\chapter{Vision Pipeline Under Real Load}

\section{Throughput vs. Thermals}
With the CPU overclocked to 2.0 GHz, the Vision Runner achieves:
\begin{itemize}
    \item \textbf{Inference}: ~280ms per frame (YOLOv11 Nano).
    \item \textbf{Effective FPS}: ~3.5 FPS.
\end{itemize}

While the codebase implements a `LatestFrameGrabber` capable of 30fps capture, the logical throughput is bound by the ONNX Runtime execution on the CPU.

\section{Memory Footprint}
\begin{itemize}
    \item \texttt{vision-runner}: \textbf{~240 MB RSS}.
    \item \textbf{Leak Check}: Stable over 1-hour run (via `LatestFrameGrabber` discarding old buffers).
\end{itemize}

\section{Thermal Impact}
Running Vision continuously drives the CPU load to 100\% on Core 3 (Pinning).
\begin{itemize}
    \item \textbf{Idle Temp}: $48^\circ$C (Measured).
    \item \textbf{Load Temp}: Rapidly approaches $70^\circ$C without active cooling.
\end{itemize}

\subsection{Optimization Strategy}
To prevent thermal throttling (which kicks in at $80^\circ$C), the system enforces a strict sleep cycle in the main loop:
\begin{lstlisting}[language=python]
# vision_runner.py
time.sleep(0.001) # Yield to OS scheduler
\end{lstlisting}
This minor yield prevents the process from dominating the Kernel schedular, allowing audio interrupts to be serviced immediately.
