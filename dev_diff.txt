diff --git a/mobile_app/app/build.gradle.kts b/mobile_app/app/build.gradle.kts
index 421fcbc..0dbe20e 100644
--- a/mobile_app/app/build.gradle.kts
+++ b/mobile_app/app/build.gradle.kts
@@ -62,6 +62,7 @@ dependencies {
     implementation("androidx.compose.ui:ui-tooling-preview")
     debugImplementation("androidx.compose.ui:ui-tooling")
     implementation("androidx.compose.material:material-icons-extended")
+    implementation("androidx.core:core-ktx:1.13.1")
 
     implementation("com.google.android.material:material:1.12.0")
 
diff --git a/mobile_app/app/src/main/AndroidManifest.xml b/mobile_app/app/src/main/AndroidManifest.xml
index d82f135..5eae3f6 100644
--- a/mobile_app/app/src/main/AndroidManifest.xml
+++ b/mobile_app/app/src/main/AndroidManifest.xml
@@ -3,6 +3,7 @@
     <uses-permission android:name="android.permission.INTERNET" />
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
     <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
+    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
 
     <application
         android:icon="@drawable/app_icon_smart_car"
diff --git a/mobile_app/app/src/main/java/com/smartcar/supervision/MainActivity.kt b/mobile_app/app/src/main/java/com/smartcar/supervision/MainActivity.kt
index f4970bb..290cc63 100644
--- a/mobile_app/app/src/main/java/com/smartcar/supervision/MainActivity.kt
+++ b/mobile_app/app/src/main/java/com/smartcar/supervision/MainActivity.kt
@@ -31,6 +31,19 @@ class MainActivity : ComponentActivity() {
                 )
             }
         }
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
+            val notificationsGranted = ContextCompat.checkSelfPermission(
+                this,
+                Manifest.permission.POST_NOTIFICATIONS
+            ) == PackageManager.PERMISSION_GRANTED
+            if (!notificationsGranted) {
+                ActivityCompat.requestPermissions(
+                    this,
+                    arrayOf(Manifest.permission.POST_NOTIFICATIONS),
+                    1002
+                )
+            }
+        }
         super.onCreate(savedInstanceState)
         setContent {
             SupervisionTheme {
diff --git a/mobile_app/app/src/main/java/com/smartcar/supervision/data/IntentModels.kt b/mobile_app/app/src/main/java/com/smartcar/supervision/data/IntentModels.kt
index 1a734b3..79105d8 100644
--- a/mobile_app/app/src/main/java/com/smartcar/supervision/data/IntentModels.kt
+++ b/mobile_app/app/src/main/java/com/smartcar/supervision/data/IntentModels.kt
@@ -2,6 +2,7 @@ package com.smartcar.supervision.data
 
 data class IntentRequest(
     val intent: String,
+    val text: String? = null,
     val direction: String? = null,
     val speed: Int? = null,
     val duration_ms: Int? = null,
diff --git a/mobile_app/app/src/main/java/com/smartcar/supervision/data/Models.kt b/mobile_app/app/src/main/java/com/smartcar/supervision/data/Models.kt
index a971ba7..87a0ad2 100644
--- a/mobile_app/app/src/main/java/com/smartcar/supervision/data/Models.kt
+++ b/mobile_app/app/src/main/java/com/smartcar/supervision/data/Models.kt
@@ -26,6 +26,10 @@ data class TelemetrySnapshot(
     val last_tts_text: String? = null,
     val last_tts_status: String? = null,
     val last_tts_ts: Long? = null,
+    val last_scan_summary: String? = null,
+    val gas_level: Int? = null,
+    val gas_warning: Boolean? = null,
+    val gas_severity: String? = null,
     val health: HealthStatus? = null,
     val remote_event: RemoteEvent? = null,
 )
diff --git a/mobile_app/app/src/main/java/com/smartcar/supervision/data/RobotRepository.kt b/mobile_app/app/src/main/java/com/smartcar/supervision/data/RobotRepository.kt
index dfaf687..6ce2546 100644
--- a/mobile_app/app/src/main/java/com/smartcar/supervision/data/RobotRepository.kt
+++ b/mobile_app/app/src/main/java/com/smartcar/supervision/data/RobotRepository.kt
@@ -106,9 +106,20 @@ class RobotRepository(
         return runCatching { api.getLogs(service, lines) }
     }
 
-    suspend fun sendIntent(intent: String, extras: Map<String, Any> = emptyMap()): IntentResult {
+    suspend fun sendIntent(
+        intent: String,
+        text: String? = null,
+        direction: String? = null,
+        speed: Int? = null,
+        durationMs: Int? = null,
+        extras: Map<String, Any> = emptyMap(),
+    ): IntentResult {
         val request = IntentRequest(
             intent = intent,
+            text = text,
+            direction = direction,
+            speed = speed,
+            duration_ms = durationMs,
             extras = if (extras.isEmpty()) null else extras,
         )
         return try {
diff --git a/mobile_app/app/src/main/java/com/smartcar/supervision/ui/AppState.kt b/mobile_app/app/src/main/java/com/smartcar/supervision/ui/AppState.kt
index b821090..b54c6c5 100644
--- a/mobile_app/app/src/main/java/com/smartcar/supervision/ui/AppState.kt
+++ b/mobile_app/app/src/main/java/com/smartcar/supervision/ui/AppState.kt
@@ -38,6 +38,8 @@ data class AppState(
     val logLinesLimit: Int = 200,
     val debugPanelVisible: Boolean = false,
     val settings: com.smartcar.supervision.data.AppSettings? = null,
+    val streamOwner: StreamOwner? = null,
+    val streamError: String? = null,
 )
 
 enum class BackendLogService(val label: String, val apiName: String) {
@@ -77,6 +79,11 @@ enum class TaskPhase {
     STOPPED,
 }
 
+enum class StreamOwner {
+    CONTROL,
+    VISION,
+}
+
 data class TaskState(
     val type: TaskType = TaskType.NONE,
     val phase: TaskPhase = TaskPhase.IDLE,
diff --git a/mobile_app/app/src/main/java/com/smartcar/supervision/ui/AppViewModel.kt b/mobile_app/app/src/main/java/com/smartcar/supervision/ui/AppViewModel.kt
index c0648e0..af571c5 100644
--- a/mobile_app/app/src/main/java/com/smartcar/supervision/ui/AppViewModel.kt
+++ b/mobile_app/app/src/main/java/com/smartcar/supervision/ui/AppViewModel.kt
@@ -32,6 +32,8 @@ class AppViewModel(
     private var logPollJob: Job? = null
     private var settingsStore: SettingsStore? = null
     private var contextBound = false
+    private var notificationHelper: GasNotificationHelper? = null
+    private var lastGasSeverity: String? = null
 
     init {
         log(LogCategory.STATE, "app_start")
@@ -43,6 +45,7 @@ class AppViewModel(
         contextBound = true
         val store = SettingsStore(context.applicationContext)
         settingsStore = store
+        notificationHelper = GasNotificationHelper(context.applicationContext).also { it.ensureChannel() }
         val (defaultIp, defaultPort) = parseDefaultIpPort()
         val settings = store.loadDefaults(defaultIp, defaultPort)
         _state.value = _state.value.copy(
@@ -79,7 +82,7 @@ class AppViewModel(
             val snapshotResult = repo.fetchSnapshotOnce()
             snapshotResult.onSuccess { snapshot ->
                 val current = _state.value
-                val remoteEvent = snapshot.telemetry?.remote_event?.let { it.toString() }
+                val remoteEvent = snapshot.telemetry?.remote_event?.event
                 _state.value = current.copy(
                     connection = ConnectionStatus.Online,
                     status = snapshot.status ?: current.status,
@@ -88,6 +91,17 @@ class AppViewModel(
                     lastTelemetryAt = if (snapshot.telemetry != null) now else current.lastTelemetryAt,
                     lastRemoteEvent = remoteEvent ?: current.lastRemoteEvent,
                 )
+                handleGasSeverityUpdate(snapshot.telemetry)
+                if (remoteEvent != null && remoteEvent != current.lastRemoteEvent) {
+                    log(
+                        LogCategory.STATE,
+                        "remote_event",
+                        data = mapOf(
+                            "event" to remoteEvent,
+                            "payload" to snapshot.telemetry?.remote_event,
+                        )
+                    )
+                }
                 log(LogCategory.NETWORK, "refresh_ok")
             }.onFailure { err ->
                 _state.value = _state.value.copy(
@@ -115,7 +129,7 @@ class AppViewModel(
                 _state.value = _state.value.copy(lastConnectAttemptAt = now)
                 result.onSuccess { snapshot ->
                     val current = _state.value
-                    val remoteEvent = snapshot.telemetry?.remote_event?.let { it.toString() }
+                    val remoteEvent = snapshot.telemetry?.remote_event?.event
                     _state.value = current.copy(
                         connection = ConnectionStatus.Online,
                         status = snapshot.status ?: current.status,
@@ -124,6 +138,17 @@ class AppViewModel(
                         lastTelemetryAt = if (snapshot.telemetry != null) now else current.lastTelemetryAt,
                         lastRemoteEvent = remoteEvent ?: current.lastRemoteEvent,
                     )
+                    handleGasSeverityUpdate(snapshot.telemetry)
+                    if (remoteEvent != null && remoteEvent != current.lastRemoteEvent) {
+                        log(
+                            LogCategory.STATE,
+                            "remote_event",
+                            data = mapOf(
+                                "event" to remoteEvent,
+                                "payload" to snapshot.telemetry?.remote_event,
+                            )
+                        )
+                    }
                     if (now - lastTelemetryLogAt > 30_000) {
                         log(LogCategory.NETWORK, "telemetry_ok")
                         lastTelemetryLogAt = now
@@ -200,6 +225,10 @@ class AppViewModel(
 
     fun sendIntent(
         intent: String,
+        text: String? = null,
+        direction: String? = null,
+        speed: Int? = null,
+        durationMs: Int? = null,
         extras: Map<String, Any> = emptyMap(),
         onComplete: ((IntentResult) -> Unit)? = null,
     ) {
@@ -207,9 +236,10 @@ class AppViewModel(
             val baseUrl = _state.value.settings?.baseUrl() ?: BuildConfig.ROBOT_BASE_URL
             val payload = mapOf(
                 "intent" to intent,
-                "direction" to extras["direction"],
-                "speed" to extras["speed"],
-                "duration_ms" to extras["duration_ms"],
+                "text" to text,
+                "direction" to direction,
+                "speed" to speed,
+                "duration_ms" to durationMs,
                 "extras" to if (extras.isEmpty()) null else extras,
             )
             _state.value = _state.value.copy(intentInFlight = true)
@@ -224,7 +254,14 @@ class AppViewModel(
                 )
             )
             refreshAppStatus()
-            val result = repo.sendIntent(intent, extras)
+            val result = repo.sendIntent(
+                intent = intent,
+                text = text,
+                direction = direction,
+                speed = speed,
+                durationMs = durationMs,
+                extras = extras,
+            )
             val message = when (result) {
                 is IntentResult.Accepted -> "accepted"
                 is IntentResult.Rejected -> "rejected: ${result.reason}"
@@ -361,6 +398,22 @@ class AppViewModel(
         log(LogCategory.STATE, "log_clear")
     }
 
+    fun requestStream(owner: StreamOwner, enabled: Boolean): Boolean {
+        val current = _state.value.streamOwner
+        if (enabled) {
+            if (current == null || current == owner) {
+                _state.value = _state.value.copy(streamOwner = owner, streamError = null)
+                return true
+            }
+            _state.value = _state.value.copy(streamError = "stream_in_use_by_${current.name.lowercase()}")
+            return false
+        }
+        if (current == owner) {
+            _state.value = _state.value.copy(streamOwner = null, streamError = null)
+        }
+        return true
+    }
+
     private fun log(
         category: LogCategory,
         event: String,
@@ -494,4 +547,21 @@ class AppViewModel(
             host to port
         }
     }
+
+    private fun handleGasSeverityUpdate(telemetry: com.smartcar.supervision.data.TelemetrySnapshot?) {
+        val severity = telemetry?.gas_severity ?: telemetry?.gas_warning?.let { if (it) "warning" else "clear" }
+        if (severity == null) return
+        if (severity == lastGasSeverity) return
+        lastGasSeverity = severity
+        val level = telemetry?.gas_level
+        val helper = notificationHelper
+        if (helper == null) return
+        if (severity == "warning" || severity == "danger") {
+            helper.showAlert(severity, level)
+            log(LogCategory.STATE, "gas_alert", data = mapOf("severity" to severity, "level" to level))
+        } else if (severity == "clear") {
+            helper.clear()
+            log(LogCategory.STATE, "gas_clear", data = mapOf("level" to level))
+        }
+    }
 }
diff --git a/mobile_app/app/src/main/java/com/smartcar/supervision/ui/screens/MainScreen.kt b/mobile_app/app/src/main/java/com/smartcar/supervision/ui/screens/MainScreen.kt
index 4b8f431..5e5cff4 100644
--- a/mobile_app/app/src/main/java/com/smartcar/supervision/ui/screens/MainScreen.kt
+++ b/mobile_app/app/src/main/java/com/smartcar/supervision/ui/screens/MainScreen.kt
@@ -1,1281 +1,1594 @@
 package com.smartcar.supervision.ui.screens
 
-import android.graphics.Bitmap
 import android.graphics.BitmapFactory
-import android.view.ViewGroup
-import android.widget.ImageView
-import androidx.compose.foundation.layout.Arrangement
-import androidx.compose.foundation.layout.Column
-import androidx.compose.foundation.layout.Row
-import androidx.compose.foundation.layout.Spacer
-import androidx.compose.foundation.layout.fillMaxSize
-import androidx.compose.foundation.layout.fillMaxWidth
-import androidx.compose.foundation.layout.height
-import androidx.compose.foundation.layout.padding
-import androidx.compose.foundation.layout.width
+import androidx.compose.animation.AnimatedVisibility
+import androidx.compose.animation.expandVertically
+import androidx.compose.animation.shrinkVertically
+import androidx.compose.foundation.Image
+import androidx.compose.foundation.background
+import androidx.compose.foundation.clickable
+import androidx.compose.foundation.layout.*
+import androidx.compose.foundation.lazy.LazyColumn
+import androidx.compose.foundation.lazy.items
 import androidx.compose.foundation.rememberScrollState
+import androidx.compose.foundation.shape.CircleShape
+import androidx.compose.foundation.shape.RoundedCornerShape
+import androidx.compose.foundation.text.KeyboardOptions
 import androidx.compose.foundation.verticalScroll
 import androidx.compose.material.icons.Icons
-import androidx.compose.material.icons.filled.Info
-import androidx.compose.material.icons.filled.Settings
-import androidx.compose.material.icons.filled.Tune
-import androidx.compose.material.icons.filled.Visibility
-import androidx.compose.material.icons.filled.Refresh
-import androidx.compose.material3.AlertDialog
-import androidx.compose.material3.Button
-import androidx.compose.material3.Card
-import androidx.compose.material3.HorizontalDivider
-import androidx.compose.material3.ExperimentalMaterial3Api
-import androidx.compose.material3.Icon
-import androidx.compose.material3.IconButton
-import androidx.compose.material3.MaterialTheme
-import androidx.compose.material3.NavigationBar
-import androidx.compose.material3.NavigationBarItem
-import androidx.compose.material3.OutlinedTextField
-import androidx.compose.material3.Scaffold
-import androidx.compose.material3.Switch
-import androidx.compose.material3.Text
-import androidx.compose.material3.TextButton
-import androidx.compose.material3.TopAppBar
-import androidx.compose.runtime.Composable
-import androidx.compose.runtime.DisposableEffect
-import androidx.compose.runtime.LaunchedEffect
-import androidx.compose.runtime.getValue
-import androidx.compose.runtime.mutableStateOf
-import androidx.compose.runtime.remember
-import androidx.compose.runtime.rememberCoroutineScope
-import androidx.compose.runtime.saveable.rememberSaveable
-import androidx.compose.runtime.setValue
+import androidx.compose.material.icons.automirrored.filled.ArrowBack
+import androidx.compose.material.icons.automirrored.filled.ArrowForward
+import androidx.compose.material.icons.filled.*
+import androidx.compose.material3.*
+import androidx.compose.runtime.*
+import androidx.compose.ui.Alignment
 import androidx.compose.ui.Modifier
+import androidx.compose.ui.draw.clip
+import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.graphics.asImageBitmap
+import androidx.compose.ui.layout.ContentScale
 import androidx.compose.ui.platform.LocalContext
-import androidx.compose.ui.text.style.TextOverflow
+import androidx.compose.ui.text.font.FontFamily
+import androidx.compose.ui.text.font.FontWeight
+import androidx.compose.ui.text.input.KeyboardType
+import androidx.compose.ui.text.style.TextAlign
 import androidx.compose.ui.unit.dp
-import androidx.compose.ui.viewinterop.AndroidView
-import androidx.lifecycle.compose.collectAsStateWithLifecycle
-import kotlinx.coroutines.CancellationException
+import androidx.compose.ui.unit.sp
+import com.smartcar.supervision.BuildConfig
+import com.smartcar.supervision.data.AppSettings
+import com.smartcar.supervision.ui.*
 import kotlinx.coroutines.Dispatchers
 import kotlinx.coroutines.isActive
-import kotlinx.coroutines.launch
 import kotlinx.coroutines.withContext
 import okhttp3.OkHttpClient
 import okhttp3.Request
-import com.smartcar.supervision.BuildConfig
-import com.smartcar.supervision.data.AppSettings
-import com.smartcar.supervision.ui.AppStatus
-import com.smartcar.supervision.ui.BackendLogService
-import com.smartcar.supervision.ui.AppViewModel
-import com.smartcar.supervision.ui.ConnectionStatus
-import com.smartcar.supervision.ui.LogCategory
-import com.smartcar.supervision.ui.TaskPhase
-import com.smartcar.supervision.ui.TaskType
-import java.time.Instant
-import java.time.ZoneId
-import java.time.format.DateTimeFormatter
-
-private enum class MainTab(val label: String) {
-    HOME("HOME"),
-    CONTROL("CTRL"),
-    VISION("VSN"),
-    SENSORS("SNS"),
-    LOGS("LOGS"),
-    SETTINGS("SET"),
+import java.io.BufferedInputStream
+import java.io.ByteArrayOutputStream
+import java.util.concurrent.TimeUnit
+
+// =============================================================================
+// TAB ENUM
+// =============================================================================
+enum class MainTab(val label: String, val icon: @Composable () -> Unit) {
+    HOME("Home", { Icon(Icons.Default.Home, contentDescription = "Home") }),
+    TASK("Task", { Icon(Icons.Default.Assignment, contentDescription = "Task") }),
+    CONTROL("Control", { Icon(Icons.Default.Gamepad, contentDescription = "Control") }),
+    VISION("Vision", { Icon(Icons.Default.RemoveRedEye, contentDescription = "Vision") }),
+    SENSORS("Sensors", { Icon(Icons.Default.Sensors, contentDescription = "Sensors") }),
+    LOGS("Logs", { Icon(Icons.Default.Article, contentDescription = "Logs") }),
+    SETTINGS("Settings", { Icon(Icons.Default.Settings, contentDescription = "Settings") }),
 }
 
-@Composable
+// =============================================================================
+// MAIN SCREEN COMPOSABLE - OPERATOR-FIRST DESIGN
+// =============================================================================
 @OptIn(ExperimentalMaterial3Api::class)
+@Composable
 fun MainScreen(viewModel: AppViewModel) {
-    val state by viewModel.state.collectAsStateWithLifecycle()
     val context = LocalContext.current
-    var selectedTab by rememberSaveable { mutableStateOf(MainTab.HOME) }
+    LaunchedEffect(Unit) { viewModel.bindContext(context) }
 
-    LaunchedEffect(Unit) {
-        viewModel.bindContext(context)
-    }
+    val state by viewModel.state.collectAsState()
+    var selectedTab by remember { mutableStateOf(MainTab.HOME) }
 
     Scaffold(
         topBar = {
             TopAppBar(
                 title = {
-                    Column(verticalArrangement = Arrangement.spacedBy(2.dp)) {
-                        Text("Smart Car Console")
-                        Text(
-                            "${state.appStatus} ??? ${connectionLabel(state.connection)} ??? ${state.blockingReason ?: "ready"}",
-                            style = MaterialTheme.typography.labelSmall
-                        )
+                    Row(verticalAlignment = Alignment.CenterVertically) {
+                        Text("SmartCar", fontWeight = FontWeight.Bold)
+                        Spacer(Modifier.width(8.dp))
+                        ConnectionIndicator(state.connection, state.appStatus)
                     }
                 },
-                actions = {
-                    IconButton(onClick = { viewModel.refreshNow() }) {
-                        Icon(imageVector = Icons.Filled.Refresh, contentDescription = "Refresh")
-                    }
-                }
+                colors = TopAppBarDefaults.topAppBarColors(
+                    containerColor = MaterialTheme.colorScheme.primaryContainer,
+                )
             )
         },
         bottomBar = {
-            NavigationBar {
-                NavigationBarItem(
-                    selected = selectedTab == MainTab.HOME,
-                    onClick = { selectedTab = MainTab.HOME },
-                    icon = { Icon(Icons.Filled.Info, contentDescription = null) },
-                    label = { Text(MainTab.HOME.label) },
-                )
-                NavigationBarItem(
-                    selected = selectedTab == MainTab.CONTROL,
-                    onClick = { selectedTab = MainTab.CONTROL },
-                    icon = { Icon(Icons.Filled.Tune, contentDescription = null) },
-                    label = { Text(MainTab.CONTROL.label) },
-                )
-                NavigationBarItem(
-                    selected = selectedTab == MainTab.VISION,
-                    onClick = { selectedTab = MainTab.VISION },
-                    icon = { Icon(Icons.Filled.Visibility, contentDescription = null) },
-                    label = { Text(MainTab.VISION.label) },
-                )
-                NavigationBarItem(
-                    selected = selectedTab == MainTab.SENSORS,
-                    onClick = { selectedTab = MainTab.SENSORS },
-                    icon = { Icon(Icons.Filled.Tune, contentDescription = null) },
-                    label = { Text(MainTab.SENSORS.label) },
-                )
-                NavigationBarItem(
-                    selected = selectedTab == MainTab.LOGS,
-                    onClick = { selectedTab = MainTab.LOGS },
-                    icon = { Icon(Icons.Filled.Info, contentDescription = null) },
-                    label = { Text(MainTab.LOGS.label) },
-                )
-                NavigationBarItem(
-                    selected = selectedTab == MainTab.SETTINGS,
-                    onClick = { selectedTab = MainTab.SETTINGS },
-                    icon = { Icon(Icons.Filled.Settings, contentDescription = null) },
-                    label = { Text(MainTab.SETTINGS.label) },
-                )
+            StopCenterNavigationBar(
+                selectedTab = selectedTab,
+                onTabSelected = { selectedTab = it },
+                onStop = {
+                    viewModel.sendIntent("stop")
+                    viewModel.logUiAction("stop_pressed", true, null)
+                }
+            )
+        }
+    ) { padding ->
+        Box(modifier = Modifier.padding(padding)) {
+            when (selectedTab) {
+                MainTab.HOME -> HomeScreen(state, viewModel)
+                MainTab.TASK -> TaskScreen(state)
+                MainTab.CONTROL -> ControlScreen(state, viewModel)
+                MainTab.VISION -> VisionScreen(state, viewModel)
+                MainTab.SENSORS -> SensorsScreen(state)
+                MainTab.LOGS -> LogsScreen(state, viewModel)
+                MainTab.SETTINGS -> SettingsScreen(state, viewModel)
             }
         }
-    ) { innerPadding ->
-        val contentModifier = Modifier
-            .fillMaxSize()
-            .padding(innerPadding)
+    }
+}
 
-        when (selectedTab) {
-            MainTab.HOME -> HomeScreen(
-                modifier = contentModifier,
-                viewModel = viewModel,
-                onOpenSettings = { selectedTab = MainTab.SETTINGS },
-            )
-            MainTab.CONTROL -> ControlScreen(
-                modifier = contentModifier,
-                viewModel = viewModel,
-                onOpenStatus = { selectedTab = MainTab.HOME },
-                onOpenSettings = { selectedTab = MainTab.SETTINGS },
-            )
-            MainTab.SENSORS -> SensorsScreen(
-                modifier = contentModifier,
-                viewModel = viewModel,
-            )
-            MainTab.VISION -> VisionScreen(
-                modifier = contentModifier,
-                viewModel = viewModel,
-                onOpenSettings = { selectedTab = MainTab.SETTINGS },
-            )
-            MainTab.LOGS -> LogsScreen(
-                modifier = contentModifier,
-                viewModel = viewModel,
-            )
-            MainTab.SETTINGS -> SettingsScreen(
-                modifier = contentModifier,
-                viewModel = viewModel,
-            )
+// =============================================================================
+// CONNECTION INDICATOR
+// =============================================================================
+@Composable
+fun ConnectionIndicator(connection: ConnectionStatus, appStatus: AppStatus) {
+    val (color, label) = when (connection) {
+        ConnectionStatus.Online -> when (appStatus) {
+            AppStatus.ONLINE_IDLE -> Color(0xFF4CAF50) to "Ready"
+            AppStatus.ONLINE_BUSY -> Color(0xFFFF9800) to "Busy"
+            AppStatus.ONLINE_EXECUTING_TASK -> Color(0xFFFF9800) to "Task"
+            else -> Color(0xFF4CAF50) to "Online"
         }
+        ConnectionStatus.Offline -> Color(0xFF9E9E9E) to "Offline"
+        is ConnectionStatus.Error -> Color(0xFFF44336) to "Error"
+    }
+    Row(verticalAlignment = Alignment.CenterVertically) {
+        Box(
+            modifier = Modifier
+                .size(10.dp)
+                .clip(CircleShape)
+                .background(color)
+        )
+        Spacer(Modifier.width(4.dp))
+        Text(label, fontSize = 12.sp, color = MaterialTheme.colorScheme.onPrimaryContainer)
     }
 }
 
+// =============================================================================
+// STOP-CENTER NAVIGATION BAR
+// =============================================================================
 @Composable
-private fun HomeScreen(
-    modifier: Modifier,
-    viewModel: AppViewModel,
-    onOpenSettings: () -> Unit,
+fun StopCenterNavigationBar(
+    selectedTab: MainTab,
+    onTabSelected: (MainTab) -> Unit,
+    onStop: () -> Unit,
 ) {
-    val state by viewModel.state.collectAsStateWithLifecycle()
-    val now = System.currentTimeMillis()
-    val sessionActive = (state.telemetry?.remote_session_active == true) || (state.status?.remote_session_active == true)
-    val lastIntentAge = state.lastIntentAt?.let { now - it }
-    val commandRecent = lastIntentAge != null && lastIntentAge < 5_000
-    val lastIntentLabel = state.lastIntentSent ?: "UNAVAILABLE"
-    val motor = state.telemetry?.motor
-    val motorActive = motor?.let { it.left != 0 || it.right != 0 } ?: false
-    val safety = state.telemetry?.sensor
+    Surface(tonalElevation = 3.dp) {
+        Row(
+            modifier = Modifier
+                .fillMaxWidth()
+                .padding(vertical = 6.dp, horizontal = 8.dp),
+            verticalAlignment = Alignment.CenterVertically,
+            horizontalArrangement = Arrangement.SpaceBetween,
+        ) {
+            val leftTabs = listOf(MainTab.HOME, MainTab.TASK, MainTab.CONTROL)
+            val rightTabs = listOf(MainTab.VISION, MainTab.SENSORS, MainTab.LOGS, MainTab.SETTINGS)
 
-    Column(
-        modifier = modifier
-            .verticalScroll(rememberScrollState())
-            .padding(16.dp),
-        verticalArrangement = Arrangement.spacedBy(12.dp)
-    ) {
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
-                Text("Robot Status", style = MaterialTheme.typography.titleLarge)
-                val statusLabel = when (state.appStatus) {
-                    AppStatus.ONLINE_IDLE -> "READY"
-                    AppStatus.ONLINE_BUSY -> "BUSY"
-                    AppStatus.ONLINE_EXECUTING_TASK -> "BUSY"
-                    AppStatus.ERROR -> "ERROR"
-                    AppStatus.OFFLINE, AppStatus.CONNECTING -> "OFFLINE"
+            Row(modifier = Modifier.weight(1f), horizontalArrangement = Arrangement.SpaceEvenly) {
+                leftTabs.forEach { tab ->
+                    NavItem(tab = tab, selected = selectedTab == tab, onClick = { onTabSelected(tab) })
                 }
-                Text(statusLabel, style = MaterialTheme.typography.headlineSmall)
-                Text(
-                    "Connection: " + when (state.connection) {
-                        ConnectionStatus.Online -> "ONLINE"
-                        ConnectionStatus.Offline -> "OFFLINE"
-                        is ConnectionStatus.Error -> "ERROR"
-                    }
+            }
+
+            Box(
+                modifier = Modifier
+                    .size(64.dp)
+                    .clip(CircleShape)
+                    .background(Color(0xFFD32F2F))
+                    .clickable { onStop() },
+                contentAlignment = Alignment.Center
+            ) {
+                Icon(
+                    Icons.Default.Stop,
+                    contentDescription = "Emergency Stop",
+                    tint = Color.White,
+                    modifier = Modifier.size(32.dp)
                 )
-                Text("Blocking: ${state.blockingReason ?: "UNAVAILABLE"}")
-                Text("Remote session: ${triState(sessionActive)}")
-                Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
-                    Button(onClick = { viewModel.refreshNow() }) { Text("Retry now") }
-                    TextButton(onClick = onOpenSettings) { Text("Open settings") }
+            }
+
+            Row(modifier = Modifier.weight(1f), horizontalArrangement = Arrangement.SpaceEvenly) {
+                rightTabs.forEach { tab ->
+                    NavItem(tab = tab, selected = selectedTab == tab, onClick = { onTabSelected(tab) })
                 }
             }
         }
+    }
+}
+
+@Composable
+fun NavItem(tab: MainTab, selected: Boolean, onClick: () -> Unit) {
+    val color = if (selected) MaterialTheme.colorScheme.primary else Color.Gray
+    Column(
+        horizontalAlignment = Alignment.CenterHorizontally,
+        modifier = Modifier
+            .padding(horizontal = 2.dp, vertical = 4.dp)
+            .clickable { onClick() }
+    ) {
+        CompositionLocalProvider(LocalContentColor provides color) {
+            tab.icon()
+        }
+        Text(tab.label, fontSize = 10.sp, color = color)
+    }
+}
 
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                Text("System snapshot", style = MaterialTheme.typography.titleMedium)
-                Text("Task: ${state.task.label.ifBlank { "UNAVAILABLE" }}")
-                Text("Last command: $lastIntentLabel")
-                Text("Last result: ${state.lastIntentResult ?: "UNAVAILABLE"}")
-                if (commandRecent) {
-                    Text("Command sent @ ${formatTimestamp(state.lastIntentAt)}")
-                }
-                Text("Motor active: ${triState(motorActive)}")
-                Text("Vision mode: ${confidenceLabel(state.telemetry?.vision_mode, state.lastTelemetryAt)}")
+// =============================================================================
+// HOME SCREEN - READ-ONLY STATUS DISPLAY
+// =============================================================================
+@Composable
+fun HomeScreen(state: AppState, viewModel: AppViewModel) {
+    Column(
+        modifier = Modifier
+            .fillMaxSize()
+            .verticalScroll(rememberScrollState())
+            .padding(16.dp)
+    ) {
+        Text("System Status", style = MaterialTheme.typography.headlineMedium)
+        Spacer(Modifier.height(16.dp))
+
+        // Connection Status Card
+        StatusCard("Connection") {
+            val connText = when (state.connection) {
+                ConnectionStatus.Online -> "Online"
+                ConnectionStatus.Offline -> "Offline"
+                is ConnectionStatus.Error -> "Error: ${state.connection.message}"
             }
+            StatusRow("Status", connText)
+            StatusRow("App Status", state.appStatus.name)
+            state.blockingReason?.let { StatusRow("Blocking", it) }
+            state.lastConnectAttemptAt?.let { StatusRow("Last Attempt", formatTime(it)) }
         }
 
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                Text("Safety", style = MaterialTheme.typography.titleMedium)
-                Text("Is safe: ${confidenceLabel(safety?.is_safe, state.telemetry?.sensor_ts)}")
-                Text("Obstacle: ${confidenceLabel(safety?.obstacle, state.telemetry?.sensor_ts)}")
-                Text("Warning: ${confidenceLabel(safety?.warning, state.telemetry?.sensor_ts)}")
-                Text("Sensor buffer: ${state.telemetry?.sensor_buffer ?: "UNAVAILABLE"}")
+        Spacer(Modifier.height(12.dp))
+
+        // Robot Status Card
+        StatusCard("Robot State") {
+            state.telemetry?.let { t ->
+                StatusRow("Mode", t.mode ?: "-")
+                StatusRow("Remote Session", if (t.remote_session_active == true) "Active" else "Inactive")
+                StatusRow("Motor Enabled", if (t.motor_enabled == true) "Yes" else "No")
+                StatusRow("Safety Stop", if (t.safety_stop == true) "ACTIVE" else "Clear")
+                t.safety_alert?.let { StatusRow("Safety Alert", it) }
+                StatusRow("Vision Active", if (t.vision_active == true) "Yes" else "No")
+                t.vision_mode?.let { StatusRow("Vision Mode", it) }
+            } ?: Text("No telemetry data", color = Color.Gray)
+        }
+
+        Spacer(Modifier.height(12.dp))
+
+        // Last Activity Card
+        StatusCard("Recent Activity") {
+            state.lastIntentSent?.let { StatusRow("Last Intent", it) }
+            state.lastIntentResult?.let { StatusRow("Result", it) }
+            state.lastIntentAt?.let { StatusRow("Sent At", formatTime(it)) }
+            state.lastRemoteEvent?.let { StatusRow("Last Event", it) }
+            if (state.task.type != TaskType.NONE) {
+                StatusRow("Task", "${state.task.type} - ${state.task.phase}")
+                StatusRow("Task Label", state.task.label)
             }
         }
 
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                Text("Quick indicators", style = MaterialTheme.typography.titleMedium)
-                val llm = state.telemetry?.last_llm_response ?: "UNAVAILABLE"
-                val tts = state.telemetry?.last_tts_text ?: "UNAVAILABLE"
-                val ttsStatus = state.telemetry?.last_tts_status ?: "UNAVAILABLE"
-                val det = state.telemetry?.vision_last_detection
-                Text("Last LLM response: ${confidenceLabel(llm, state.telemetry?.last_llm_ts)}")
-                Text("Last TTS: ${confidenceLabel(tts, state.telemetry?.last_tts_ts)}")
-                Text("TTS status: $ttsStatus")
-                if (det == null) {
-                    Text("Last detection: UNAVAILABLE")
-                } else {
-                    Text("Last detection: ${det.label ?: "UNAVAILABLE"} conf=${det.confidence ?: "?"}")
-                }
+        Spacer(Modifier.height(12.dp))
+
+        // LLM/TTS Status
+        state.telemetry?.let { t ->
+            StatusCard("AI / Voice") {
+                t.last_llm_response?.let { StatusRow("LLM Response", it.take(100) + if (it.length > 100) "..." else "") }
+                t.last_tts_text?.let { StatusRow("TTS Text", it.take(50) + if (it.length > 50) "..." else "") }
+                t.last_tts_status?.let { StatusRow("TTS Status", it) }
+                t.last_scan_summary?.let { StatusRow("Scan Summary", it.take(100) + if (it.length > 100) "..." else "") }
             }
         }
-        Spacer(modifier = Modifier.height(12.dp))
+
+        Spacer(Modifier.height(12.dp))
+
+        // Health Status
+        StatusCard("Health") {
+            state.health?.let { h ->
+                StatusRow("Health OK", if (h.ok == true) "Yes" else "No")
+                h.timestamp?.let { StatusRow("Checked At", formatTime(it * 1000)) }
+            } ?: Text("No health data", color = Color.Gray)
+        }
     }
 }
 
 @Composable
-private fun ControlScreen(
-    modifier: Modifier,
-    viewModel: AppViewModel,
-    onOpenStatus: () -> Unit,
-    onOpenSettings: () -> Unit,
-) {
-    val state by viewModel.state.collectAsStateWithLifecycle()
-    val intentsEnabled = state.appStatus == AppStatus.ONLINE_IDLE
-    val sessionActive = (state.telemetry?.remote_session_active == true) || (state.status?.remote_session_active == true)
-    val stopEnabled = sessionActive
-    val lastIntentAge = state.lastIntentAt?.let { System.currentTimeMillis() - it }
-    val commandRecent = lastIntentAge != null && lastIntentAge < 5_000
-    val lastIntentLabel = state.lastIntentSent ?: "UNAVAILABLE"
-    val hasFailure = state.connection is ConnectionStatus.Error || !sessionActive ||
-        state.lastIntentResult?.startsWith("rejected") == true ||
-        state.lastIntentResult?.startsWith("timed_out") == true ||
-        state.lastIntentResult?.startsWith("failed") == true
-    var confirmScan by rememberSaveable { mutableStateOf(false) }
-    var confirmStop by rememberSaveable { mutableStateOf(false) }
-    var confirmStartForward by rememberSaveable { mutableStateOf(false) }
-    var actionBlockedReason by rememberSaveable { mutableStateOf<String?>(null) }
-    var customMessage by rememberSaveable { mutableStateOf("") }
+fun StatusCard(title: String, content: @Composable ColumnScope.() -> Unit) {
+    Card(
+        modifier = Modifier.fillMaxWidth(),
+        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
+    ) {
+        Column(modifier = Modifier.padding(12.dp)) {
+            Text(title, fontWeight = FontWeight.Bold, fontSize = 14.sp)
+            Spacer(Modifier.height(8.dp))
+            content()
+        }
+    }
+}
+
+@Composable
+fun StatusRow(label: String, value: String) {
+    Row(
+        modifier = Modifier
+            .fillMaxWidth()
+            .padding(vertical = 2.dp),
+        horizontalArrangement = Arrangement.SpaceBetween
+    ) {
+        Text(label, fontSize = 12.sp, color = Color.Gray)
+        Text(value, fontSize = 12.sp, fontWeight = FontWeight.Medium)
+    }
+}
+
+@Composable
+fun StatusRowColored(label: String, value: String, valueColor: Color) {
+    Row(
+        modifier = Modifier
+            .fillMaxWidth()
+            .padding(vertical = 2.dp),
+        horizontalArrangement = Arrangement.SpaceBetween
+    ) {
+        Text(label, fontSize = 12.sp, color = Color.Gray)
+        Text(value, fontSize = 12.sp, fontWeight = FontWeight.Medium, color = valueColor)
+    }
+}
+
+// =============================================================================
+// CONTROL SCREEN - WITH EMBEDDED STREAM (NON-NEGOTIABLE)
+// =============================================================================
+@Composable
+fun ControlScreen(state: AppState, viewModel: AppViewModel) {
+    val baseUrl = state.settings?.baseUrl() ?: BuildConfig.ROBOT_BASE_URL
+    val streamUrl = baseUrl.trimEnd('/') + "/stream/mjpeg"
+    val streamOwner = state.streamOwner
+    val streamEnabled = streamOwner == StreamOwner.CONTROL
+    val streamLockedByOther = streamOwner != null && streamOwner != StreamOwner.CONTROL
 
     Column(
-        modifier = modifier
-            .verticalScroll(rememberScrollState())
-            .padding(16.dp),
-        verticalArrangement = Arrangement.spacedBy(12.dp)
+        modifier = Modifier
+            .fillMaxSize()
+            .padding(16.dp)
     ) {
-        if (!intentsEnabled || !sessionActive) {
-            Card {
-                Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                    Text("Control offline", style = MaterialTheme.typography.titleMedium)
-                    Text("Reason: ${state.blockingReason ?: "session inactive"}")
-                    Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
-                        TextButton(onClick = onOpenStatus) { Text("View status") }
-                        TextButton(onClick = onOpenSettings) { Text("Open settings") }
-                    }
+        // Stream Toggle
+        Row(
+            modifier = Modifier.fillMaxWidth(),
+            horizontalArrangement = Arrangement.SpaceBetween,
+            verticalAlignment = Alignment.CenterVertically
+        ) {
+            Text("Live Stream", fontWeight = FontWeight.Bold)
+            Switch(
+                checked = streamEnabled,
+                onCheckedChange = { 
+                    val allowed = viewModel.requestStream(StreamOwner.CONTROL, it)
+                    val blockedReason = if (!allowed) "stream_in_use" else null
+                    viewModel.logUiAction("stream_toggle", allowed, blockedReason)
                 }
+            )
+        }
+
+        if (streamLockedByOther) {
+            Spacer(Modifier.height(4.dp))
+            Text("Stream already active in Vision screen", color = Color.Red, fontSize = 12.sp)
+        }
+
+        // MJPEG Stream View - EMBEDDED IN CONTROL (NON-NEGOTIABLE)
+        if (streamEnabled) {
+            Spacer(Modifier.height(8.dp))
+            Card(
+                modifier = Modifier
+                    .fillMaxWidth()
+                    .aspectRatio(16f / 9f),
+                colors = CardDefaults.cardColors(containerColor = Color.Black)
+            ) {
+                MjpegStreamView(
+                    url = streamUrl,
+                    modifier = Modifier.fillMaxSize()
+                )
             }
         }
 
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                Text("Task Flow", style = MaterialTheme.typography.titleMedium)
-                Text("Task: ${state.task.type}")
-                Text("Phase: ${state.task.phase}")
-                Text("Status: ${state.task.label}")
-                Text("Blocking: ${state.blockingReason ?: "none"}")
-                Button(
-                    onClick = {
-                        val blocked = if (intentsEnabled) null else state.blockingReason ?: "invalid_state"
-                        viewModel.logUiAction("start_scan_observe_stop", intentsEnabled, blocked)
-                        if (intentsEnabled) {
-                            confirmScan = true
-                        } else {
-                            actionBlockedReason = state.blockingReason ?: "invalid_state"
-                        }
-                    },
-                    enabled = intentsEnabled
-                ) {
-                    Text("Start scan ??? observe ??? stop")
-                }
-                Button(
-                    onClick = {
-                        val allowed = intentsEnabled && state.task.phase == TaskPhase.OBSERVE
-                        val blocked = if (allowed) null else state.blockingReason ?: "invalid_state"
-                        viewModel.logUiAction("mark_observe", allowed, blocked)
-                        if (intentsEnabled && state.task.phase == TaskPhase.OBSERVE) {
-                            viewModel.markObservation()
-                        } else {
-                            actionBlockedReason = state.blockingReason ?: "invalid_state"
-                        }
-                    },
-                    enabled = intentsEnabled && state.task.phase == TaskPhase.OBSERVE
-                ) {
-                    Text("Mark observe")
+        Spacer(Modifier.height(16.dp))
+
+        // CONTROL BUTTONS - ALWAYS VISIBLE, ALWAYS ENABLED, ALWAYS RESPONSIVE
+        Text("Movement Controls", fontWeight = FontWeight.Bold)
+        Spacer(Modifier.height(8.dp))
+
+        val canControl = state.connection == ConnectionStatus.Online &&
+            state.telemetry?.remote_session_active == true &&
+            !state.intentInFlight
+
+        // Control Grid
+        Column(
+            modifier = Modifier.fillMaxWidth(),
+            horizontalAlignment = Alignment.CenterHorizontally,
+        ) {
+            // Forward Button
+            ControlButton(
+                label = "FORWARD",
+                icon = Icons.Default.KeyboardArrowUp,
+                enabled = canControl,
+                onClick = {
+                    viewModel.logUiAction("forward", canControl, if (!canControl) "control_disabled" else null)
+                    if (canControl) viewModel.sendIntent("start_motion", direction = "forward")
                 }
-                Button(
+            )
+            
+            Spacer(Modifier.height(8.dp))
+
+            // Left - Right Row (STOP is always in bottom nav)
+            Row(
+                modifier = Modifier.fillMaxWidth(),
+                horizontalArrangement = Arrangement.SpaceEvenly
+            ) {
+                ControlButton(
+                    label = "LEFT",
+                    icon = Icons.AutoMirrored.Filled.ArrowBack,
+                    enabled = canControl,
                     onClick = {
-                        val allowed = stopEnabled && state.task.type != TaskType.NONE
-                        val blocked = if (allowed) null else state.blockingReason ?: "invalid_state"
-                        viewModel.logUiAction("stop_task", allowed, blocked)
-                        if (stopEnabled && state.task.type != TaskType.NONE) {
-                            confirmStop = true
-                        } else {
-                            actionBlockedReason = state.blockingReason ?: "invalid_state"
-                        }
-                    },
-                    enabled = stopEnabled && state.task.type != TaskType.NONE
-                ) {
-                    Text("Stop task")
-                }
-                Button(
+                        viewModel.logUiAction("rotate_left", canControl, if (!canControl) "control_disabled" else null)
+                        if (canControl) viewModel.sendIntent("rotate_left", direction = "left")
+                    }
+                )
+                
+                ControlButton(
+                    label = "RIGHT",
+                    icon = Icons.AutoMirrored.Filled.ArrowForward,
+                    enabled = canControl,
                     onClick = {
-                        val allowed = !state.intentInFlight && state.task.type != TaskType.NONE
-                        val blocked = if (allowed) null else state.blockingReason ?: "invalid_state"
-                        viewModel.logUiAction("clear_task", allowed, blocked)
-                        if (!state.intentInFlight && state.task.type != TaskType.NONE) {
-                            viewModel.clearTask()
-                        } else {
-                            actionBlockedReason = state.blockingReason ?: "invalid_state"
-                        }
-                    },
-                    enabled = !state.intentInFlight && state.task.type != TaskType.NONE
-                ) {
-                    Text("Clear task")
-                }
+                        viewModel.logUiAction("rotate_right", canControl, if (!canControl) "control_disabled" else null)
+                        if (canControl) viewModel.sendIntent("rotate_right", direction = "right")
+                    }
+                )
             }
+            
+            Spacer(Modifier.height(8.dp))
+
+            // Backward Button
+            ControlButton(
+                label = "BACKWARD",
+                icon = Icons.Default.KeyboardArrowDown,
+                enabled = canControl,
+                onClick = {
+                    viewModel.logUiAction("backward", canControl, if (!canControl) "control_disabled" else null)
+                    if (canControl) viewModel.sendIntent("move_backward", direction = "backward")
+                }
+            )
         }
 
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
-                Text("Motion Control", style = MaterialTheme.typography.titleMedium)
-                Text("Controls require an active remote session")
-                Button(
-                    onClick = {
-                        viewModel.logUiAction("stop", stopEnabled, if (stopEnabled) null else state.blockingReason)
-                        if (stopEnabled) {
-                            confirmStop = true
-                        } else {
-                            actionBlockedReason = state.blockingReason ?: "invalid_state"
-                        }
-                    },
-                    enabled = stopEnabled,
-                    modifier = Modifier.fillMaxWidth().height(56.dp),
-                    colors = androidx.compose.material3.ButtonDefaults.buttonColors(
-                        containerColor = MaterialTheme.colorScheme.error,
-                        contentColor = MaterialTheme.colorScheme.onError,
-                    )
-                ) { Text("STOP") }
+        Spacer(Modifier.height(16.dp))
 
-                Row(modifier = Modifier.fillMaxSize(), horizontalArrangement = Arrangement.Center) {
-                    Button(
-                        onClick = {
-                            viewModel.logUiAction("start_forward", intentsEnabled, if (intentsEnabled) null else state.blockingReason)
-                            if (intentsEnabled) {
-                                confirmStartForward = true
-                            } else {
-                                actionBlockedReason = state.blockingReason ?: "invalid_state"
-                            }
-                        },
-                        enabled = intentsEnabled,
-                    ) {
-                        Text("Forward")
-                    }
-                }
-                Row(horizontalArrangement = Arrangement.SpaceBetween) {
-                    Button(
-                        onClick = {
-                            viewModel.logUiAction("rotate_left", intentsEnabled, if (intentsEnabled) null else state.blockingReason)
-                            viewModel.sendIntent("rotate_left")
-                        },
-                        enabled = intentsEnabled,
-                    ) { Text("Left") }
-                    Button(
-                        onClick = {
-                            viewModel.logUiAction("rotate_right", intentsEnabled, if (intentsEnabled) null else state.blockingReason)
-                            viewModel.sendIntent("rotate_right")
-                        },
-                        enabled = intentsEnabled,
-                    ) { Text("Right") }
-                }
-                Row(modifier = Modifier.fillMaxSize(), horizontalArrangement = Arrangement.Center) {
-                    Button(
-                        onClick = {
-                            viewModel.logUiAction("move_backward", intentsEnabled, if (intentsEnabled) null else state.blockingReason)
-                            viewModel.sendIntent("move_backward")
-                        },
-                        enabled = intentsEnabled,
-                    ) { Text("Backward") }
-                }
-                Row(modifier = Modifier.fillMaxSize(), horizontalArrangement = Arrangement.Center) {
-                    Button(
-                        onClick = {
-                            viewModel.logUiAction("scan", intentsEnabled, if (intentsEnabled) null else state.blockingReason)
-                            if (intentsEnabled) {
-                                confirmScan = true
-                            } else {
-                                actionBlockedReason = state.blockingReason ?: "invalid_state"
-                            }
-                        },
-                        enabled = intentsEnabled,
-                    ) { Text("Scan") }
-                }
+        // Additional Actions
+        Text("Actions", fontWeight = FontWeight.Bold)
+        Spacer(Modifier.height(8.dp))
 
-                if (!intentsEnabled) {
-                    Text("Controls disabled: ${state.blockingReason ?: "invalid_state"}")
-                }
-                if (!stopEnabled) {
-                    Text("Stop disabled: ${state.blockingReason ?: "invalid_state"}")
-                }
-                if (commandRecent) {
-                    Text("Command sent: $lastIntentLabel @ ${formatTimestamp(state.lastIntentAt)}")
-                } else {
-                    Text("Last command: $lastIntentLabel")
-                    Text("Last result: ${state.lastIntentResult ?: "UNAVAILABLE"}")
-                }
+        Row(
+            modifier = Modifier.fillMaxWidth(),
+            horizontalArrangement = Arrangement.SpaceEvenly
+        ) {
+            ActionButton("Scan", Icons.Default.Search, canControl) {
+                viewModel.logUiAction("scan", canControl, null)
+                if (canControl) viewModel.startScanObserveTask()
+            }
+            ActionButton("Observe", Icons.Default.Visibility, canControl) {
+                viewModel.logUiAction("observe", canControl, null)
+                if (canControl) viewModel.markObservation()
             }
         }
 
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
-                Text("Assistant Control", style = MaterialTheme.typography.titleMedium)
-                Button(onClick = {
-                    viewModel.logUiAction("invoke_assistant", intentsEnabled, if (intentsEnabled) null else state.blockingReason)
-                    viewModel.sendIntent("invoke_assistant")
-                }, enabled = intentsEnabled) {
-                    Text("Invoke Assistant")
-                }
-                OutlinedTextField(
-                    value = customMessage,
-                    onValueChange = { customMessage = it },
-                    label = { Text("Custom message") },
-                    singleLine = false,
-                    modifier = Modifier.fillMaxWidth(),
-                )
-                Button(onClick = {
-                    viewModel.logUiAction("assistant_text", intentsEnabled, if (intentsEnabled) null else state.blockingReason)
-                    viewModel.sendIntent("assistant_text", mapOf("text" to customMessage.trim()))
-                    customMessage = ""
-                }, enabled = intentsEnabled && customMessage.isNotBlank()) {
-                    Text("Send to Assistant")
+        Spacer(Modifier.height(8.dp))
+
+        Spacer(Modifier.height(16.dp))
+
+        // Scan Summary (last reported)
+        StatusCard("Last Scan Summary") {
+            val summary = state.telemetry?.last_scan_summary
+            Text(summary ?: "No scan summary yet", fontSize = 12.sp, color = if (summary == null) Color.Gray else Color.Unspecified)
+        }
+
+        Spacer(Modifier.height(16.dp))
+
+        // Assistant Control - RESTORED
+        Text("Assistant", fontWeight = FontWeight.Bold)
+        Spacer(Modifier.height(8.dp))
+
+        var assistantText by remember { mutableStateOf("") }
+
+        Button(
+            onClick = {
+                viewModel.logUiAction("invoke_assistant", canControl, null)
+                if (canControl) viewModel.sendIntent("invoke_assistant")
+            },
+            enabled = canControl,
+            modifier = Modifier.fillMaxWidth()
+        ) {
+            Icon(Icons.Default.RecordVoiceOver, contentDescription = null)
+            Spacer(Modifier.width(8.dp))
+            Text("Invoke Assistant")
+        }
+
+        Spacer(Modifier.height(8.dp))
+
+        OutlinedTextField(
+            value = assistantText,
+            onValueChange = { assistantText = it },
+            label = { Text("Custom message") },
+            modifier = Modifier.fillMaxWidth(),
+            singleLine = false,
+            maxLines = 3
+        )
+
+        Spacer(Modifier.height(8.dp))
+
+        Button(
+            onClick = {
+                viewModel.logUiAction("assistant_text", canControl, null)
+                if (canControl && assistantText.isNotBlank()) {
+                    viewModel.sendIntent("assistant_text", text = assistantText.trim())
+                    assistantText = ""
                 }
-            }
+            },
+            enabled = canControl && assistantText.isNotBlank(),
+            modifier = Modifier.fillMaxWidth()
+        ) {
+            Icon(Icons.Default.Send, contentDescription = null)
+            Spacer(Modifier.width(8.dp))
+            Text("Send to Assistant")
         }
 
+        // Failure Surface - RESTORED
+        val sessionActive = state.telemetry?.remote_session_active == true || state.status?.remote_session_active == true
+        val hasFailure = state.connection is ConnectionStatus.Error || !sessionActive ||
+            state.lastIntentResult?.startsWith("rejected") == true ||
+            state.lastIntentResult?.startsWith("timed_out") == true ||
+            state.lastIntentResult?.startsWith("failed") == true
+
         if (hasFailure) {
-            Card {
-                Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                    Text("Failure surface", style = MaterialTheme.typography.titleMedium)
+            Spacer(Modifier.height(12.dp))
+            Card(
+                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.errorContainer)
+            ) {
+                Column(modifier = Modifier.padding(12.dp)) {
+                    Text("Failure Surface", fontWeight = FontWeight.Bold, fontSize = 14.sp)
+                    Spacer(Modifier.height(4.dp))
                     if (state.connection is ConnectionStatus.Error) {
-                        Text("Network failure: ${(state.connection as ConnectionStatus.Error).message}")
+                        Text("Network: ${(state.connection as ConnectionStatus.Error).message}", fontSize = 12.sp)
                     }
                     if (!sessionActive) {
-                        Text("Session loss: remote session inactive")
-                    }
-                    if (state.lastIntentResult?.startsWith("rejected") == true) {
-                        Text("Intent rejected: ${state.lastIntentResult}")
-                    }
-                    if (state.lastIntentResult?.startsWith("timed_out") == true) {
-                        Text("Intent timeout: ${state.lastIntentResult}")
+                        Text("Session: Remote session inactive", fontSize = 12.sp)
                     }
-                    if (state.lastIntentResult?.startsWith("failed") == true) {
-                        Text("Intent failure: ${state.lastIntentResult}")
+                    state.lastIntentResult?.let { result ->
+                        if (result.startsWith("rejected") || result.startsWith("timed_out") || result.startsWith("failed")) {
+                            Text("Intent: $result", fontSize = 12.sp)
+                        }
                     }
                 }
             }
         }
-        Spacer(modifier = Modifier.height(12.dp))
-    }
 
-    if (actionBlockedReason != null) {
-        AlertDialog(
-            onDismissRequest = { actionBlockedReason = null },
-            title = { Text("Action blocked") },
-            text = { Text("Reason: ${actionBlockedReason}") },
-            confirmButton = {
-                TextButton(onClick = { actionBlockedReason = null }) { Text("OK") }
+        // Control Status Info
+        if (!canControl) {
+            Spacer(Modifier.height(12.dp))
+            Card(
+                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.errorContainer)
+            ) {
+                Text(
+                    text = when {
+                        state.connection != ConnectionStatus.Online -> "Controls disabled: Not connected"
+                        state.telemetry?.remote_session_active != true -> "Controls disabled: No remote session"
+                        state.intentInFlight -> "Controls disabled: Intent in progress"
+                        else -> "Controls disabled"
+                    },
+                    modifier = Modifier.padding(12.dp),
+                    fontSize = 12.sp,
+                    color = MaterialTheme.colorScheme.onErrorContainer
+                )
             }
-        )
+        }
     }
+}
 
-    if (confirmScan) {
-        AlertDialog(
-            onDismissRequest = { confirmScan = false },
-            title = { Text("Confirm scan") },
-            text = { Text("Send scan intent to the robot?") },
-            confirmButton = {
-                Button(onClick = {
-                    confirmScan = false
-                    viewModel.logUiAction("confirm_scan", true, null)
-                    viewModel.startScanObserveTask()
-                }) { Text("Confirm") }
-            },
-            dismissButton = {
-                TextButton(onClick = { confirmScan = false }) { Text("Cancel") }
-            }
-        )
-    }
+// =============================================================================
+// TASK SCREEN - READ-ONLY OBSERVATION
+// =============================================================================
+@Composable
+fun TaskScreen(state: AppState) {
+    Column(
+        modifier = Modifier
+            .fillMaxSize()
+            .verticalScroll(rememberScrollState())
+            .padding(16.dp)
+    ) {
+        Text("Task Monitor", style = MaterialTheme.typography.headlineMedium)
+        Spacer(Modifier.height(16.dp))
 
-    if (confirmStop) {
-        AlertDialog(
-            onDismissRequest = { confirmStop = false },
-            title = { Text("Confirm stop") },
-            text = { Text("Send stop intent to the robot?") },
-            confirmButton = {
-                Button(onClick = {
-                    confirmStop = false
-                    viewModel.logUiAction("confirm_stop", true, null)
-                    viewModel.stopTask()
-                }) { Text("Confirm") }
-            },
-            dismissButton = {
-                TextButton(onClick = { confirmStop = false }) { Text("Cancel") }
+        StatusCard("Task State") {
+            StatusRow("Task Type", state.task.type.name)
+            StatusRow("Phase", state.task.phase.name)
+            StatusRow("Label", state.task.label.ifBlank { "-" })
+            state.lastRemoteEvent?.let { StatusRow("Last Remote Event", it) }
+            state.lastIntentSent?.let { StatusRow("Last Intent", it) }
+            state.lastIntentResult?.let { StatusRow("Last Result", it) }
+        }
+
+        Spacer(Modifier.height(12.dp))
+
+        StatusCard("Scan Summary") {
+            val summary = state.telemetry?.last_scan_summary
+            Text(summary ?: "No scan summary yet", fontSize = 12.sp, color = if (summary == null) Color.Gray else Color.Unspecified)
+        }
+
+        Spacer(Modifier.height(12.dp))
+
+        StatusCard("LLM Response") {
+            val llm = state.telemetry?.last_llm_response
+            Text(llm ?: "No LLM response yet", fontSize = 12.sp, color = if (llm == null) Color.Gray else Color.Unspecified)
+        }
+
+        Spacer(Modifier.height(12.dp))
+
+        val taskEvents = state.logs.filter { entry ->
+            entry.category == LogCategory.STATE && (
+                entry.event.contains("task") ||
+                entry.event.contains("remote_event") ||
+                entry.event.contains("scan")
+            )
+        }.takeLast(20).reversed()
+
+        StatusCard("Task / Scan Events") {
+            if (taskEvents.isEmpty()) {
+                Text("No task events", fontSize = 12.sp, color = Color.Gray)
+            } else {
+                Column(modifier = Modifier.heightIn(max = 240.dp)) {
+                    taskEvents.forEach { entry ->
+                        Text(entry.toDisplayLine(), fontSize = 10.sp, fontFamily = FontFamily.Monospace)
+                        Spacer(Modifier.height(2.dp))
+                    }
+                }
             }
-        )
-    }
+        }
 
-    if (confirmStartForward) {
-        AlertDialog(
-            onDismissRequest = { confirmStartForward = false },
-            title = { Text("Confirm forward") },
-            text = { Text("Send start forward intent to the robot?") },
-            confirmButton = {
-                Button(onClick = {
-                    confirmStartForward = false
-                    viewModel.logUiAction("confirm_start_forward", true, null)
-                    viewModel.sendIntent("start")
-                }) { Text("Confirm") }
-            },
-            dismissButton = {
-                TextButton(onClick = { confirmStartForward = false }) { Text("Cancel") }
+        Spacer(Modifier.height(12.dp))
+
+        state.telemetry?.detection_history?.takeIf { it.isNotEmpty() }?.let { history ->
+            Text("Detection History", fontWeight = FontWeight.Bold)
+            Spacer(Modifier.height(8.dp))
+            Column(
+                modifier = Modifier
+                    .fillMaxWidth()
+                    .heightIn(max = 200.dp)
+            ) {
+                history.takeLast(10).reversed().forEach { det ->
+                    Card(
+                        modifier = Modifier
+                            .fillMaxWidth()
+                            .padding(vertical = 2.dp),
+                        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
+                    ) {
+                        Row(
+                            modifier = Modifier
+                                .fillMaxWidth()
+                                .padding(8.dp),
+                            horizontalArrangement = Arrangement.SpaceBetween
+                        ) {
+                            Text(det.label ?: "Unknown", fontSize = 12.sp, fontWeight = FontWeight.Medium)
+                            Text("${((det.confidence ?: 0.0) * 100).toInt()}%", fontSize = 12.sp, color = Color.Gray)
+                        }
+                    }
+                }
             }
-        )
+        } ?: StatusCard("Detection History") {
+            Text("No detections", fontSize = 12.sp, color = Color.Gray)
+        }
     }
 }
 
 @Composable
-private fun VisionScreen(
-    modifier: Modifier,
-    viewModel: AppViewModel,
-    onOpenSettings: () -> Unit,
+fun ControlButton(
+    label: String,
+    icon: androidx.compose.ui.graphics.vector.ImageVector,
+    enabled: Boolean,
+    onClick: () -> Unit
 ) {
-    val state by viewModel.state.collectAsStateWithLifecycle()
-    val sessionActive = (state.telemetry?.remote_session_active == true) || (state.status?.remote_session_active == true)
-    val intentsEnabled = state.appStatus == AppStatus.ONLINE_IDLE && sessionActive
-    val streamUrl = resolveStreamUrl(state.telemetry?.stream_url ?: state.status?.stream_url, state.settings)
-    val visionMode = state.telemetry?.vision_mode ?: state.status?.vision_mode
-    val visionModeLabel = when (visionMode) {
-        "off" -> "OFF"
-        "on" -> "ON_NO_STREAM"
-        "on_with_stream" -> "ON_WITH_STREAM"
-        null -> "UNKNOWN"
-        else -> visionMode.uppercase()
-    }
-    val canStream = intentsEnabled && visionMode == "on_with_stream" && streamUrl.isNotBlank()
-    var isStreaming by rememberSaveable { mutableStateOf(false) }
-    var streamError by rememberSaveable { mutableStateOf<String?>(null) }
-    var overlayEnabled by rememberSaveable { mutableStateOf(false) }
-
-    LaunchedEffect(canStream) {
-        if (!canStream) {
-            isStreaming = false
+    Button(
+        onClick = onClick,
+        enabled = enabled,
+        modifier = Modifier.size(80.dp),
+        colors = ButtonDefaults.buttonColors(
+            containerColor = MaterialTheme.colorScheme.primary,
+            disabledContainerColor = Color.Gray.copy(alpha = 0.3f)
+        )
+    ) {
+        Column(horizontalAlignment = Alignment.CenterHorizontally) {
+            Icon(icon, contentDescription = label, modifier = Modifier.size(24.dp))
+            Text(label, fontSize = 8.sp)
         }
     }
+}
 
-    Column(
-        modifier = modifier
-            .verticalScroll(rememberScrollState())
-            .padding(16.dp),
-        verticalArrangement = Arrangement.spacedBy(12.dp)
+@Composable
+fun ActionButton(
+    label: String,
+    icon: androidx.compose.ui.graphics.vector.ImageVector,
+    enabled: Boolean,
+    onClick: () -> Unit
+) {
+    OutlinedButton(
+        onClick = onClick,
+        enabled = enabled,
     ) {
-        if (!intentsEnabled) {
-            Card {
-                Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                    Text("Vision offline", style = MaterialTheme.typography.titleMedium)
-                    Text("Reason: ${state.blockingReason ?: "session inactive"}")
-                    Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
-                        TextButton(onClick = onOpenSettings) { Text("Open settings") }
-                    }
-                }
-            }
-        }
+        Icon(icon, contentDescription = label, modifier = Modifier.size(16.dp))
+        Spacer(Modifier.width(4.dp))
+        Text(label, fontSize = 12.sp)
+    }
+}
 
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                Text("Vision mode: $visionModeLabel", style = MaterialTheme.typography.titleMedium)
-                Text("Stream URL: ${if (streamUrl.isBlank()) "missing" else "available"}")
-                Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
-                    Button(onClick = {
-                        viewModel.logUiAction("enable_vision", intentsEnabled, if (intentsEnabled) null else state.blockingReason)
-                        viewModel.sendIntent("enable_vision")
-                    }, enabled = intentsEnabled) { Text("Vision ON") }
-                    Button(onClick = {
-                        viewModel.logUiAction("disable_vision", intentsEnabled, if (intentsEnabled) null else state.blockingReason)
-                        viewModel.sendIntent("disable_vision")
-                    }, enabled = intentsEnabled) { Text("Vision OFF") }
-                }
-                Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
-                    Button(onClick = {
-                        viewModel.logUiAction("enable_stream", intentsEnabled, if (intentsEnabled) null else state.blockingReason)
-                        viewModel.sendIntent("enable_stream")
-                    }, enabled = intentsEnabled) { Text("Stream ON") }
-                    Button(onClick = {
-                        viewModel.logUiAction("disable_stream", intentsEnabled, if (intentsEnabled) null else state.blockingReason)
-                        viewModel.sendIntent("disable_stream")
-                    }, enabled = intentsEnabled) { Text("Stream OFF") }
-                }
+// =============================================================================
+// MJPEG STREAM VIEW COMPOSABLE
+// =============================================================================
+@Composable
+fun MjpegStreamView(url: String, modifier: Modifier = Modifier) {
+    var bitmap by remember { mutableStateOf<android.graphics.Bitmap?>(null) }
+    var error by remember { mutableStateOf<String?>(null) }
 
-                HorizontalDivider()
-                Text("Streaming", style = MaterialTheme.typography.titleMedium)
-                if (streamUrl.isBlank()) {
-                    Text("No stream URL provided by backend")
-                    Text("Streaming disabled: stream URL missing")
-                } else if (!intentsEnabled) {
-                    Text("Streaming disabled: ${state.blockingReason ?: "invalid_state"}")
-                } else if (visionMode != "on_with_stream") {
-                    Text("Streaming disabled: vision mode is not on_with_stream")
-                    Text("Enable streaming via intent first")
-                } else {
-                    if (streamError != null) {
-                        Text("Stream error: ${streamError}")
-                    }
-                    if (!isStreaming) {
-                        Button(onClick = {
-                            streamError = null
-                            isStreaming = true
-                            viewModel.logUiAction("vision_stream_start", canStream, if (canStream) null else state.blockingReason)
-                        }, enabled = canStream) {
-                            Text("Start stream")
-                        }
-                    } else {
-                        Button(onClick = {
-                            isStreaming = false
-                            viewModel.logUiAction("vision_stream_stop", true, null)
-                        }) { Text("Stop stream") }
-                        MjpegStreamingView(
-                            url = streamUrl,
-                            onError = { msg ->
-                                streamError = msg
-                                isStreaming = false
-                                viewModel.logUiAction("vision_stream_error", false, msg)
-                            },
-                            onStop = { isStreaming = false },
-                        )
-                    }
+    LaunchedEffect(url) {
+        withContext(Dispatchers.IO) {
+            try {
+                val client = OkHttpClient.Builder()
+                    .connectTimeout(10, TimeUnit.SECONDS)
+                    .readTimeout(30, TimeUnit.SECONDS)
+                    .build()
+
+                val request = Request.Builder()
+                    .url(url)
+                    .header("Accept", "multipart/x-mixed-replace")
+                    .build()
+
+                val response = client.newCall(request).execute()
+                if (!response.isSuccessful) {
+                    error = "Stream error: ${response.code}"
+                    return@withContext
                 }
 
-                HorizontalDivider()
-                Text("Vision metadata overlay", style = MaterialTheme.typography.titleMedium)
-                Button(onClick = { overlayEnabled = !overlayEnabled }) {
-                    Text(if (overlayEnabled) "Disable overlay" else "Enable overlay")
+                val body = response.body ?: run {
+                    error = "Empty response"
+                    return@withContext
                 }
 
-                if (overlayEnabled) {
-                    val det = state.telemetry?.vision_last_detection
-                    if (det == null) {
-                        Text("No detection available")
+                val inputStream = BufferedInputStream(body.byteStream())
+                val boundaryPattern = "--".toByteArray()
+                val buffer = ByteArrayOutputStream()
+
+                var inImage = false
+                var headersParsed = false
+                val headerBuffer = StringBuilder()
+
+                while (isActive) {
+                    val b = inputStream.read()
+                    if (b == -1) break
+
+                    if (!inImage) {
+                        headerBuffer.append(b.toChar())
+                        val headers = headerBuffer.toString()
+                        if (headers.contains("\r\n\r\n") || headers.contains("\n\n")) {
+                            if (headers.contains("Content-Type: image/jpeg", ignoreCase = true)) {
+                                inImage = true
+                                headersParsed = true
+                                buffer.reset()
+                            }
+                            headerBuffer.clear()
+                        }
                     } else {
-                        Text("Latest detection", style = MaterialTheme.typography.titleMedium)
-                        Text("Label: ${confidenceLabel(det.label, state.lastTelemetryAt)}")
-                        Text("Confidence: ${confidenceLabel(det.confidence, state.lastTelemetryAt)}")
-                        Text("BBox: ${confidenceLabel(det.bbox?.joinToString(prefix = "[", postfix = "]"), state.lastTelemetryAt)}")
-                        Text("Timestamp: ${confidenceLabel(det.ts, state.lastTelemetryAt)}")
+                        buffer.write(b)
+                        val data = buffer.toByteArray()
+                        
+                        // Check for JPEG end marker (FFD9)
+                        if (data.size >= 2 && 
+                            data[data.size - 2] == 0xFF.toByte() && 
+                            data[data.size - 1] == 0xD9.toByte()) {
+                            
+                            // Decode frame
+                            try {
+                                val decoded = BitmapFactory.decodeByteArray(data, 0, data.size)
+                                if (decoded != null) {
+                                    withContext(Dispatchers.Main) {
+                                        bitmap = decoded
+                                        error = null
+                                    }
+                                }
+                            } catch (e: Exception) {
+                                // Skip bad frame
+                            }
+                            
+                            buffer.reset()
+                            inImage = false
+                        }
                     }
-                } else {
-                    Text("Overlay is off")
                 }
-
-                HorizontalDivider()
-                Text("Capture", style = MaterialTheme.typography.titleMedium)
-                Button(
-                    onClick = {
-                        viewModel.logUiAction("capture_frame", intentsEnabled, if (intentsEnabled) null else state.blockingReason)
-                        viewModel.sendIntent("capture_frame")
-                    },
-                    enabled = intentsEnabled
-                ) {
-                    Text("Capture frame")
-                }
-                if (state.lastIntentSent == "capture_frame") {
-                    Text("Capture status: ${state.lastIntentResult ?: "pending"}")
-                    Text("Capture ts: ${formatTimestamp(state.lastIntentAt)}")
+            } catch (e: Exception) {
+                withContext(Dispatchers.Main) {
+                    error = "Stream error: ${e.message}"
                 }
+            }
+        }
+    }
 
-                HorizontalDivider()
-                Text("Detection history", style = MaterialTheme.typography.titleMedium)
-                val history = state.telemetry?.detection_history.orEmpty()
-                if (history.isEmpty()) {
-                    Text("No detections yet")
-                } else {
-                    val recent = history.takeLast(10).reversed()
-                    recent.forEachIndexed { index, item ->
-                        val style = if (index == 0) MaterialTheme.typography.titleSmall else MaterialTheme.typography.bodySmall
-                        Text(
-                            "${item.label ?: "unknown"} " +
-                                "conf=${item.confidence ?: "?"} " +
-                                "bbox=${item.bbox?.joinToString(prefix = "[", postfix = "]") ?: "[]"}",
-                            style = style,
-                        )
-                    }
+    Box(
+        modifier = modifier,
+        contentAlignment = Alignment.Center
+    ) {
+        when {
+            error != null -> {
+                Text(
+                    text = error ?: "Unknown error",
+                    color = Color.Red,
+                    fontSize = 12.sp,
+                    textAlign = TextAlign.Center
+                )
+            }
+            bitmap != null -> {
+                Image(
+                    bitmap = bitmap!!.asImageBitmap(),
+                    contentDescription = "Live Stream",
+                    modifier = Modifier.fillMaxSize(),
+                    contentScale = ContentScale.Fit
+                )
+            }
+            else -> {
+                Column(horizontalAlignment = Alignment.CenterHorizontally) {
+                    CircularProgressIndicator(color = Color.White, modifier = Modifier.size(24.dp))
+                    Spacer(Modifier.height(8.dp))
+                    Text("Connecting...", color = Color.White, fontSize = 12.sp)
                 }
             }
         }
-        Spacer(modifier = Modifier.height(12.dp))
     }
 }
 
+// =============================================================================
+// VISION SCREEN - DEDICATED VISION VIEW
+// =============================================================================
 @Composable
-private fun SensorsScreen(
-    modifier: Modifier,
-    viewModel: AppViewModel,
-) {
-    val state by viewModel.state.collectAsStateWithLifecycle()
-    val sessionActive = (state.telemetry?.remote_session_active == true) || (state.status?.remote_session_active == true)
+fun VisionScreen(state: AppState, viewModel: AppViewModel) {
+    val baseUrl = state.settings?.baseUrl() ?: BuildConfig.ROBOT_BASE_URL
+    val streamUrl = baseUrl.trimEnd('/') + "/stream/mjpeg"
+    val streamOwner = state.streamOwner
+    val streamEnabled = streamOwner == StreamOwner.VISION
+    val streamLockedByOther = streamOwner != null && streamOwner != StreamOwner.VISION
+    var overlayEnabled by remember { mutableStateOf(false) }
+
+    val intentsEnabled = state.appStatus == AppStatus.ONLINE_IDLE
+    val sessionActive = state.telemetry?.remote_session_active == true || state.status?.remote_session_active == true
+    val canControl = state.connection == ConnectionStatus.Online && sessionActive && !state.intentInFlight
 
     Column(
-        modifier = modifier
+        modifier = Modifier
+            .fillMaxSize()
             .verticalScroll(rememberScrollState())
-            .padding(16.dp),
-        verticalArrangement = Arrangement.spacedBy(12.dp)
+            .padding(16.dp)
     ) {
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                Text("Robot state", style = MaterialTheme.typography.titleMedium)
-                Text("Session: ${triState(sessionActive)}")
-                Text("Status mode: ${confidenceLabel(state.status?.mode, state.lastStatusAt)}")
-                Text("Status display: ${confidenceLabel(state.status?.display_text, state.lastStatusAt)}")
-                Text("Telemetry mode: ${confidenceLabel(state.telemetry?.mode, state.lastTelemetryAt)}")
-                Text("Telemetry display: ${confidenceLabel(state.telemetry?.display_text, state.lastTelemetryAt)}")
+        Text("Vision System", style = MaterialTheme.typography.headlineMedium)
+        Spacer(Modifier.height(16.dp))
+
+        // Vision Control - RESTORED
+        StatusCard("Vision Control") {
+            val visionMode = state.telemetry?.vision_mode ?: state.status?.vision_mode
+            val visionModeLabel = when (visionMode) {
+                "off" -> "OFF"
+                "on" -> "ON (no stream)"
+                "on_with_stream" -> "ON + STREAM"
+                null -> "UNKNOWN"
+                else -> visionMode.uppercase()
+            }
+            StatusRow("Vision Mode", visionModeLabel)
+            
+            Spacer(Modifier.height(8.dp))
+            
+            Row(
+                modifier = Modifier.fillMaxWidth(),
+                horizontalArrangement = Arrangement.spacedBy(8.dp)
+            ) {
+                Button(
+                    onClick = {
+                        viewModel.logUiAction("enable_vision", canControl, null)
+                        if (canControl) viewModel.sendIntent("enable_vision")
+                    },
+                    enabled = canControl,
+                    modifier = Modifier.weight(1f)
+                ) { Text("Vision ON") }
+                Button(
+                    onClick = {
+                        viewModel.logUiAction("disable_vision", canControl, null)
+                        if (canControl) viewModel.sendIntent("disable_vision")
+                    },
+                    enabled = canControl,
+                    modifier = Modifier.weight(1f)
+                ) { Text("Vision OFF") }
+            }
+            
+            Spacer(Modifier.height(8.dp))
+            
+            Row(
+                modifier = Modifier.fillMaxWidth(),
+                horizontalArrangement = Arrangement.spacedBy(8.dp)
+            ) {
+                Button(
+                    onClick = {
+                        viewModel.logUiAction("enable_stream", canControl, null)
+                        if (canControl) viewModel.sendIntent("enable_stream")
+                    },
+                    enabled = canControl,
+                    modifier = Modifier.weight(1f)
+                ) { Text("Stream ON") }
+                Button(
+                    onClick = {
+                        viewModel.logUiAction("disable_stream", canControl, null)
+                        if (canControl) viewModel.sendIntent("disable_stream")
+                    },
+                    enabled = canControl,
+                    modifier = Modifier.weight(1f)
+                ) { Text("Stream OFF") }
             }
         }
 
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                Text("Sensor health", style = MaterialTheme.typography.titleMedium)
-                Text("Sensor timestamp: ${confidenceLabel(state.telemetry?.sensor_ts, state.lastTelemetryAt)}")
-                Text("Buffer size: ${state.telemetry?.sensor_buffer ?: "unknown"}")
-                Text("Safety stop: ${confidenceLabel(state.telemetry?.safety_stop, state.lastTelemetryAt)}")
-                Text("Blocking: ${state.blockingReason ?: "none"}")
+        Spacer(Modifier.height(12.dp))
+
+        // Stream View Toggle (local)
+        Row(
+            modifier = Modifier.fillMaxWidth(),
+            horizontalArrangement = Arrangement.SpaceBetween,
+            verticalAlignment = Alignment.CenterVertically
+        ) {
+            Text("Show Stream View", fontWeight = FontWeight.Bold)
+            Switch(
+                checked = streamEnabled,
+                onCheckedChange = {
+                    val allowed = viewModel.requestStream(StreamOwner.VISION, it)
+                    val blockedReason = if (!allowed) "stream_in_use" else null
+                    viewModel.logUiAction("vision_stream_view_toggle", allowed, blockedReason)
+                }
+            )
+        }
+
+        if (streamLockedByOther) {
+            Spacer(Modifier.height(4.dp))
+            Text("Stream already active in Control screen", color = Color.Red, fontSize = 12.sp)
+        }
+
+        if (streamEnabled) {
+            Spacer(Modifier.height(8.dp))
+            Card(
+                modifier = Modifier
+                    .fillMaxWidth()
+                    .aspectRatio(16f / 9f),
+                colors = CardDefaults.cardColors(containerColor = Color.Black)
+            ) {
+                MjpegStreamView(
+                    url = streamUrl,
+                    modifier = Modifier.fillMaxSize()
+                )
             }
         }
 
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                Text("Motor feedback", style = MaterialTheme.typography.titleMedium)
-                val motor = state.telemetry?.motor
-                Text("Motor enabled: ${confidenceLabel(state.telemetry?.motor_enabled, state.lastTelemetryAt)}")
-                Text("Left motor: ${confidenceLabel(motor?.left, state.lastTelemetryAt)}")
-                Text("Right motor: ${confidenceLabel(motor?.right, state.lastTelemetryAt)}")
-                Text("Intent busy: ${triState(state.intentInFlight)}")
-                Text("Last intent: ${state.lastIntentSent ?: "unknown"}")
-                Text("Last intent result: ${state.lastIntentResult ?: "unknown"}")
+        Spacer(Modifier.height(12.dp))
+
+        // Capture Frame - RESTORED
+        Button(
+            onClick = {
+                viewModel.logUiAction("capture_frame", canControl, null)
+                if (canControl) viewModel.sendIntent("capture_frame")
+            },
+            enabled = canControl,
+            modifier = Modifier.fillMaxWidth()
+        ) {
+            Icon(Icons.Default.Camera, contentDescription = null)
+            Spacer(Modifier.width(8.dp))
+            Text("Capture Frame")
+        }
+
+        if (state.lastIntentSent == "capture_frame") {
+            Text(
+                "Capture: ${state.lastIntentResult ?: "pending"} @ ${state.lastIntentAt?.let { formatTime(it) } ?: "-"}",
+                fontSize = 10.sp,
+                color = Color.Gray
+            )
+        }
+
+        Spacer(Modifier.height(12.dp))
+
+        // Vision Status
+        StatusCard("Vision Status") {
+            state.telemetry?.let { t ->
+                StatusRow("Vision Active", if (t.vision_active == true) "Yes" else "No")
+                StatusRow("Vision Paused", if (t.vision_paused == true) "Yes" else "No")
+                t.vision_mode?.let { StatusRow("Mode", it) }
+                t.stream_url?.let { StatusRow("Stream URL", it) }
+            } ?: Text("No vision data", color = Color.Gray)
+        }
+
+        Spacer(Modifier.height(12.dp))
+
+        // Overlay Toggle - RESTORED
+        Row(
+            modifier = Modifier.fillMaxWidth(),
+            horizontalArrangement = Arrangement.SpaceBetween,
+            verticalAlignment = Alignment.CenterVertically
+        ) {
+            Text("Detection Overlay", fontWeight = FontWeight.Bold)
+            Switch(
+                checked = overlayEnabled,
+                onCheckedChange = { overlayEnabled = it }
+            )
+        }
+
+        // Last Detection (shown when overlay enabled or always)
+        if (overlayEnabled) {
+            Spacer(Modifier.height(8.dp))
+            StatusCard("Last Detection (Overlay)") {
+                state.telemetry?.vision_last_detection?.let { det ->
+                    StatusRow("Label", det.label ?: "-")
+                    det.confidence?.let { StatusRow("Confidence", "%.2f%%".format(it * 100)) }
+                    det.bbox?.let { StatusRow("BBox", it.joinToString(", ")) }
+                    det.ts?.let { StatusRow("Timestamp", "%.2f".format(it)) }
+                } ?: Text("No detections", color = Color.Gray)
             }
         }
 
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                Text("Sensor values", style = MaterialTheme.typography.titleMedium)
-                val sensor = state.telemetry?.sensor
-                Text("Is safe: ${confidenceLabel(sensor?.is_safe, state.telemetry?.sensor_ts)}")
-                Text("Obstacle: ${confidenceLabel(sensor?.obstacle, state.telemetry?.sensor_ts)}")
-                Text("Warning: ${confidenceLabel(sensor?.warning, state.telemetry?.sensor_ts)}")
-                Text("Raw telemetry: ${state.telemetry?.toString() ?: "telemetry_missing"}")
+        Spacer(Modifier.height(12.dp))
+
+        // Detection History
+        state.telemetry?.detection_history?.takeIf { it.isNotEmpty() }?.let { history ->
+            Text("Detection History", fontWeight = FontWeight.Bold)
+            Spacer(Modifier.height(8.dp))
+            Column(
+                modifier = Modifier
+                    .fillMaxWidth()
+                    .heightIn(max = 200.dp)
+            ) {
+                history.takeLast(10).reversed().forEach { det ->
+                    Card(
+                        modifier = Modifier
+                            .fillMaxWidth()
+                            .padding(vertical = 2.dp),
+                        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
+                    ) {
+                        Row(
+                            modifier = Modifier
+                                .fillMaxWidth()
+                                .padding(8.dp),
+                            horizontalArrangement = Arrangement.SpaceBetween
+                        ) {
+                            Text(det.label ?: "Unknown", fontSize = 12.sp, fontWeight = FontWeight.Medium)
+                            Text("${((det.confidence ?: 0.0) * 100).toInt()}%", fontSize = 12.sp, color = Color.Gray)
+                        }
+                    }
+                }
             }
         }
-        Spacer(modifier = Modifier.height(12.dp))
     }
 }
 
+// =============================================================================
+// SENSORS SCREEN - SENSOR DATA DISPLAY
+// =============================================================================
 @Composable
-private fun LogsScreen(
-    modifier: Modifier,
-    viewModel: AppViewModel,
-) {
-    val state by viewModel.state.collectAsStateWithLifecycle()
-    val context = LocalContext.current
-    var showUi by rememberSaveable { mutableStateOf(true) }
-    var showNetwork by rememberSaveable { mutableStateOf(true) }
-    var showIntent by rememberSaveable { mutableStateOf(true) }
-    var showState by rememberSaveable { mutableStateOf(true) }
-    val backendServices = listOf(
-        BackendLogService.APP,
-        BackendLogService.REMOTE_INTERFACE,
-        BackendLogService.ORCHESTRATOR,
-        BackendLogService.UART,
-        BackendLogService.VISION,
-        BackendLogService.LLM_TTS,
-    )
-    var selectedServices by remember {
-        mutableStateOf(backendServices.associateWith { true })
-    }
-    val scrollState = rememberScrollState()
-
-    val filtered = state.logs.filter { entry ->
-        when (entry.category) {
-            LogCategory.UI -> showUi
-            LogCategory.NETWORK -> showNetwork
-            LogCategory.INTENT -> showIntent
-            LogCategory.STATE -> showState
+fun SensorsScreen(state: AppState) {
+    Column(
+        modifier = Modifier
+            .fillMaxSize()
+            .verticalScroll(rememberScrollState())
+            .padding(16.dp)
+    ) {
+        Text("Sensors", style = MaterialTheme.typography.headlineMedium)
+        Spacer(Modifier.height(16.dp))
+
+        // Distance Sensors
+        StatusCard("Distance Sensors") {
+            state.telemetry?.sensor?.let { s ->
+                SensorBar("Sensor 1 (Left)", s.s1, 400)
+                SensorBar("Sensor 2 (Center)", s.s2, 400)
+                SensorBar("Sensor 3 (Right)", s.s3, 400)
+                Spacer(Modifier.height(8.dp))
+                s.min_distance?.let { StatusRow("Min Distance", "$it cm") }
+                StatusRow("Obstacle", if (s.obstacle == true) "YES" else "Clear")
+                StatusRow("Warning", if (s.warning == true) "ACTIVE" else "None")
+                StatusRow("Is Safe", if (s.is_safe == true) "Yes" else "NO")
+            } ?: Text("No sensor data", color = Color.Gray)
         }
-    }
 
-    val lastCritical = filtered.lastOrNull { entry ->
-        when (entry.category) {
-            LogCategory.INTENT -> {
-                val result = entry.data["result"]?.toString() ?: ""
-                result.contains("rejected") || result.contains("failed") || result.contains("timed_out")
-            }
-            LogCategory.NETWORK -> entry.event.contains("error")
-            LogCategory.STATE -> entry.event.contains("error")
-            LogCategory.UI -> false
+        Spacer(Modifier.height(12.dp))
+
+        // Motor State
+        StatusCard("Motor State") {
+            state.telemetry?.let { t ->
+                StatusRow("Motor Enabled", if (t.motor_enabled == true) "Yes" else "No")
+                t.motor?.let { m ->
+                    StatusRow("Left Motor", "${m.left ?: 0}")
+                    StatusRow("Right Motor", "${m.right ?: 0}")
+                }
+                t.sensor?.let { s ->
+                    StatusRow("L Motor (Raw)", "${s.lmotor ?: 0}")
+                    StatusRow("R Motor (Raw)", "${s.rmotor ?: 0}")
+                }
+            } ?: Text("No motor data", color = Color.Gray)
+        }
+
+        Spacer(Modifier.height(12.dp))
+
+        // Gas Sensor
+        StatusCard("Gas Sensor (MQ2)") {
+            state.telemetry?.let { t ->
+                t.sensor?.mq2?.let { SensorBar("MQ2 Level", it, 1000) }
+                t.gas_level?.let { StatusRow("Gas Level", "$it") }
+                val severity = t.gas_severity
+                    ?: (if (t.gas_warning == true) "warning" else "clear")
+                val severityLabel = when (severity) {
+                    "danger" -> "DANGER"
+                    "warning" -> "WARNING"
+                    "clear" -> "CLEAR"
+                    else -> "UNKNOWN"
+                }
+                val severityColor = when (severity) {
+                    "danger" -> Color(0xFFF44336)
+                    "warning" -> Color(0xFFFFC107)
+                    "clear" -> Color(0xFF4CAF50)
+                    else -> Color.Gray
+                }
+                StatusRowColored("Gas Severity", severityLabel, severityColor)
+            } ?: Text("No gas sensor data", color = Color.Gray)
+        }
+
+        Spacer(Modifier.height(12.dp))
+
+        // Safety Status
+        StatusCard("Safety Status") {
+            state.telemetry?.let { t ->
+                StatusRow("Safety Stop", if (t.safety_stop == true) "ACTIVE" else "Clear")
+                t.safety_alert?.let { StatusRow("Alert", it) }
+            } ?: Text("No safety data", color = Color.Gray)
+        }
+
+        Spacer(Modifier.height(12.dp))
+
+        // Sensor Timestamp
+        state.telemetry?.sensor_ts?.let {
+            Text("Last Update: ${formatTime(it * 1000)}", fontSize = 10.sp, color = Color.Gray)
         }
     }
+}
 
-    val byCategory = filtered.groupBy { it.category }
+@Composable
+fun SensorBar(label: String, value: Int?, maxValue: Int) {
+    val safeValue = value?.coerceIn(0, maxValue) ?: 0
+    val fraction = safeValue.toFloat() / maxValue
 
-    LaunchedEffect(filtered.size) {
-        scrollState.animateScrollTo(scrollState.maxValue)
+    Column(modifier = Modifier.padding(vertical = 4.dp)) {
+        Row(
+            modifier = Modifier.fillMaxWidth(),
+            horizontalArrangement = Arrangement.SpaceBetween
+        ) {
+            Text(label, fontSize = 12.sp)
+            Text("$safeValue", fontSize = 12.sp, fontWeight = FontWeight.Medium)
+        }
+        Spacer(Modifier.height(4.dp))
+        LinearProgressIndicator(
+            progress = { fraction },
+            modifier = Modifier
+                .fillMaxWidth()
+                .height(8.dp)
+                .clip(RoundedCornerShape(4.dp)),
+            color = when {
+                fraction > 0.7f -> Color(0xFFF44336)
+                fraction > 0.4f -> Color(0xFFFF9800)
+                else -> Color(0xFF4CAF50)
+            },
+        )
     }
+}
+
+// =============================================================================
+// LOGS SCREEN - COLLAPSIBLE GROUPS BY SERVICE
+// =============================================================================
+@Composable
+fun LogsScreen(state: AppState, viewModel: AppViewModel) {
+    val context = LocalContext.current
+    var expandedServices by remember { mutableStateOf(setOf<BackendLogService>()) }
 
     Column(
-        modifier = modifier
-            .verticalScroll(scrollState)
-            .padding(16.dp),
-        verticalArrangement = Arrangement.spacedBy(12.dp)
+        modifier = Modifier
+            .fillMaxSize()
+            .padding(16.dp)
     ) {
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
-                Text("Backend logs", style = MaterialTheme.typography.titleMedium)
-                Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
-                    Text("Auto refresh")
-                    Switch(
-                        checked = state.logAutoRefresh,
-                        onCheckedChange = { viewModel.setLogAutoRefresh(it) }
-                    )
-                    Text("Lines: ${state.logLinesLimit}")
+        // Header Row
+        Row(
+            modifier = Modifier.fillMaxWidth(),
+            horizontalArrangement = Arrangement.SpaceBetween,
+            verticalAlignment = Alignment.CenterVertically
+        ) {
+            Text("Logs", style = MaterialTheme.typography.headlineMedium)
+            Row {
+                IconButton(onClick = { viewModel.refreshBackendLogs() }) {
+                    Icon(Icons.Default.Refresh, contentDescription = "Refresh")
                 }
-                Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
-                    Button(onClick = { viewModel.refreshBackendLogs() }) { Text("Refresh now") }
-                    Text("Updated: ${formatTimestamp(state.backendLogsUpdatedAt)}")
-                }
-                backendServices.forEach { service ->
-                    Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
-                        Text(service.label)
-                        Switch(
-                            checked = selectedServices[service] == true,
-                            onCheckedChange = { enabled ->
-                                selectedServices = selectedServices.toMutableMap().also { it[service] = enabled }
-                            }
-                        )
-                    }
+                IconButton(onClick = { viewModel.exportLogs(context) }) {
+                    Icon(Icons.Default.Download, contentDescription = "Export")
                 }
             }
         }
 
-        backendServices.filter { selectedServices[it] == true }.forEach { service ->
-            val snapshot = state.backendLogs[service]
-            val appLogLines = filtered.takeLast(200).map { it.toDisplayLine() }
-            Card {
-                Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                    Text(service.label, style = MaterialTheme.typography.titleMedium)
-                    if (service == BackendLogService.APP) {
-                        if (appLogLines.isEmpty()) {
-                            Text("No app logs")
-                        } else {
-                            appLogLines.forEach { line ->
-                                Text(line, style = MaterialTheme.typography.bodySmall)
-                            }
-                        }
-                    } else if (snapshot == null) {
-                        Text("No data yet")
-                    } else {
-                        if (!snapshot.error.isNullOrBlank()) {
-                            Text("Error: ${snapshot.error}")
-                        }
-                        if (snapshot.lines.isEmpty()) {
-                            Text("No log lines")
-                        } else {
-                            snapshot.lines.takeLast(200).forEach { line ->
-                                Text(line, style = MaterialTheme.typography.bodySmall)
+        // Auto-refresh toggle
+        Row(
+            modifier = Modifier.fillMaxWidth(),
+            horizontalArrangement = Arrangement.SpaceBetween,
+            verticalAlignment = Alignment.CenterVertically
+        ) {
+            Text("Auto-refresh", fontSize = 12.sp)
+            Switch(
+                checked = state.logAutoRefresh,
+                onCheckedChange = { viewModel.setLogAutoRefresh(it) }
+            )
+        }
+
+        Spacer(Modifier.height(8.dp))
+
+        // Export Result
+        state.logExportResult?.let {
+            Text(it, fontSize = 10.sp, color = if (it.startsWith("error")) Color.Red else Color.Green)
+            Spacer(Modifier.height(8.dp))
+        }
+
+        // Collapsible Log Groups
+        LazyColumn(modifier = Modifier.fillMaxSize()) {
+            // Backend Services
+            item {
+                Text("Backend Services", fontWeight = FontWeight.Bold, fontSize = 14.sp)
+                Spacer(Modifier.height(8.dp))
+            }
+
+            BackendLogService.entries.forEach { service ->
+                val snapshot = state.backendLogs[service]
+                val isExpanded = expandedServices.contains(service)
+                val lineCount = snapshot?.lines?.size ?: 0
+
+                item(key = "header_${service.name}") {
+                    LogServiceHeader(
+                        service = service,
+                        lineCount = lineCount,
+                        error = snapshot?.error,
+                        isExpanded = isExpanded,
+                        onClick = {
+                            expandedServices = if (isExpanded) {
+                                expandedServices - service
+                            } else {
+                                expandedServices + service
                             }
                         }
+                    )
+                }
+
+                item(key = "content_${service.name}") {
+                    AnimatedVisibility(
+                        visible = isExpanded,
+                        enter = expandVertically(),
+                        exit = shrinkVertically()
+                    ) {
+                        LogServiceContent(
+                            lines = snapshot?.lines.orEmpty(),
+                            error = snapshot?.error
+                        )
                     }
                 }
             }
-        }
 
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
-                Text("Log controls", style = MaterialTheme.typography.titleMedium)
-                Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
-                    Text("UI (button actions)")
-                    Switch(checked = showUi, onCheckedChange = { showUi = it })
-                    Text("Network (HTTP)")
-                    Switch(checked = showNetwork, onCheckedChange = { showNetwork = it })
-                }
-                Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
-                    Text("Intent (sent/result)")
-                    Switch(checked = showIntent, onCheckedChange = { showIntent = it })
-                    Text("State (app)")
-                    Switch(checked = showState, onCheckedChange = { showState = it })
-                }
-                Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
-                    Button(onClick = { viewModel.exportLogs(context) }) {
-                        Text("Export JSONL")
-                    }
+            // App Logs Section
+            item {
+                Spacer(Modifier.height(16.dp))
+                Row(
+                    modifier = Modifier.fillMaxWidth(),
+                    horizontalArrangement = Arrangement.SpaceBetween,
+                    verticalAlignment = Alignment.CenterVertically
+                ) {
+                    Text("App Logs (${state.logs.size})", fontWeight = FontWeight.Bold, fontSize = 14.sp)
                     TextButton(onClick = { viewModel.clearLogs() }) {
-                        Text("Clear logs")
+                        Text("Clear", fontSize = 12.sp)
                     }
                 }
-                Text("Log export: ${state.logExportResult ?: "not exported"}")
+                Spacer(Modifier.height(8.dp))
+            }
+
+            items(state.logs.takeLast(50).reversed(), key = { it.ts }) { entry ->
+                AppLogItem(entry)
             }
         }
+    }
+}
 
-        if (lastCritical != null) {
-            Card {
-                Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                    Text("Last critical log", style = MaterialTheme.typography.titleMedium)
-                    Text(lastCritical.toDisplayLine())
-                }
+@Composable
+fun LogServiceHeader(
+    service: BackendLogService,
+    lineCount: Int,
+    error: String?,
+    isExpanded: Boolean,
+    onClick: () -> Unit
+) {
+    Card(
+        modifier = Modifier
+            .fillMaxWidth()
+            .padding(vertical = 2.dp)
+            .clickable { onClick() },
+        colors = CardDefaults.cardColors(
+            containerColor = if (error != null) MaterialTheme.colorScheme.errorContainer
+            else MaterialTheme.colorScheme.surfaceVariant
+        )
+    ) {
+        Row(
+            modifier = Modifier
+                .fillMaxWidth()
+                .padding(12.dp),
+            horizontalArrangement = Arrangement.SpaceBetween,
+            verticalAlignment = Alignment.CenterVertically
+        ) {
+            Row(verticalAlignment = Alignment.CenterVertically) {
+                Icon(
+                    if (isExpanded) Icons.Default.ExpandLess else Icons.Default.ExpandMore,
+                    contentDescription = null,
+                    modifier = Modifier.size(20.dp)
+                )
+                Spacer(Modifier.width(8.dp))
+                Text(service.label, fontWeight = FontWeight.Medium)
             }
+            Text(
+                if (error != null) "Error" else "$lineCount lines",
+                fontSize = 12.sp,
+                color = if (error != null) MaterialTheme.colorScheme.error else Color.Gray
+            )
         }
+    }
+}
 
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                Text("Logs", style = MaterialTheme.typography.titleMedium)
-                Text("Showing ${filtered.size} of ${state.logs.size}")
-                if (filtered.isEmpty()) {
-                    Text("No logs match current filters")
-                } else {
-                    val order = listOf(LogCategory.INTENT, LogCategory.UI, LogCategory.NETWORK, LogCategory.STATE)
-                    order.forEach { category ->
-                        val entries = byCategory[category].orEmpty()
-                        if (entries.isNotEmpty()) {
-                            Text(category.name, style = MaterialTheme.typography.titleSmall)
-                            entries.takeLast(100).forEach { entry ->
-                                val style = if (entry.category == LogCategory.INTENT) {
-                                    MaterialTheme.typography.bodyMedium
-                                } else {
-                                    MaterialTheme.typography.bodySmall
-                                }
-                                Text(entry.toDisplayLine(), maxLines = 3, overflow = TextOverflow.Ellipsis, style = style)
-                            }
-                        }
+@Composable
+fun LogServiceContent(lines: List<String>, error: String?) {
+    Card(
+        modifier = Modifier
+            .fillMaxWidth()
+            .padding(start = 16.dp, end = 0.dp, top = 0.dp, bottom = 8.dp),
+        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface)
+    ) {
+        Column(
+            modifier = Modifier
+                .fillMaxWidth()
+                .heightIn(max = 300.dp)
+                .padding(8.dp)
+        ) {
+            if (error != null) {
+                Text("Error: $error", color = Color.Red, fontSize = 10.sp)
+            } else if (lines.isEmpty()) {
+                Text("No logs", color = Color.Gray, fontSize = 10.sp)
+            } else {
+                LazyColumn {
+                    items(lines.takeLast(100).reversed()) { line ->
+                        Text(
+                            text = line,
+                            fontSize = 9.sp,
+                            fontFamily = FontFamily.Monospace,
+                            modifier = Modifier.padding(vertical = 1.dp)
+                        )
                     }
                 }
             }
         }
-        Spacer(modifier = Modifier.height(12.dp))
     }
 }
 
 @Composable
-private fun SettingsScreen(
-    modifier: Modifier,
-    viewModel: AppViewModel,
-) {
-    val state by viewModel.state.collectAsStateWithLifecycle()
-    val context = LocalContext.current
-    var ip by rememberSaveable { mutableStateOf(state.settings?.robotIp ?: "") }
-    var port by rememberSaveable { mutableStateOf(state.settings?.robotPort?.toString() ?: "") }
-    var pollMs by rememberSaveable { mutableStateOf(state.settings?.pollIntervalMs?.toString() ?: "1000") }
-    var debugEnabled by rememberSaveable { mutableStateOf(state.settings?.debugEnabled ?: false) }
-    var errorMessage by rememberSaveable { mutableStateOf<String?>(null) }
-    var showDiagnostics by rememberSaveable { mutableStateOf(false) }
-    var showLimitations by rememberSaveable { mutableStateOf(false) }
-
-    LaunchedEffect(state.settings) {
-        val settings = state.settings
-        if (settings != null) {
-            ip = settings.robotIp
-            port = settings.robotPort.toString()
-            pollMs = settings.pollIntervalMs.toString()
-            debugEnabled = settings.debugEnabled
-        }
+fun AppLogItem(entry: AppLogEntry) {
+    val bgColor = when (entry.category) {
+        LogCategory.INTENT -> MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.3f)
+        LogCategory.NETWORK -> MaterialTheme.colorScheme.tertiaryContainer.copy(alpha = 0.3f)
+        LogCategory.STATE -> MaterialTheme.colorScheme.secondaryContainer.copy(alpha = 0.3f)
+        LogCategory.UI -> MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.3f)
+    }
+
+    Card(
+        modifier = Modifier
+            .fillMaxWidth()
+            .padding(vertical = 1.dp),
+        colors = CardDefaults.cardColors(containerColor = bgColor)
+    ) {
+        Text(
+            text = entry.toDisplayLine(),
+            fontSize = 9.sp,
+            fontFamily = FontFamily.Monospace,
+            modifier = Modifier.padding(6.dp)
+        )
     }
+}
+
+// =============================================================================
+// SETTINGS SCREEN - IP/PORT CONFIGURATION
+// =============================================================================
+@Composable
+fun SettingsScreen(state: AppState, viewModel: AppViewModel) {
+    var editIp by remember(state.settings) { mutableStateOf(state.settings?.robotIp ?: "") }
+    var editPort by remember(state.settings) { mutableStateOf(state.settings?.robotPort?.toString() ?: "") }
+    var editPollMs by remember(state.settings) { mutableStateOf(state.settings?.pollIntervalMs?.toString() ?: "") }
+    var editDebug by remember(state.settings) { mutableStateOf(state.settings?.debugEnabled ?: false) }
 
     Column(
-        modifier = modifier
+        modifier = Modifier
+            .fillMaxSize()
             .verticalScroll(rememberScrollState())
-            .padding(16.dp),
-        verticalArrangement = Arrangement.spacedBy(12.dp)
+            .padding(16.dp)
     ) {
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
-                Text("Connection", style = MaterialTheme.typography.titleMedium)
-                Text("Base URL (read-only): ${state.settings?.baseUrl() ?: BuildConfig.ROBOT_BASE_URL}")
-                OutlinedTextField(
-                    value = ip,
-                    onValueChange = { ip = it.trim() },
-                    label = { Text("Robot IP") },
-                    singleLine = true,
-                )
-                OutlinedTextField(
-                    value = port,
-                    onValueChange = { port = it.trim() },
-                    label = { Text("Port") },
-                    singleLine = true,
-                )
-                OutlinedTextField(
-                    value = pollMs,
-                    onValueChange = { pollMs = it.trim() },
-                    label = { Text("Poll interval (ms)") },
-                    singleLine = true,
-                )
-                if (errorMessage != null) {
-                    Text(errorMessage!!, color = MaterialTheme.colorScheme.error)
-                }
-                Button(onClick = {
-                    val parsedPort = port.toIntOrNull()
-                    val parsedPoll = pollMs.toLongOrNull()
-                    val ipValue = ip.trim()
-                    errorMessage = when {
-                        ipValue.isBlank() -> "IP address is required"
-                        parsedPort == null || parsedPort <= 0 -> "Port must be a positive integer"
-                        parsedPoll == null || parsedPoll < 250L -> "Poll interval must be at least 250ms"
-                        else -> null
-                    }
-                    if (errorMessage == null) {
-                        viewModel.updateSettings(
-                            AppSettings(
-                                robotIp = ipValue,
-                                robotPort = parsedPort!!,
-                                pollIntervalMs = parsedPoll!!,
-                                debugEnabled = debugEnabled,
-                            )
-                        )
-                    }
-                }) {
-                    Text("Apply settings")
-                }
-            }
-        }
+        Text("Settings", style = MaterialTheme.typography.headlineMedium)
+        Spacer(Modifier.height(16.dp))
 
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
-                Text("Diagnostics", style = MaterialTheme.typography.titleMedium)
-                Text("App version: ${BuildConfig.VERSION_NAME}")
-                Text("Log export: ${state.logExportResult ?: "not exported"}")
-                Button(onClick = { viewModel.exportLogs(context) }) {
-                    Text("Export logs")
-                }
-                TextButton(onClick = { showDiagnostics = !showDiagnostics }) {
-                    Text(if (showDiagnostics) "Hide runtime details" else "Show runtime details")
-                }
-                if (showDiagnostics) {
-                    Text("Robot base URL: ${state.settings?.baseUrl() ?: BuildConfig.ROBOT_BASE_URL}")
-                    Text("Last status: ${formatTimestamp(state.lastStatusAt)}")
-                    Text("Last telemetry: ${formatTimestamp(state.lastTelemetryAt)}")
-                    Text("Last intent: ${state.lastIntentSent ?: "unknown"}")
-                    Text("Last intent result: ${state.lastIntentResult ?: "unknown"}")
-                }
-            }
+        // Connection Settings
+        StatusCard("Connection") {
+            OutlinedTextField(
+                value = editIp,
+                onValueChange = { editIp = it },
+                label = { Text("Robot IP") },
+                modifier = Modifier.fillMaxWidth(),
+                singleLine = true,
+                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Uri)
+            )
+            Spacer(Modifier.height(8.dp))
+            OutlinedTextField(
+                value = editPort,
+                onValueChange = { editPort = it.filter { c -> c.isDigit() } },
+                label = { Text("Robot Port") },
+                modifier = Modifier.fillMaxWidth(),
+                singleLine = true,
+                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number)
+            )
         }
 
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                TextButton(onClick = { showLimitations = !showLimitations }) {
-                    Text(if (showLimitations) "Hide known limitations" else "Show known limitations")
-                }
-                if (showLimitations) {
-                    Text("Known limitations", style = MaterialTheme.typography.titleMedium)
-                    Text("- No auto-retry for intents")
-                    Text("- Telemetry may be stale or missing fields")
-                    Text("- Streaming depends on backend-provided URL and format")
-                }
-            }
+        Spacer(Modifier.height(12.dp))
+
+        // Polling Settings
+        StatusCard("Polling") {
+            OutlinedTextField(
+                value = editPollMs,
+                onValueChange = { editPollMs = it.filter { c -> c.isDigit() } },
+                label = { Text("Poll Interval (ms)") },
+                modifier = Modifier.fillMaxWidth(),
+                singleLine = true,
+                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number)
+            )
         }
 
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
-                Text("Advanced", style = MaterialTheme.typography.titleMedium)
-                Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
-                    Text("Debug panel")
-                    Switch(checked = debugEnabled, onCheckedChange = { debugEnabled = it })
-                }
-                Text(
-                    "Enables extra diagnostics on app screens.",
-                    style = MaterialTheme.typography.bodySmall,
+        Spacer(Modifier.height(12.dp))
+
+        // Debug Settings
+        StatusCard("Debug") {
+            Row(
+                modifier = Modifier.fillMaxWidth(),
+                horizontalArrangement = Arrangement.SpaceBetween,
+                verticalAlignment = Alignment.CenterVertically
+            ) {
+                Text("Enable Debug Mode")
+                Switch(
+                    checked = editDebug,
+                    onCheckedChange = { editDebug = it }
                 )
             }
         }
-        Spacer(modifier = Modifier.height(12.dp))
-    }
-}
 
-@Composable
-private fun MjpegStreamingView(
-    url: String,
-    onError: (String) -> Unit,
-    onStop: () -> Unit,
-) {
-    val context = LocalContext.current
-    val client = remember { OkHttpClient.Builder().build() }
-    var latestBitmap by remember { mutableStateOf<Bitmap?>(null) }
-    val scope = rememberCoroutineScope()
+        Spacer(Modifier.height(16.dp))
 
-    DisposableEffect(url) {
-        val job = scope.launch(Dispatchers.IO) {
-            try {
-                val request = Request.Builder().url(url).build()
-                val response = client.newCall(request).execute()
-                if (!response.isSuccessful) {
-                    withContext(Dispatchers.Main) { onError("http_${response.code}") }
-                    response.close()
-                    return@launch
-                }
-                val contentType = response.header("Content-Type")
-                val boundary = parseBoundary(contentType)
-                val body = response.body ?: run {
-                    withContext(Dispatchers.Main) { onError("empty_body") }
-                    response.close()
-                    return@launch
-                }
-                val source = body.source()
-                while (isActive) {
-                    val line = source.readUtf8Line() ?: break
-                    if (!line.startsWith(boundary)) {
-                        continue
-                    }
-                    var contentLength = -1
-                    while (true) {
-                        val header = source.readUtf8Line() ?: break
-                        if (header.isBlank()) break
-                        val parts = header.split(":", limit = 2)
-                        if (parts.size == 2 && parts[0].trim().equals("Content-Length", true)) {
-                            contentLength = parts[1].trim().toIntOrNull() ?: -1
-                        }
-                    }
-                    if (contentLength <= 0) {
-                        continue
-                    }
-                    val bytes = source.readByteArray(contentLength.toLong())
-                    val bitmap = BitmapFactory.decodeByteArray(bytes, 0, bytes.size)
-                    if (bitmap != null) {
-                        withContext(Dispatchers.Main) { latestBitmap = bitmap }
-                    }
-                    source.readUtf8Line()
-                }
-                response.close()
-            } catch (err: CancellationException) {
-                // Ignore cancellation
-            } catch (err: Exception) {
-                withContext(Dispatchers.Main) { onError(err.message ?: "stream_error") }
-            }
+        // Save Button
+        Button(
+            onClick = {
+                val newSettings = AppSettings(
+                    robotIp = editIp.ifBlank { "100.111.13.60" },
+                    robotPort = editPort.toIntOrNull() ?: 8770,
+                    pollIntervalMs = editPollMs.toLongOrNull() ?: 1000L,
+                    debugEnabled = editDebug,
+                )
+                viewModel.updateSettings(newSettings)
+            },
+            modifier = Modifier.fillMaxWidth()
+        ) {
+            Icon(Icons.Default.Save, contentDescription = null)
+            Spacer(Modifier.width(8.dp))
+            Text("Save Settings")
         }
 
-        onDispose {
-            job.cancel()
-            onStop()
+        Spacer(Modifier.height(16.dp))
+
+        // Current Settings Display
+        StatusCard("Current Configuration") {
+            StatusRow("Base URL", state.settings?.baseUrl() ?: "-")
+            StatusRow("Poll Interval", "${state.settings?.pollIntervalMs ?: "-"} ms")
+            StatusRow("Debug Mode", if (state.settings?.debugEnabled == true) "Enabled" else "Disabled")
         }
-    }
 
-    AndroidView(
-        factory = {
-            val view = ImageView(context)
-            view.layoutParams = ViewGroup.LayoutParams(
-                ViewGroup.LayoutParams.MATCH_PARENT,
-                ViewGroup.LayoutParams.WRAP_CONTENT
-            )
-            view.adjustViewBounds = true
-            view
-        },
-        update = { view ->
-            view.setImageBitmap(latestBitmap)
-        },
-        modifier = Modifier.padding(top = 8.dp)
-    )
-}
+        Spacer(Modifier.height(12.dp))
 
-private fun triState(value: Boolean?): String = when (value) {
-    null -> "UNAVAILABLE"
-    true -> "true"
-    false -> "false"
-}
+        // Build Info
+        StatusCard("Build Info") {
+            StatusRow("Default URL", BuildConfig.ROBOT_BASE_URL)
+            StatusRow("Version", "1.0.0")
+        }
 
-private fun connectionLabel(status: ConnectionStatus): String = when (status) {
-    ConnectionStatus.Online -> "ONLINE"
-    ConnectionStatus.Offline -> "OFFLINE"
-    is ConnectionStatus.Error -> "ERROR"
-}
+        Spacer(Modifier.height(12.dp))
 
-private fun confidenceLabel(value: Any?, lastTs: Long?): String {
-    val now = System.currentTimeMillis()
-    val freshness = if (lastTs == null) "UNAVAILABLE" else if (now - lastTs > 5_000) "STALE" else "LIVE"
-    val v = value?.toString() ?: "UNAVAILABLE"
-    return "$v ($freshness)"
-}
+        // Diagnostics Section - RESTORED
+        var diagExpanded by remember { mutableStateOf(false) }
+        StatusCard("Diagnostics") {
+            Row(
+                modifier = Modifier
+                    .fillMaxWidth()
+                    .clickable { diagExpanded = !diagExpanded },
+                horizontalArrangement = Arrangement.SpaceBetween,
+                verticalAlignment = Alignment.CenterVertically
+            ) {
+                Text("Runtime Diagnostics", fontWeight = FontWeight.Bold)
+                Icon(
+                    imageVector = if (diagExpanded) Icons.Default.ExpandLess else Icons.Default.ExpandMore,
+                    contentDescription = if (diagExpanded) "Collapse" else "Expand"
+                )
+            }
+            if (diagExpanded) {
+                Spacer(Modifier.height(8.dp))
+                Divider()
+                Spacer(Modifier.height(8.dp))
+                val connLabel = when (state.connection) {
+                    is ConnectionStatus.Online -> "Online"
+                    is ConnectionStatus.Offline -> "Offline"
+                    is ConnectionStatus.Error -> "Error: ${(state.connection as ConnectionStatus.Error).message}"
+                }
+                StatusRow("Connection Status", connLabel)
+                StatusRow("App Status", state.appStatus.name)
+                StatusRow("Intent In Flight", if (state.intentInFlight) "Yes" else "No")
+                state.lastIntentSent?.let { StatusRow("Last Intent", it) }
+                state.lastIntentResult?.let { StatusRow("Last Result", it) }
+                state.lastIntentAt?.let { StatusRow("Last Intent At", formatTime(it)) }
+                state.blockingReason?.let {
+                    Spacer(Modifier.height(4.dp))
+                    Text("Blocking Reason:", fontWeight = FontWeight.Bold, color = Color.Red)
+                    Text(it, fontSize = 12.sp, color = Color.Red)
+                }
+            }
+        }
 
-private fun resolveStreamUrl(raw: String?, settings: AppSettings?): String {
-    val value = raw?.trim().orEmpty()
-    if (value.isBlank()) return ""
-    if (value.startsWith("http://") || value.startsWith("https://")) return value
-    val base = settings?.baseUrl() ?: BuildConfig.ROBOT_BASE_URL
-    return base.trimEnd('/') + "/" + value.trimStart('/')
-}
+        Spacer(Modifier.height(12.dp))
 
-private fun parseBoundary(contentType: String?): String {
-    if (contentType.isNullOrBlank()) return "--frame"
-    val boundary = contentType.split(";")
-        .map { it.trim() }
-        .firstOrNull { it.startsWith("boundary=") }
-        ?.substringAfter("boundary=")
-        ?.trim('"')
-        ?: "frame"
-    return if (boundary.startsWith("--")) boundary else "--$boundary"
+        // Known Limitations Section - RESTORED
+        var limExpanded by remember { mutableStateOf(false) }
+        StatusCard("Known Limitations") {
+            Row(
+                modifier = Modifier
+                    .fillMaxWidth()
+                    .clickable { limExpanded = !limExpanded },
+                horizontalArrangement = Arrangement.SpaceBetween,
+                verticalAlignment = Alignment.CenterVertically
+            ) {
+                Text("Platform Notes", fontWeight = FontWeight.Bold)
+                Icon(
+                    imageVector = if (limExpanded) Icons.Default.ExpandLess else Icons.Default.ExpandMore,
+                    contentDescription = if (limExpanded) "Collapse" else "Expand"
+                )
+            }
+            if (limExpanded) {
+                Spacer(Modifier.height(8.dp))
+                Divider()
+                Spacer(Modifier.height(8.dp))
+                val limitations = listOf(
+                    "??? MJPEG stream may have latency over cellular",
+                    "??? Vision intents require backend vision module active",
+                    "??? Assistant intents require LLM endpoint configured",
+                    "??? Control intents are queued; only one executes at a time",
+                    "??? Collision avoidance may override direction commands",
+                    "??? Wake-word detection requires continuous audio stream",
+                    "??? TTS playback blocks other audio operations"
+                )
+                limitations.forEach { lim ->
+                    Text(lim, fontSize = 12.sp, color = Color.Gray)
+                    Spacer(Modifier.height(4.dp))
+                }
+            }
+        }
+    }
 }
 
-private fun formatTimestamp(ts: Long?): String {
-    if (ts == null) return "UNAVAILABLE"
-    val formatter = DateTimeFormatter.ofPattern("HH:mm:ss")
-    return Instant.ofEpochMilli(ts).atZone(ZoneId.systemDefault()).format(formatter)
+// =============================================================================
+// UTILITY FUNCTIONS
+// =============================================================================
+fun formatTime(epochMs: Long): String {
+    val instant = java.time.Instant.ofEpochMilli(epochMs)
+    val zoned = instant.atZone(java.time.ZoneId.systemDefault())
+    return java.time.format.DateTimeFormatter.ofPattern("HH:mm:ss").format(zoned)
 }
diff --git a/mobile_app/app/src/main/res/drawable/app_icon_smart_car.avif b/mobile_app/app/src/main/res/drawable/app_icon_smart_car.avif
deleted file mode 100644
index 7bed324..0000000
Binary files a/mobile_app/app/src/main/res/drawable/app_icon_smart_car.avif and /dev/null differ
diff --git a/src/core/orchestrator.py b/src/core/orchestrator.py
index c88f0d1..9251545 100644
--- a/src/core/orchestrator.py
+++ b/src/core/orchestrator.py
@@ -58,8 +58,8 @@ class Phase(Enum):
     IDLE = auto()
     LISTENING = auto()
     THINKING = auto()
-    SPEAKING = auto()
     SCANNING = auto()
+    SPEAKING = auto()
     ERROR = auto()
 
 
@@ -78,19 +78,20 @@ class Orchestrator:
         (Phase.IDLE, "manual_text"): Phase.THINKING,
         (Phase.IDLE, "manual_speak"): Phase.SPEAKING,
         (Phase.IDLE, "scan_start"): Phase.SCANNING,
+        (Phase.THINKING, "scan_start"): Phase.SCANNING,
         (Phase.LISTENING, "stt_valid"): Phase.THINKING,
         (Phase.LISTENING, "stt_invalid"): Phase.IDLE,
         (Phase.LISTENING, "stt_timeout"): Phase.IDLE,
         (Phase.THINKING, "llm_with_speech"): Phase.SPEAKING,
         (Phase.THINKING, "llm_no_speech"): Phase.IDLE,
-        (Phase.SPEAKING, "tts_done"): Phase.IDLE,
         (Phase.SCANNING, "scan_complete"): Phase.IDLE,
         (Phase.SCANNING, "scan_abort"): Phase.IDLE,
+        (Phase.SPEAKING, "tts_done"): Phase.IDLE,
         (Phase.IDLE, "health_error"): Phase.ERROR,
         (Phase.LISTENING, "health_error"): Phase.ERROR,
         (Phase.THINKING, "health_error"): Phase.ERROR,
-        (Phase.SPEAKING, "health_error"): Phase.ERROR,
         (Phase.SCANNING, "health_error"): Phase.ERROR,
+        (Phase.SPEAKING, "health_error"): Phase.ERROR,
         (Phase.ERROR, "health_ok"): Phase.IDLE,
         (Phase.ERROR, "error_timeout"): Phase.IDLE,
     }
@@ -113,24 +114,26 @@ class Orchestrator:
         self._esp_min_distance = -1
         self._obstacle_latched = False
 
+        self._scan_active = False
         self._scan_end_ts: Optional[float] = None
         self._scan_labels: list[str] = []
-        self._capture_labels: Dict[str, list[str]] = {}
         self._last_scan_summary: Optional[str] = None
-        self._scan_prev_vision_mode: Optional[VisionMode] = None
+        self._capture_labels: Dict[str, list[str]] = {}
 
-        self._gas_warning = False
+        self._gas_state = "clear"
         self._gas_level: Optional[int] = None
 
         self._remote_session_active = False
         self._remote_last_seen = 0.0
-        self._last_led_state = "idle"
         
         orch_cfg = self.config.get("orchestrator", {}) or {}
         self.auto_trigger_enabled = bool(orch_cfg.get("auto_trigger_enabled", True))
         self.auto_trigger_interval = float(orch_cfg.get("auto_trigger_interval", 60.0))
         self.scan_duration_s = float(orch_cfg.get("scan_duration_s", 4.0))
-        self.gas_threshold = int(orch_cfg.get("gas_threshold", 800))
+        self.scan_turn_direction = str(orch_cfg.get("scan_turn_direction", "right")).lower()
+        self.gas_warning_threshold = int(orch_cfg.get("gas_warning_threshold", 600))
+        self.gas_danger_threshold = int(orch_cfg.get("gas_danger_threshold", 800))
+        self.scan_min_confidence = float(orch_cfg.get("scan_min_confidence", 0.6))
         
         stt_cfg = self.config.get("stt", {}) or {}
         self.stt_timeout_s = float(stt_cfg.get("timeout_seconds", 30.0))
@@ -145,16 +148,13 @@ class Orchestrator:
         self.vision_mode = self._coerce_vision_mode(default_mode)
 
     def _publish_led_state(self, state: str) -> None:
-        if state != "gas_danger":
-            self._last_led_state = state
-        effective_state = "gas_danger" if self._gas_warning else state
         publish_json(self.cmd_pub, TOPIC_DISPLAY_STATE, {
-            "state": effective_state,
+            "state": state,
             "phase": self._phase.name,
             "timestamp": int(time.time()),
             "source": "orchestrator",
         })
-        logger.debug("LED: %s", effective_state)
+        logger.debug("LED: %s", state)
 
     def _publish_display_text(self, text: str) -> None:
         publish_json(self.cmd_pub, TOPIC_DISPLAY_TEXT, {
@@ -232,6 +232,10 @@ class Orchestrator:
         self._publish_led_state("tts_processing")
         self._publish_display_text(f"Saying: {text[:120]}")
         normalized = self._normalize_direction(direction)
+        if normalized == "scan":
+            if self._transition("scan_start"):
+                self._start_scan(source="voice")
+            return
         if normalized != "stop":
             if self._esp_obstacle and normalized == "forward":
                 logger.warning("Blocked forward command due to obstacle")
@@ -257,6 +261,10 @@ class Orchestrator:
             logger.info("Status TTS skipped context=%s reason=transition_blocked text=%s", context, text[:120])
             self._publish_remote_event("tts_skipped", {"reason": "transition_blocked", "context": context, "text": text})
 
+    def _publish_status_tts(self, text: str, *, context: str) -> None:
+        publish_json(self.cmd_pub, TOPIC_TTS, {"text": text, "source": "orchestrator", "context": context})
+        logger.info("status_tts context=%s text=%s", context, text[:120])
+
     @staticmethod
     def _summarize_labels(labels: list[str]) -> str:
         counts: Dict[str, int] = {}
@@ -275,110 +283,57 @@ class Orchestrator:
                 parts.append(f"{count} {label_value}s")
         return ", ".join(parts)
 
-    @staticmethod
-    def _count_labels(labels: list[str]) -> Dict[str, int]:
-        counts: Dict[str, int] = {}
-        for label in labels:
-            label_value = (label or "").strip()
-            if not label_value or label_value == "none":
-                continue
-            counts[label_value] = counts.get(label_value, 0) + 1
-        return counts
-
-    def _start_scan(self, *, source: str) -> bool:
-        if self._phase != Phase.IDLE:
-            logger.warning("scan_start rejected reason=busy phase=%s", self._phase.name)
-            self._publish_remote_event("rejected", {"reason": "busy", "intent": "scan"})
-            return False
-        if not self._transition("scan_start"):
-            logger.warning("scan_start rejected reason=transition_blocked phase=%s", self._phase.name)
-            self._publish_remote_event("rejected", {"reason": "transition_blocked", "intent": "scan"})
-            return False
-        self._scan_end_ts = time.time() + self.scan_duration_s
+    def _start_scan(self, *, source: str) -> None:
+        now = time.time()
+        self._scan_active = True
+        self._scan_end_ts = now + max(0.5, self.scan_duration_s)
         self._scan_labels = []
-        self._scan_prev_vision_mode = self.vision_mode
         if self.vision_mode == VisionMode.OFF:
             self._set_vision_mode(VisionMode.ON_NO_STREAM, source="scan")
+        direction = self.scan_turn_direction if self.scan_turn_direction in {"left", "right"} else "right"
+        publish_json(self.cmd_pub, TOPIC_NAV, {"direction": direction, "source": source})
         self._publish_led_state("scanning")
-        self._publish_display_text("Scanning 360")
-        publish_json(
-            self.cmd_pub,
-            TOPIC_NAV,
-            {
-                "direction": "right",
-                "source": source,
-                "duration_s": self.scan_duration_s,
-                "intent": "scan",
-            },
-        )
-        self._last_nav_direction = "right"
-        logger.info("scan_start source=%s duration_s=%.2f", source, self.scan_duration_s)
-        self._publish_remote_event("scan_start", {"source": source, "duration_s": self.scan_duration_s})
-        return True
+        self._publish_display_text("Scanning 360 degrees")
+        self._publish_status_tts("360 degree scan started.", context="scan_start")
+        logger.info("scan_start source=%s duration_s=%.2f direction=%s", source, self.scan_duration_s, direction)
+        self._publish_remote_event("scan_start", {
+            "duration_s": self.scan_duration_s,
+            "direction": direction,
+            "source": source,
+        })
 
-    def _finish_scan(self, *, reason: str, transition_event: str = "scan_complete") -> None:
-        publish_json(self.cmd_pub, TOPIC_NAV, {"direction": "stop", "source": "scan", "reason": reason})
-        self._last_nav_direction = "stop"
-        if self._scan_prev_vision_mode == VisionMode.OFF:
-            self._set_vision_mode(VisionMode.OFF, source="scan")
-        self._scan_prev_vision_mode = None
-        summary = self._summarize_labels(self._scan_labels)
-        counts = self._count_labels(self._scan_labels)
-        self._last_scan_summary = summary
+    def _finish_scan(self, *, reason: str, transition_event: str) -> None:
+        if not self._scan_active:
+            return
+        self._scan_active = False
         self._scan_end_ts = None
+        publish_json(self.cmd_pub, TOPIC_NAV, {"direction": "stop", "source": "orchestrator"})
+        summary = self._summarize_labels(self._scan_labels)
         self._scan_labels = []
-        logger.info("object_summary summary=%s counts=%s", summary, counts)
-        if self._transition(transition_event):
+        self._last_scan_summary = summary
+        logger.info("object_summary summary=%s", summary)
+        logger.info("scan_complete reason=%s", reason)
+        self._publish_remote_event("scan_complete", {"summary": summary, "reason": reason})
+        if self._phase == Phase.SCANNING and self._transition(transition_event):
             self._enter_idle()
-        if transition_event == "scan_abort":
-            logger.info("scan_abort reason=%s", reason)
-        else:
-            logger.info("scan_complete reason=%s", reason)
-        self._publish_remote_event(
-            "scan_complete",
-            {"summary": summary, "counts": counts, "reason": reason},
-        )
-        if summary == "no objects detected":
-            speak_text = "Scan complete. I detected no objects."
-        else:
-            speak_text = f"Scan complete. I detected {summary}."
-        self._maybe_speak_status(speak_text, context="scan_complete")
+        self._maybe_speak_status(f"Scan complete. I detected {summary}.", context="scan_complete")
 
     def _abort_scan(self, *, reason: str) -> None:
-        if self._phase != Phase.SCANNING:
-            return
-        logger.warning("scan_abort reason=%s", reason)
         self._finish_scan(reason=reason, transition_event="scan_abort")
 
-    def _update_gas_warning(self, mq2_value: Optional[int]) -> None:
-        if mq2_value is None:
-            return
-        self._gas_level = mq2_value
-        gas_warning = mq2_value >= self.gas_threshold
-        if gas_warning == self._gas_warning:
-            return
-        self._gas_warning = gas_warning
-        if gas_warning:
-            logger.warning("gas_warning level=%s threshold=%s", mq2_value, self.gas_threshold)
+    def _enter_idle(self) -> None:
+        if self._gas_state == "danger":
             self._publish_led_state("gas_danger")
-            self._publish_display_text("Gas danger detected")
-            publish_json(
-                self.cmd_pub,
-                TOPIC_TTS,
-                {"text": "Warning. Gas level is above safe limits.", "source": "orchestrator"},
-            )
-            self._publish_remote_event(
-                "gas_warning",
-                {"level": mq2_value, "threshold": self.gas_threshold},
-            )
+            self._publish_display_text("Gas danger")
+        elif self._gas_state == "warning":
+            self._publish_led_state("gas_warning")
+            self._publish_display_text("Gas warning")
+        elif self._scan_active:
+            self._publish_led_state("scanning")
+            self._publish_display_text("Scanning 360 degrees")
         else:
-            logger.info("gas_clear level=%s threshold=%s", mq2_value, self.gas_threshold)
-            self._publish_led_state(self._last_led_state or "idle")
-            self._publish_remote_event("gas_clear", {"level": mq2_value, "threshold": self.gas_threshold})
-
-    def _enter_idle(self) -> None:
-        self._publish_led_state("idle")
-        self._publish_display_text("Idle")
+            self._publish_led_state("idle")
+            self._publish_display_text("Idle")
         # Vision lifecycle is managed explicitly; do not auto-resume here.
 
     def _notify_stt_failure(self, reason: str) -> None:
@@ -484,8 +439,10 @@ class Orchestrator:
     def on_vision(self, payload: Dict[str, Any]) -> None:
         self._last_vision = payload
         label_value = payload.get("label")
-        if self._phase == Phase.SCANNING:
-            self._scan_labels.append(str(label_value or "none"))
+        if self._scan_active:
+            confidence = float(payload.get("confidence", 0.0) or 0.0)
+            if confidence >= self.scan_min_confidence:
+                self._scan_labels.append(str(label_value or "none"))
             if len(self._scan_labels) > 50:
                 self._scan_labels = self._scan_labels[-50:]
         request_id = payload.get("request_id")
@@ -524,6 +481,10 @@ class Orchestrator:
                 speak = f"{speak} Obstacle ahead, stopping."
         logger.info("LLM response speak: %s", (speak or "")[:120])
         
+        if direction == "scan":
+            if self._transition("scan_start"):
+                self._start_scan(source="voice")
+            return
         if speak:
             if self._transition("llm_with_speech"):
                 self._enter_speaking(speak, direction)
@@ -538,7 +499,8 @@ class Orchestrator:
 
     def on_tts(self, payload: Dict[str, Any]) -> None:
         if payload.get("started"):
-            self._publish_led_state("speaking")
+            if self._gas_state != "danger":
+                self._publish_led_state("speaking")
             return
         done = payload.get("done") or payload.get("final") or payload.get("completed")
         if payload.get("notification"):
@@ -558,19 +520,61 @@ class Orchestrator:
             self._esp_obstacle = bool(data.get("obstacle", False)) or (data.get("is_safe") is False)
             self._esp_min_distance = int(data.get("min_distance", -1))
             mq2_value = data.get("mq2")
-            try:
-                mq2_value = int(mq2_value) if mq2_value is not None else None
-            except Exception:
-                mq2_value = None
-            self._update_gas_warning(mq2_value)
+            if mq2_value is not None:
+                self._gas_level = int(mq2_value)
+                if self._gas_level >= self.gas_danger_threshold:
+                    next_state = "danger"
+                elif self._gas_level >= self.gas_warning_threshold:
+                    next_state = "warning"
+                else:
+                    next_state = "clear"
+                if next_state != self._gas_state:
+                    previous = self._gas_state
+                    self._gas_state = next_state
+                    if next_state == "danger":
+                        logger.warning(
+                            "gas_danger level=%s warning_threshold=%s danger_threshold=%s",
+                            self._gas_level,
+                            self.gas_warning_threshold,
+                            self.gas_danger_threshold,
+                        )
+                        self._publish_led_state("gas_danger")
+                        self._publish_display_text("Danger: gas level critical")
+                        self._publish_remote_event("gas_danger", {"gas_level": self._gas_level})
+                        self._publish_status_tts("Danger. Gas level is critical.", context="gas_danger")
+                    elif next_state == "warning":
+                        logger.warning(
+                            "gas_warning level=%s warning_threshold=%s danger_threshold=%s",
+                            self._gas_level,
+                            self.gas_warning_threshold,
+                            self.gas_danger_threshold,
+                        )
+                        self._publish_led_state("gas_warning")
+                        self._publish_display_text("Warning: gas level high")
+                        self._publish_remote_event("gas_warning", {"gas_level": self._gas_level})
+                        self._publish_status_tts("Warning. Gas level is above safe limits.", context="gas_warning")
+                    else:
+                        logger.info(
+                            "gas_clear level=%s warning_threshold=%s danger_threshold=%s prev=%s",
+                            self._gas_level,
+                            self.gas_warning_threshold,
+                            self.gas_danger_threshold,
+                            previous,
+                        )
+                        self._publish_remote_event("gas_clear", {"gas_level": self._gas_level})
+                        if self._scan_active:
+                            self._publish_led_state("scanning")
+                            self._publish_display_text("Scanning 360 degrees")
+                        else:
+                            self._enter_idle()
             if self._esp_obstacle and not self._obstacle_latched:
                 self._obstacle_latched = True
                 logger.warning("Obstacle detected by ESP32; forcing stop")
                 publish_json(self.cmd_pub, TOPIC_NAV, {"direction": "stop", "reason": "obstacle"})
                 self._last_nav_direction = "stop"
                 self._publish_display_text("Obstacle detected - stopping")
-                if self._phase == Phase.SCANNING:
-                    self._abort_scan(reason="obstacle")
+                if self._scan_active:
+                    self._finish_scan(reason="safety_stop", transition_event="scan_abort")
             elif not self._esp_obstacle and self._obstacle_latched:
                 self._obstacle_latched = False
                 logger.info("Obstacle cleared by ESP32")
@@ -579,6 +583,8 @@ class Orchestrator:
             logger.critical("ESP32 collision alert!")
             publish_json(self.cmd_pub, TOPIC_NAV, {"direction": "stop", "reason": "collision"})
             self._last_nav_direction = "stop"
+            if self._scan_active:
+                self._finish_scan(reason="collision", transition_event="scan_abort")
 
     def on_health(self, payload: Dict[str, Any]) -> None:
         ok = bool(payload.get("ok", True))
@@ -614,8 +620,8 @@ class Orchestrator:
                 if self._phase == Phase.THINKING:
                     self._enter_thinking(self._last_transcript)
 
-        if self._phase == Phase.SCANNING and self._scan_end_ts and now >= self._scan_end_ts:
-            self._finish_scan(reason="time_bound")
+        if self._scan_active and self._scan_end_ts and now >= self._scan_end_ts:
+            self._finish_scan(reason="completed", transition_event="scan_complete")
 
         if self._remote_session_active and self._remote_last_seen:
             if (now - self._remote_last_seen) > self.remote_session_timeout_s:
@@ -740,11 +746,6 @@ class Orchestrator:
             self._publish_remote_event("rejected", {"reason": "missing_intent", "payload": payload})
             return
 
-        if self._phase == Phase.SCANNING:
-            logger.warning("remote_intent rejected reason=scan_in_progress payload=%s", payload)
-            self._publish_remote_event("rejected", {"reason": "scan_in_progress", "payload": payload})
-            return
-
         if intent in {"enable_vision", "enable_perception"}:
             self._set_vision_mode(VisionMode.ON_NO_STREAM, source="remote_app")
             logger.info("remote_intent accepted intent=%s", intent)
@@ -798,11 +799,21 @@ class Orchestrator:
                 self._publish_remote_event("rejected", {"reason": "busy", "payload": payload})
             return
         if intent in {"scan", "start_scan"}:
-            if self._start_scan(source="remote_app"):
+            if self._phase != Phase.IDLE:
+                logger.warning("remote_intent rejected reason=busy payload=%s", payload)
+                self._publish_remote_event("rejected", {"reason": "busy", "payload": payload})
+                return
+            if self._transition("scan_start"):
+                self._start_scan(source="remote_app")
                 logger.info("remote_intent accepted intent=%s", intent)
                 self._publish_remote_event("accepted", {"intent": intent})
+            else:
+                logger.warning("remote_intent rejected reason=transition_blocked payload=%s", payload)
+                self._publish_remote_event("rejected", {"reason": "transition_blocked", "payload": payload})
             return
         if intent in {"stop", "stop_motion"}:
+            if self._scan_active:
+                self._finish_scan(reason="manual_stop", transition_event="scan_abort")
             logger.info(
                 "nav.command publish intent=%s direction=stop speed=%s duration=%s payload=%s",
                 intent,
diff --git a/src/piled/led_ring_service.py b/src/piled/led_ring_service.py
index 09aa79c..336bf8d 100644
--- a/src/piled/led_ring_service.py
+++ b/src/piled/led_ring_service.py
@@ -1,4 +1,4 @@
-"""Phase-driven LED ring controller: LED = f(Phase).
+"""Phase-driven LED strip controller: LED = f(Phase).
 
 ARCHITECTURE:
     LED state is derived SOLELY from TOPIC_DISPLAY_STATE.
@@ -13,9 +13,11 @@ LED STATES (user-specified color scheme):
     thinking                 - PINK pulse (LLM processing)
     tts_processing           - ORANGE pulse (generating speech)
     speaking                 - Dark GREEN chase pattern (playing audio)
-    scanning                 - White/teal rotating sweep (360 scan)
-    gas_danger               - Red pulse (gas danger)
-    error                    - RED blink (system error)
+    scanning                 - Hazard-style sweep
+    gas_warning              - Strong amber alert
+    gas_danger               - Aggressive red attention
+    error                    - Solid red
+    sleep                    - Dim blue/purple fade
 
 DESIGN PRINCIPLE:
     If a human cannot tell what the system is doing
@@ -49,7 +51,7 @@ RGB = tuple[int, int, int]
 
 
 class LedRingHardware:
-    """Thin wrapper around the NeoPixel ring to centralize error handling."""
+    """Thin wrapper around the NeoPixel strip to centralize error handling."""
 
     def __init__(
         self,
@@ -124,20 +126,23 @@ class LedRingHardware:
 
 class LedAnimator:
     """Generates color frames for each phase state.
-    
+
     LED = f(Phase). Each phase has a distinct, human-recognizable pattern.
-    
+
     COLOR SCHEME (user-specified):
-        idle (wakeword listening) - Dim cyan breathing (waiting)
-        wakeword_detected        - Bright GREEN flash (acknowledged!)
-        listening (STT capture)  - Bright BLUE sweep (capturing audio)
-        transcribing             - PURPLE pulse (STT processing)
-        thinking                 - PINK pulse (LLM processing)
-        tts_processing           - ORANGE pulse (generating speech)
-        speaking                 - Dark GREEN chase pattern (playing audio)
-        scanning                 - White/teal rotating sweep (360 scan)
-        gas_danger               - Red pulse (gas danger)
-        error                    - RED blink (system error)
+        idle (wakeword listening) - Dim cool breathing glow
+        wakeword_detected        - Bright pulse sweeping left -> right
+        listening                - Same color, slower sweep
+        thinking                 - 3-LED frame moving left <-> right
+        speaking                 - Calm centered glow
+        scanning                 - Hazard-style sweep (~70% brightness)
+        gas_warning              - Strong amber alert
+        gas_danger               - Aggressive red attention pattern
+        error                    - Solid red
+        sleep                    - Dim blue/purple fade
+        forward                  - All LEDs white, full brightness
+        left                     - LEDs 0-1 yellow
+        right                    - LEDs 7-9 yellow
     """
 
     def __init__(self, hardware: LedRingHardware) -> None:
@@ -161,37 +166,36 @@ class LedAnimator:
         renderer(now)
         self._last_render = now
 
+    def _sweep(self, now: float, color: RGB, speed: float) -> None:
+        pos = (now * speed) % max(1, self.hw.pixel_count)
+        colors: list[RGB] = []
+        for idx in range(self.hw.pixel_count):
+            delta = abs(idx - pos)
+            fade = max(0.0, 1.0 - (delta / 2.5))
+            r, g, b = color
+            colors.append((int(r * fade), int(g * fade), int(b * fade)))
+        self.hw.show(colors)
+
+    def _ping_pong_pos(self, now: float, speed: float) -> int:
+        if self.hw.pixel_count <= 1:
+            return 0
+        span = (self.hw.pixel_count - 1) * 2
+        step = int(now * speed) % span
+        return step if step < self.hw.pixel_count else span - step
+
     def _render_idle(self, now: float) -> None:
-        """IDLE: Dim cyan breathing - waiting for wakeword."""
+        """IDLE: Dim cool breathing glow."""
         phase = 0.5 + 0.5 * math.sin(now * 1.0)  # Slow breathing
         level = int(5 + 25 * phase)  # Dim: 5-30 range
         self.hw.fill((0, level, level + 3))  # Dim cyan
 
     def _render_wakeword_detected(self, now: float) -> None:
-        """WAKEWORD DETECTED: Bright GREEN flash then settle."""
-        elapsed = now - self._state_entered
-        if elapsed < 0.3:
-            # Bright flash
-            self.hw.fill((0, 255, 0))
-        elif elapsed < 0.6:
-            # Quick fade
-            fade = 1.0 - (elapsed - 0.3) / 0.3
-            level = int(255 * fade)
-            self.hw.fill((0, level, 0))
-        else:
-            # Settle to bright green glow
-            self.hw.fill((0, 150, 20))
+        """WAKEWORD: Bright pulse sweeping left -> right."""
+        self._sweep(now, (0, 220, 200), speed=10.0)
 
     def _render_listening(self, now: float) -> None:
-        """LISTENING: Bright BLUE sweep - actively capturing audio."""
-        pos = (now * 8) % self.hw.pixel_count  # Faster sweep
-        colors: list[RGB] = []
-        for idx in range(self.hw.pixel_count):
-            delta = min((idx - pos) % self.hw.pixel_count, (pos - idx) % self.hw.pixel_count)
-            fade = max(0.0, 1.0 - delta / 2.0)
-            value = int(80 + 175 * fade)  # Bright blue: 80-255
-            colors.append((0, int(20 * fade), value))
-        self.hw.show(colors)
+        """LISTENING: Same color, slower sweep."""
+        self._sweep(now, (0, 220, 200), speed=4.0)
 
     def _render_transcribing(self, now: float) -> None:
         """TRANSCRIBING: PURPLE pulse - STT processing."""
@@ -202,12 +206,15 @@ class LedAnimator:
         self.hw.fill((r, g, b))
 
     def _render_thinking(self, now: float) -> None:
-        """THINKING: PINK pulse - LLM processing."""
-        phase = 0.5 + 0.5 * math.sin(now * 2.5)
-        r = int(200 + 55 * phase)   # Pink: strong R
-        g = int(50 + 50 * phase)    # Some green for pink
-        b = int(100 + 80 * phase)   # Medium blue for pink
-        self.hw.fill((r, g, b))
+        """THINKING: 3-LED frame moving left <-> right."""
+        pos = self._ping_pong_pos(now, speed=6.0)
+        colors: list[RGB] = []
+        for idx in range(self.hw.pixel_count):
+            if idx in {pos - 1, pos, pos + 1}:
+                colors.append((200, 80, 160))
+            else:
+                colors.append((0, 0, 0))
+        self.hw.show(colors)
 
     def _render_tts_processing(self, now: float) -> None:
         """TTS PROCESSING: ORANGE pulse - generating speech."""
@@ -218,38 +225,67 @@ class LedAnimator:
         self.hw.fill((r, g, b))
 
     def _render_speaking(self, now: float) -> None:
-        """SPEAKING: Dark GREEN chase pattern - TTS playing."""
-        # Create a chase/blink pattern
-        step = int(now * 6) % 4
-        colors: list[RGB] = []
-        for idx in range(self.hw.pixel_count):
-            if (idx + step) % 4 == 0:
-                colors.append((0, 120, 30))  # Dark green ON
-            else:
-                colors.append((0, 30, 10))   # Very dim
+        """SPEAKING: Calm centered glow."""
+        colors: list[RGB] = [(0, 0, 0)] * self.hw.pixel_count
+        center_left = max(0, (self.hw.pixel_count // 2) - 1)
+        center_right = min(self.hw.pixel_count - 1, center_left + 1)
+        for idx in {center_left, center_right}:
+            colors[idx] = (120, 120, 140)
         self.hw.show(colors)
 
     def _render_scanning(self, now: float) -> None:
-        """SCANNING: Rotating teal/white sweep to show 360 scan."""
-        pos = int(now * 10) % self.hw.pixel_count
+        """SCANNING: Hazard-style sweep (~70% brightness)."""
+        pos = int((now * 6) % max(1, self.hw.pixel_count))
         colors: list[RGB] = []
         for idx in range(self.hw.pixel_count):
-            delta = min((idx - pos) % self.hw.pixel_count, (pos - idx) % self.hw.pixel_count)
-            fade = max(0.0, 1.0 - delta / 2.0)
-            base = int(50 + 205 * fade)
-            colors.append((base, base, int(180 * fade)))
+            if idx in {pos, pos + 1}:
+                colors.append((180, 140, 0))
+            else:
+                colors.append((10, 8, 0))
         self.hw.show(colors)
 
-    def _render_gas_danger(self, now: float) -> None:
-        """GAS DANGER: Strong red pulse for hazardous gas detection."""
+    def _render_gas_warning(self, now: float) -> None:
+        """GAS WARNING: Strong amber alert."""
         phase = 0.5 + 0.5 * math.sin(now * 4)
-        level = int(80 + 175 * phase)
+        level = int(120 + 120 * phase)
+        self.hw.fill((level, int(level * 0.7), 0))
+
+    def _render_gas_danger(self, now: float) -> None:
+        """GAS DANGER: Aggressive red attention pattern."""
+        phase = 0.5 + 0.5 * math.sin(now * 8)
+        level = int(140 + 115 * phase)
         self.hw.fill((level, 0, 0))
 
     def _render_error(self, now: float) -> None:
-        """ERROR: RED blink - something is wrong."""
-        on = int(now * 4) % 2 == 0
-        self.hw.fill((200, 0, 0) if on else (20, 0, 0))
+        """ERROR: Solid red."""
+        self.hw.fill((200, 0, 0))
+
+    def _render_sleep(self, now: float) -> None:
+        """SLEEP: Dim blue/purple fade."""
+        phase = 0.5 + 0.5 * math.sin(now * 0.6)
+        r = int(10 + 15 * phase)
+        g = int(0 + 5 * phase)
+        b = int(25 + 25 * phase)
+        self.hw.fill((r, g, b))
+
+    def _render_forward(self, now: float) -> None:
+        """FORWARD: All LEDs white, full brightness."""
+        self.hw.fill((255, 255, 255))
+
+    def _render_left(self, now: float) -> None:
+        """LEFT: LEDs 0-1 yellow."""
+        colors = [(0, 0, 0)] * self.hw.pixel_count
+        for idx in range(min(2, self.hw.pixel_count)):
+            colors[idx] = (255, 200, 0)
+        self.hw.show(colors)
+
+    def _render_right(self, now: float) -> None:
+        """RIGHT: LEDs 7-9 yellow."""
+        colors = [(0, 0, 0)] * self.hw.pixel_count
+        start = max(0, self.hw.pixel_count - 3)
+        for idx in range(start, self.hw.pixel_count):
+            colors[idx] = (255, 200, 0)
+        self.hw.show(colors)
 
 
 class LedRingService:
@@ -357,7 +393,7 @@ def parse_args() -> argparse.Namespace:
     parser = argparse.ArgumentParser(description="Run the orchestrator LED ring service")
     parser.add_argument("--config", default="config/system.yaml", help="Path to system config")
     parser.add_argument("--pin", default="D12", help="Board pin attribute for the NeoPixel ring")
-    parser.add_argument("--pixels", type=int, default=8, help="Number of LEDs on the ring")
+    parser.add_argument("--pixels", type=int, default=10, help="Number of LEDs on the strip")
     parser.add_argument("--brightness", type=float, default=0.25, help="LED brightness (0-1)")
     parser.add_argument(
         "--dry-run",
diff --git a/src/remote/remote_interface.py b/src/remote/remote_interface.py
index 3a3de2e..fcb1382 100644
--- a/src/remote/remote_interface.py
+++ b/src/remote/remote_interface.py
@@ -64,8 +64,9 @@ class TelemetryState:
         self.last_tts_status: Optional[str] = None
         self.last_tts_ts: Optional[float] = None
         self.last_scan_summary: Optional[str] = None
-        self.last_scan_ts: Optional[float] = None
-        self.gas_threshold: int = 800
+        self.gas_level: Optional[int] = None
+        self.gas_warning: Optional[bool] = None
+        self.gas_severity: Optional[str] = None
 
     def snapshot(self) -> Dict[str, Any]:
         with self.lock:
@@ -75,19 +76,11 @@ class TelemetryState:
             min_distance: Optional[int] = None
             obstacle = False
             warning = False
-            gas_level: Optional[int] = None
-            gas_warning = False
             if self.last_esp and "data" in self.last_esp:
                 data = self.last_esp["data"] or {}
                 obstacle = bool(data.get("obstacle", False))
                 warning = bool(data.get("warning", False))
                 min_distance = data.get("min_distance")
-                gas_level = data.get("mq2")
-                try:
-                    gas_level = int(gas_level) if gas_level is not None else None
-                except Exception:
-                    gas_level = None
-                gas_warning = gas_level is not None and gas_level >= self.gas_threshold
                 is_safe = data.get("is_safe")
                 if isinstance(is_safe, bool):
                     motor_enabled = is_safe
@@ -116,16 +109,16 @@ class TelemetryState:
                 "motor": motor,
                 "safety_stop": safety_stop,
                 "safety_alert": self.last_alert,
-                "gas_level": gas_level,
-                "gas_warning": gas_warning,
-                "last_scan_summary": self.last_scan_summary,
-                "last_scan_ts": int(self.last_scan_ts) if self.last_scan_ts else None,
                 "sensor": self.last_esp.get("data") if self.last_esp else None,
                 "sensor_ts": self.last_esp.get("data_ts") if self.last_esp else None,
                 "sensor_buffer": self.last_esp.get("buffer") if self.last_esp else None,
                 "vision_last_detection": self.last_detection,
                 "detection_history": list(self.detection_history),
                 "last_capture": self.last_capture,
+                "last_scan_summary": self.last_scan_summary,
+                "gas_level": self.gas_level,
+                "gas_warning": self.gas_warning,
+                "gas_severity": self.gas_severity,
                 "last_llm_response": self.last_llm_response,
                 "last_llm_ts": int(self.last_llm_ts) if self.last_llm_ts else None,
                 "last_tts_text": self.last_tts_text,
@@ -151,7 +144,6 @@ class RemoteSupervisor:
         self.allowed_cidrs = self._parse_cidrs(remote_cfg.get("allowed_cidrs", ["100.64.0.0/10"]))
         self.session_timeout_s = float(remote_cfg.get("session_timeout_s", 15.0))
         self._detection_history_max = int(remote_cfg.get("detection_history_max", 200))
-        self.telemetry.gas_threshold = int(self.config.get("orchestrator", {}).get("gas_threshold", 800))
 
         self.telemetry = TelemetryState()
         self._ctx = zmq.Context.instance()
@@ -362,15 +354,30 @@ class RemoteSupervisor:
                         self.telemetry.last_alert = str(alert)
                     if payload.get("blocked"):
                         self.telemetry.last_alert = str(payload.get("reason", "blocked"))
+                    data = payload.get("data") or {}
+                    if "mq2" in data:
+                        try:
+                            self.telemetry.gas_level = int(data.get("mq2"))
+                        except (TypeError, ValueError):
+                            self.telemetry.gas_level = None
+                        if self.telemetry.gas_level is not None and self.telemetry.gas_severity is None:
+                            self.telemetry.gas_severity = "unknown"
                 elif topic == TOPIC_HEALTH:
                     self.telemetry.last_health = payload
                 elif topic == TOPIC_REMOTE_EVENT:
                     self.telemetry.last_remote_event = payload
-                    if payload.get("event") == "scan_complete":
-                        summary = payload.get("summary")
-                        if summary:
-                            self.telemetry.last_scan_summary = str(summary)
-                            self.telemetry.last_scan_ts = payload.get("timestamp") or time.time()
+                    event = payload.get("event")
+                    if event == "scan_complete":
+                        self.telemetry.last_scan_summary = payload.get("summary")
+                    elif event == "gas_warning":
+                        self.telemetry.gas_warning = True
+                        self.telemetry.gas_severity = "warning"
+                    elif event == "gas_danger":
+                        self.telemetry.gas_warning = True
+                        self.telemetry.gas_severity = "danger"
+                    elif event == "gas_clear":
+                        self.telemetry.gas_warning = False
+                        self.telemetry.gas_severity = "clear"
                 elif topic == TOPIC_VISN_CAPTURED:
                     self.telemetry.last_capture = payload
                 elif topic == TOPIC_LLM_RESP:
diff --git a/systemd/led-ring.service b/systemd/led-ring.service
index 6b18c94..cc7c1f6 100644
--- a/systemd/led-ring.service
+++ b/systemd/led-ring.service
@@ -12,7 +12,7 @@ Environment=PROJECT_ROOT=/home/dev/smart_car
 Environment=PYTHONPATH=/home/dev/smart_car
 Environment=PYTHONUNBUFFERED=1
 EnvironmentFile=/home/dev/smart_car/.env
-ExecStart=/home/dev/smart_car/.venvs/visn-py313/bin/python -m src.piled.led_ring_service --config config/system.yaml
+ExecStart=/home/dev/smart_car/.venvs/visn-py313/bin/python -m src.piled.led_ring_service --config config/system.yaml --pixels 10
 Restart=on-failure
 RestartSec=3
 StandardOutput=append:/home/dev/smart_car/logs/led-ring.log
