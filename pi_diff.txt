diff --git a/mobile_app/app/src/main/AndroidManifest.xml b/mobile_app/app/src/main/AndroidManifest.xml
index d82f135..b2e1647 100644
--- a/mobile_app/app/src/main/AndroidManifest.xml
+++ b/mobile_app/app/src/main/AndroidManifest.xml
@@ -1,15 +1,12 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android">
 
     <uses-permission android:name="android.permission.INTERNET" />
-    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
-    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
 
     <application
         android:icon="@drawable/app_icon_smart_car"
         android:roundIcon="@drawable/app_icon_smart_car"
         android:label="@string/app_name"
         android:theme="@style/Theme.Supervision"
-        android:requestLegacyExternalStorage="true"
         android:usesCleartextTraffic="true"
         android:networkSecurityConfig="@xml/network_security_config">
         <activity
diff --git a/mobile_app/app/src/main/java/com/smartcar/supervision/MainActivity.kt b/mobile_app/app/src/main/java/com/smartcar/supervision/MainActivity.kt
index f4970bb..92f589d 100644
--- a/mobile_app/app/src/main/java/com/smartcar/supervision/MainActivity.kt
+++ b/mobile_app/app/src/main/java/com/smartcar/supervision/MainActivity.kt
@@ -1,42 +1,18 @@
 package com.smartcar.supervision
 
 import android.os.Bundle
-import android.Manifest
-import android.content.pm.PackageManager
-import android.os.Build
-import androidx.core.app.ActivityCompat
-import androidx.core.content.ContextCompat
 import androidx.activity.ComponentActivity
 import androidx.activity.compose.setContent
 import androidx.lifecycle.viewmodel.compose.viewModel
 import com.smartcar.supervision.ui.AppViewModel
 import com.smartcar.supervision.ui.screens.MainScreen
-import com.smartcar.supervision.ui.theme.SupervisionTheme
 
 class MainActivity : ComponentActivity() {
     override fun onCreate(savedInstanceState: Bundle?) {
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-            val writeGranted = ContextCompat.checkSelfPermission(
-                this,
-                Manifest.permission.WRITE_EXTERNAL_STORAGE
-            ) == PackageManager.PERMISSION_GRANTED
-            if (!writeGranted) {
-                ActivityCompat.requestPermissions(
-                    this,
-                    arrayOf(
-                        Manifest.permission.WRITE_EXTERNAL_STORAGE,
-                        Manifest.permission.READ_EXTERNAL_STORAGE
-                    ),
-                    1001
-                )
-            }
-        }
         super.onCreate(savedInstanceState)
         setContent {
-            SupervisionTheme {
-                val vm: AppViewModel = viewModel()
-                MainScreen(viewModel = vm)
-            }
+            val vm: AppViewModel = viewModel()
+            MainScreen(viewModel = vm)
         }
     }
 }
diff --git a/mobile_app/app/src/main/java/com/smartcar/supervision/data/IntentModels.kt b/mobile_app/app/src/main/java/com/smartcar/supervision/data/IntentModels.kt
deleted file mode 100644
index 1a734b3..0000000
--- a/mobile_app/app/src/main/java/com/smartcar/supervision/data/IntentModels.kt
+++ /dev/null
@@ -1,23 +0,0 @@
-package com.smartcar.supervision.data
-
-data class IntentRequest(
-    val intent: String,
-    val direction: String? = null,
-    val speed: Int? = null,
-    val duration_ms: Int? = null,
-    val extras: Map<String, Any>? = null,
-)
-
-data class IntentResponse(
-    val ok: Boolean? = null,
-    val message: String? = null,
-    val data: Map<String, Any>? = null,
-)
-
-fun IntentResponse.toMap(): Map<String, Any> {
-    val payload = mutableMapOf<String, Any>()
-    if (ok != null) payload["ok"] = ok
-    if (message != null) payload["message"] = message
-    if (data != null) payload["data"] = data
-    return payload
-}
\ No newline at end of file
diff --git a/mobile_app/app/src/main/java/com/smartcar/supervision/data/Models.kt b/mobile_app/app/src/main/java/com/smartcar/supervision/data/Models.kt
index a971ba7..6566945 100644
--- a/mobile_app/app/src/main/java/com/smartcar/supervision/data/Models.kt
+++ b/mobile_app/app/src/main/java/com/smartcar/supervision/data/Models.kt
@@ -13,19 +13,11 @@ data class TelemetrySnapshot(
     val vision_active: Boolean? = null,
     val vision_paused: Boolean? = null,
     val motor_enabled: Boolean? = null,
-    val motor: MotorState? = null,
     val safety_stop: Boolean? = null,
     val safety_alert: String? = null,
     val sensor: SensorData? = null,
-    val sensor_ts: Long? = null,
-    val sensor_buffer: List<SensorData>? = null,
     val vision_last_detection: VisionDetection? = null,
     val detection_history: List<VisionDetection>? = null,
-    val last_llm_response: String? = null,
-    val last_llm_ts: Long? = null,
-    val last_tts_text: String? = null,
-    val last_tts_status: String? = null,
-    val last_tts_ts: Long? = null,
     val health: HealthStatus? = null,
     val remote_event: RemoteEvent? = null,
 )
@@ -36,21 +28,12 @@ data class SensorData(
     val s2: Int? = null,
     val s3: Int? = null,
     val mq2: Int? = null,
-    val lmotor: Int? = null,
-    val rmotor: Int? = null,
     val min_distance: Int? = null,
     val obstacle: Boolean? = null,
     val warning: Boolean? = null,
     val is_safe: Boolean? = null,
 )
 
-@JsonClass(generateAdapter = true)
-data class MotorState(
-    val left: Int? = null,
-    val right: Int? = null,
-    val ts: Long? = null,
-)
-
 @JsonClass(generateAdapter = true)
 data class VisionDetection(
     val label: String? = null,
@@ -74,12 +57,3 @@ data class RemoteEvent(
     val direction: String? = null,
     val timestamp: Long? = null,
 )
-
-@JsonClass(generateAdapter = true)
-data class LogLinesResponse(
-    val service: String? = null,
-    val lines: List<String>? = null,
-    val sources: List<String>? = null,
-    val ts: Long? = null,
-    val error: String? = null,
-)
diff --git a/mobile_app/app/src/main/java/com/smartcar/supervision/data/RobotApi.kt b/mobile_app/app/src/main/java/com/smartcar/supervision/data/RobotApi.kt
index 292d762..141ad24 100644
--- a/mobile_app/app/src/main/java/com/smartcar/supervision/data/RobotApi.kt
+++ b/mobile_app/app/src/main/java/com/smartcar/supervision/data/RobotApi.kt
@@ -4,7 +4,6 @@ import retrofit2.Response
 import retrofit2.http.Body
 import retrofit2.http.GET
 import retrofit2.http.POST
-import retrofit2.http.Query
 
 interface RobotApi {
     @GET("status")
@@ -17,11 +16,5 @@ interface RobotApi {
     suspend fun getHealth(): HealthStatus
 
     @POST("intent")
-    suspend fun postIntent(@Body payload: IntentRequest): Response<IntentResponse>
-
-    @GET("logs")
-    suspend fun getLogs(
-        @Query("service") service: String,
-        @Query("lines") lines: Int,
-    ): LogLinesResponse
+    suspend fun postIntent(@Body payload: Map<String, Any>): Response<Map<String, Any>>
 }
diff --git a/mobile_app/app/src/main/java/com/smartcar/supervision/data/RobotRepository.kt b/mobile_app/app/src/main/java/com/smartcar/supervision/data/RobotRepository.kt
index dfaf687..e693cbb 100644
--- a/mobile_app/app/src/main/java/com/smartcar/supervision/data/RobotRepository.kt
+++ b/mobile_app/app/src/main/java/com/smartcar/supervision/data/RobotRepository.kt
@@ -102,20 +102,13 @@ class RobotRepository(
         return runCatching { api.getHealth() }
     }
 
-    suspend fun fetchLogs(service: String, lines: Int): Result<LogLinesResponse> {
-        return runCatching { api.getLogs(service, lines) }
-    }
-
     suspend fun sendIntent(intent: String, extras: Map<String, Any> = emptyMap()): IntentResult {
-        val request = IntentRequest(
-            intent = intent,
-            extras = if (extras.isEmpty()) null else extras,
-        )
+        val payload = mutableMapOf<String, Any>("intent" to intent)
+        payload.putAll(extras)
         return try {
-            val response = api.postIntent(request)
+            val response = api.postIntent(payload)
             if (response.isSuccessful) {
-                val body = response.body()?.toMap() ?: emptyMap()
-                IntentResult.Accepted(body)
+                IntentResult.Accepted(response.body() ?: emptyMap())
             } else {
                 IntentResult.Rejected("http_${response.code()}")
             }
diff --git a/mobile_app/app/src/main/java/com/smartcar/supervision/ui/AppLog.kt b/mobile_app/app/src/main/java/com/smartcar/supervision/ui/AppLog.kt
deleted file mode 100644
index 667df32..0000000
--- a/mobile_app/app/src/main/java/com/smartcar/supervision/ui/AppLog.kt
+++ /dev/null
@@ -1,90 +0,0 @@
-package com.smartcar.supervision.ui
-
-import java.time.Instant
-import java.time.ZoneId
-import java.time.format.DateTimeFormatter
-
-enum class LogCategory {
-    UI,
-    NETWORK,
-    INTENT,
-    STATE,
-}
-
-data class AppLogEntry(
-    val ts: Long,
-    val category: LogCategory,
-    val event: String,
-    val message: String? = null,
-    val data: Map<String, Any?> = emptyMap(),
-) {
-    fun toJsonLine(): String {
-        val payload = mapOf(
-            "ts" to ts,
-            "ts_iso" to formatTimestamp(ts),
-            "category" to category.name.lowercase(),
-            "event" to event,
-            "message" to message,
-            "data" to data,
-        )
-        return JsonEncoder.encode(payload)
-    }
-
-    fun toDisplayLine(): String {
-        val time = DateTimeFormatter.ofPattern("HH:mm:ss").format(
-            Instant.ofEpochMilli(ts).atZone(ZoneId.systemDefault())
-        )
-        val base = "$time [${category.name}] $event"
-        val msg = message?.takeIf { it.isNotBlank() }?.let { " ??? $it" }.orEmpty()
-        val dataPart = if (data.isEmpty()) "" else " ??? ${data.entries.joinToString { "${it.key}=${it.value}" }}"
-        return "$base$msg$dataPart"
-    }
-
-    private fun formatTimestamp(value: Long): String {
-        return DateTimeFormatter.ISO_INSTANT.format(Instant.ofEpochMilli(value))
-    }
-}
-
-class AppLogger(
-    private val maxEntries: Int = 1000,
-) {
-    fun append(existing: List<AppLogEntry>, entry: AppLogEntry): List<AppLogEntry> {
-        return (existing + entry).takeLast(maxEntries)
-    }
-}
-
-private object JsonEncoder {
-    fun encode(value: Any?): String = encodeValue(value)
-
-    private fun encodeValue(value: Any?): String = when (value) {
-        null -> "null"
-        is Boolean, is Int, is Long, is Double, is Float -> value.toString()
-        is Number -> value.toString()
-        is String -> "\"${escape(value)}\""
-        is Map<*, *> -> encodeMap(value)
-        is Iterable<*> -> encodeList(value)
-        else -> "\"${escape(value.toString())}\""
-    }
-
-    private fun encodeMap(map: Map<*, *>): String {
-        val entries = map.entries.joinToString(separator = ",") { entry ->
-            val key = entry.key?.toString() ?: ""
-            "\"${escape(key)}\":${encodeValue(entry.value)}"
-        }
-        return "{$entries}"
-    }
-
-    private fun encodeList(list: Iterable<*>): String {
-        val entries = list.joinToString(separator = ",") { encodeValue(it) }
-        return "[$entries]"
-    }
-
-    private fun escape(value: String): String {
-        return value
-            .replace("\\", "\\\\")
-            .replace("\"", "\\\"")
-            .replace("\n", "\\n")
-            .replace("\r", "\\r")
-            .replace("\t", "\\t")
-    }
-}
\ No newline at end of file
diff --git a/mobile_app/app/src/main/java/com/smartcar/supervision/ui/AppState.kt b/mobile_app/app/src/main/java/com/smartcar/supervision/ui/AppState.kt
index b821090..51498ed 100644
--- a/mobile_app/app/src/main/java/com/smartcar/supervision/ui/AppState.kt
+++ b/mobile_app/app/src/main/java/com/smartcar/supervision/ui/AppState.kt
@@ -24,38 +24,13 @@ data class AppState(
     val lastIntentResult: String? = null,
     val lastIntentSent: String? = null,
     val lastIntentAt: Long? = null,
-    val lastIntentResultAt: Long? = null,
-    val lastUiAction: String? = null,
-    val lastUiActionAt: Long? = null,
-    val lastUiActionEnabled: Boolean? = null,
-    val lastUiActionBlockedReason: String? = null,
     val lastRemoteEvent: String? = null,
-    val logs: List<AppLogEntry> = emptyList(),
+    val logs: List<String> = emptyList(),
     val logExportResult: String? = null,
-    val backendLogs: Map<BackendLogService, BackendLogSnapshot> = emptyMap(),
-    val backendLogsUpdatedAt: Long? = null,
-    val logAutoRefresh: Boolean = true,
-    val logLinesLimit: Int = 200,
     val debugPanelVisible: Boolean = false,
     val settings: com.smartcar.supervision.data.AppSettings? = null,
 )
 
-enum class BackendLogService(val label: String, val apiName: String) {
-    APP("App", "app"),
-    REMOTE_INTERFACE("Remote Interface", "remote_interface"),
-    ORCHESTRATOR("Orchestrator", "orchestrator"),
-    UART("UART", "uart"),
-    VISION("Vision", "vision"),
-    LLM_TTS("LLM / TTS", "llm_tts"),
-}
-
-data class BackendLogSnapshot(
-    val lines: List<String> = emptyList(),
-    val sources: List<String> = emptyList(),
-    val error: String? = null,
-    val updatedAt: Long? = null,
-)
-
 enum class AppStatus {
     OFFLINE,
     CONNECTING,
diff --git a/mobile_app/app/src/main/java/com/smartcar/supervision/ui/AppViewModel.kt b/mobile_app/app/src/main/java/com/smartcar/supervision/ui/AppViewModel.kt
index c0648e0..b6ef7ee 100644
--- a/mobile_app/app/src/main/java/com/smartcar/supervision/ui/AppViewModel.kt
+++ b/mobile_app/app/src/main/java/com/smartcar/supervision/ui/AppViewModel.kt
@@ -9,14 +9,11 @@ import com.smartcar.supervision.data.IntentResult
 import com.smartcar.supervision.data.RobotRepository
 import com.smartcar.supervision.data.SettingsStore
 import kotlinx.coroutines.Job
-import kotlinx.coroutines.delay
 import kotlinx.coroutines.flow.MutableStateFlow
 import kotlinx.coroutines.flow.StateFlow
 import kotlinx.coroutines.flow.asStateFlow
-import kotlinx.coroutines.isActive
 import kotlinx.coroutines.launch
 import java.io.File
-import android.os.Environment
 import java.net.URI
 import java.time.LocalDateTime
 import java.time.format.DateTimeFormatter
@@ -26,15 +23,13 @@ class AppViewModel(
 ) : ViewModel() {
     private val _state = MutableStateFlow(AppState())
     val state: StateFlow<AppState> = _state.asStateFlow()
-    private val logger = AppLogger(1000)
     private var lastTelemetryLogAt: Long = 0L
     private var pollJob: Job? = null
-    private var logPollJob: Job? = null
     private var settingsStore: SettingsStore? = null
     private var contextBound = false
 
     init {
-        log(LogCategory.STATE, "app_start")
+        appendLog("app_start")
         _state.value = _state.value.copy(appStatus = AppStatus.CONNECTING)
     }
 
@@ -51,10 +46,8 @@ class AppViewModel(
         )
         repo.updateBaseUrl(settings.baseUrl())
         startPolling(settings.pollIntervalMs)
-        startLogPolling(settings.pollIntervalMs)
         refreshNow()
-        refreshBackendLogs()
-        log(LogCategory.STATE, "settings_loaded", data = mapOf("base_url" to settings.baseUrl()))
+        appendLog("settings_loaded:${settings.baseUrl()}")
     }
 
     fun updateSettings(settings: AppSettings) {
@@ -65,10 +58,8 @@ class AppViewModel(
         )
         repo.updateBaseUrl(settings.baseUrl())
         startPolling(settings.pollIntervalMs)
-        startLogPolling(settings.pollIntervalMs)
         refreshNow()
-        refreshBackendLogs()
-        log(LogCategory.STATE, "settings_updated", data = mapOf("base_url" to settings.baseUrl()))
+        appendLog("settings_updated:${settings.baseUrl()}")
     }
 
     fun refreshNow() {
@@ -88,19 +79,19 @@ class AppViewModel(
                     lastTelemetryAt = if (snapshot.telemetry != null) now else current.lastTelemetryAt,
                     lastRemoteEvent = remoteEvent ?: current.lastRemoteEvent,
                 )
-                log(LogCategory.NETWORK, "refresh_ok")
+                appendLog("refresh_ok")
             }.onFailure { err ->
                 _state.value = _state.value.copy(
                     connection = ConnectionStatus.Error(err.message ?: "refresh_error")
                 )
-                log(LogCategory.NETWORK, "refresh_error", message = err.message ?: "unknown")
+                appendLog("refresh_error:${err.message ?: "unknown"}")
             }
 
             val health = repo.checkHealth()
             health.onSuccess {
                 _state.value = _state.value.copy(health = it)
             }.onFailure { err ->
-                log(LogCategory.NETWORK, "health_error", message = err.message ?: "unknown")
+                appendLog("health_error:${err.message ?: "unknown"}")
             }
 
             refreshAppStatus()
@@ -125,7 +116,7 @@ class AppViewModel(
                         lastRemoteEvent = remoteEvent ?: current.lastRemoteEvent,
                     )
                     if (now - lastTelemetryLogAt > 30_000) {
-                        log(LogCategory.NETWORK, "telemetry_ok")
+                        appendLog("telemetry_ok")
                         lastTelemetryLogAt = now
                     }
                     refreshAppStatus()
@@ -133,96 +124,22 @@ class AppViewModel(
                     _state.value = _state.value.copy(
                         connection = ConnectionStatus.Error(err.message ?: "telemetry_error")
                     )
-                    log(LogCategory.NETWORK, "telemetry_error", message = err.message ?: "unknown")
+                    appendLog("telemetry_error:${err.message ?: "unknown"}")
                     refreshAppStatus()
                 }
             }
         }
     }
 
-    private fun startLogPolling(pollMs: Long) {
-        logPollJob?.cancel()
-        logPollJob = viewModelScope.launch {
-            while (isActive) {
-                if (_state.value.logAutoRefresh) {
-                    fetchBackendLogsOnce()
-                }
-                delay(pollMs)
-            }
-        }
-    }
-
-    fun setLogAutoRefresh(enabled: Boolean) {
-        _state.value = _state.value.copy(logAutoRefresh = enabled)
-    }
-
-    fun refreshBackendLogs() {
-        viewModelScope.launch {
-            fetchBackendLogsOnce()
-        }
-    }
-
-    private suspend fun fetchBackendLogsOnce() {
-        val limit = _state.value.logLinesLimit
-        val services = listOf(
-            BackendLogService.REMOTE_INTERFACE,
-            BackendLogService.ORCHESTRATOR,
-            BackendLogService.UART,
-            BackendLogService.VISION,
-            BackendLogService.LLM_TTS,
-        )
-        val now = System.currentTimeMillis()
-        val snapshots = mutableMapOf<BackendLogService, BackendLogSnapshot>()
-        services.forEach { service ->
-            val result = repo.fetchLogs(service.apiName, limit)
-            result.onSuccess { payload ->
-                snapshots[service] = BackendLogSnapshot(
-                    lines = payload.lines.orEmpty(),
-                    sources = payload.sources.orEmpty(),
-                    error = payload.error,
-                    updatedAt = payload.ts?.let { it * 1000L } ?: now,
-                )
-            }.onFailure { err ->
-                snapshots[service] = BackendLogSnapshot(
-                    lines = emptyList(),
-                    sources = emptyList(),
-                    error = err.message ?: "log_fetch_error",
-                    updatedAt = now,
-                )
-            }
-        }
-        val current = _state.value
-        _state.value = current.copy(
-            backendLogs = current.backendLogs + snapshots,
-            backendLogsUpdatedAt = now,
-        )
-    }
-
     fun sendIntent(
         intent: String,
         extras: Map<String, Any> = emptyMap(),
         onComplete: ((IntentResult) -> Unit)? = null,
     ) {
         viewModelScope.launch {
-            val baseUrl = _state.value.settings?.baseUrl() ?: BuildConfig.ROBOT_BASE_URL
-            val payload = mapOf(
-                "intent" to intent,
-                "direction" to extras["direction"],
-                "speed" to extras["speed"],
-                "duration_ms" to extras["duration_ms"],
-                "extras" to if (extras.isEmpty()) null else extras,
-            )
             _state.value = _state.value.copy(intentInFlight = true)
             _state.value = _state.value.copy(lastIntentSent = intent, lastIntentAt = System.currentTimeMillis())
-            log(
-                LogCategory.INTENT,
-                "intent_sent",
-                data = mapOf(
-                    "intent" to intent,
-                    "payload" to payload,
-                    "url" to baseUrl.trimEnd('/') + "/intent",
-                )
-            )
+            appendLog("intent_send:$intent")
             refreshAppStatus()
             val result = repo.sendIntent(intent, extras)
             val message = when (result) {
@@ -231,17 +148,9 @@ class AppViewModel(
                 is IntentResult.TimedOut -> "timed_out: ${result.reason}"
                 is IntentResult.Failed -> "failed: ${result.reason}"
             }
-            _state.value = _state.value.copy(lastIntentResult = message, lastIntentResultAt = System.currentTimeMillis())
+            _state.value = _state.value.copy(lastIntentResult = message)
             _state.value = _state.value.copy(intentInFlight = false)
-            log(
-                LogCategory.INTENT,
-                "intent_result",
-                data = mapOf(
-                    "intent" to intent,
-                    "result" to message,
-                    "payload" to payload,
-                )
-            )
+            appendLog("intent_result:$intent:$message")
             refreshAppStatus()
             onComplete?.invoke(result)
         }
@@ -255,7 +164,7 @@ class AppViewModel(
                 label = "Scanning",
             )
         )
-        log(LogCategory.STATE, "task_start", data = mapOf("task" to "scan_observe_stop"))
+        appendLog("task_start:scan_observe_stop")
         sendIntent("scan") { result ->
             val label = when (result) {
                 is IntentResult.Accepted -> "Observe"
@@ -274,7 +183,7 @@ class AppViewModel(
                     label = label,
                 )
             )
-            log(LogCategory.STATE, "task_update", data = mapOf("task" to "scan_observe_stop", "phase" to phase.name))
+            appendLog("task_update:scan_observe_stop:${phase.name}")
             refreshAppStatus()
         }
     }
@@ -288,7 +197,7 @@ class AppViewModel(
                 label = "Observe",
             )
         )
-        log(LogCategory.STATE, "task_mark_observe")
+        appendLog("task_mark_observe")
         refreshAppStatus()
     }
 
@@ -311,14 +220,14 @@ class AppViewModel(
                     label = "Stopped",
                 )
             )
-            log(LogCategory.STATE, "task_stop")
+            appendLog("task_stop")
             refreshAppStatus()
         }
     }
 
     fun clearTask() {
         _state.value = _state.value.copy(task = TaskState())
-        log(LogCategory.STATE, "task_clear")
+        appendLog("task_clear")
         refreshAppStatus()
     }
 
@@ -334,97 +243,24 @@ class AppViewModel(
         }
     }
 
-    fun logUiAction(action: String, enabled: Boolean, blockedReason: String?) {
-        val now = System.currentTimeMillis()
-        val current = _state.value
-        _state.value = current.copy(
-            lastUiAction = action,
-            lastUiActionAt = now,
-            lastUiActionEnabled = enabled,
-            lastUiActionBlockedReason = blockedReason,
-        )
-        log(
-            LogCategory.UI,
-            "ui_action",
-            data = mapOf(
-                "action" to action,
-                "enabled" to enabled,
-                "blocked_reason" to blockedReason,
-                "app_status" to current.appStatus.name,
-                "blocking_reason" to current.blockingReason,
-            )
-        )
-    }
-
-    fun clearLogs() {
-        _state.value = _state.value.copy(logs = emptyList())
-        log(LogCategory.STATE, "log_clear")
-    }
-
-    private fun log(
-        category: LogCategory,
-        event: String,
-        message: String? = null,
-        data: Map<String, Any?> = emptyMap(),
-    ) {
-        val snapshot = appStateSnapshot(_state.value)
-        val entry = AppLogEntry(
-            ts = System.currentTimeMillis(),
-            category = category,
-            event = event,
-            message = message,
-            data = data + mapOf(
-                "app_state" to snapshot,
-                "last_ui_action" to _state.value.lastUiAction,
-                "last_intent_sent" to _state.value.lastIntentSent,
-                "last_intent_result" to _state.value.lastIntentResult,
-            ),
-        )
-        val updated = logger.append(_state.value.logs, entry)
+    fun appendLog(message: String) {
+        val timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_TIME)
+        val entry = "$timestamp $message"
+        val updated = (_state.value.logs + entry).takeLast(200)
         _state.value = _state.value.copy(logs = updated)
     }
 
-    private fun appStateSnapshot(state: AppState): Map<String, Any?> {
-        val connection = when (state.connection) {
-            ConnectionStatus.Online -> "online"
-            ConnectionStatus.Offline -> "offline"
-            is ConnectionStatus.Error -> "error"
-        }
-        val sessionActive = (state.telemetry?.remote_session_active == true) ||
-            (state.status?.remote_session_active == true)
-        return mapOf(
-            "connection" to connection,
-            "app_status" to state.appStatus.name,
-            "blocking_reason" to state.blockingReason,
-            "intent_in_flight" to state.intentInFlight,
-            "task_phase" to state.task.phase.name,
-            "remote_session_active" to sessionActive,
-        )
-    }
-
     fun exportLogs(context: Context) {
         val now = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"))
-        val externalRoot = Environment.getExternalStorageDirectory()
-        val logDir = File(externalRoot, "smart_car/logs")
-        if (!logDir.exists() && !logDir.mkdirs()) {
-            _state.value = _state.value.copy(logExportResult = "error: mkdir_failed ${logDir.absolutePath}")
-            log(LogCategory.STATE, "export_failed", message = "mkdir_failed", data = mapOf("path" to logDir.absolutePath))
-            return
-        }
-        val file = File(logDir, "app_logs_${now}.jsonl")
-        val content = _state.value.logs.joinToString(separator = "\n") { it.toJsonLine() }
+        val file = File(context.filesDir, "smartcar_log_$now.txt")
+        val content = _state.value.logs.joinToString(separator = "\n")
         try {
             file.writeText(content)
             _state.value = _state.value.copy(logExportResult = "saved: ${file.absolutePath}")
-            log(LogCategory.STATE, "export_success", data = mapOf("path" to file.absolutePath, "bytes" to file.length()))
+            appendLog("log_export:ok")
         } catch (err: Exception) {
             _state.value = _state.value.copy(logExportResult = "error: ${err.message ?: "unknown"}")
-            log(
-                LogCategory.STATE,
-                "export_failed",
-                message = err.message ?: "unknown",
-                data = mapOf("path" to file.absolutePath)
-            )
+            appendLog("log_export:error")
         }
     }
 
@@ -460,19 +296,7 @@ class AppViewModel(
             else -> null
         }
 
-        val changed = current.appStatus != status || current.blockingReason != blockingReason
         _state.value = current.copy(appStatus = status, blockingReason = blockingReason)
-        if (changed) {
-            log(
-                LogCategory.STATE,
-                "app_status_change",
-                data = mapOf(
-                    "from" to current.appStatus.name,
-                    "to" to status.name,
-                    "blocking_reason" to blockingReason,
-                )
-            )
-        }
     }
 
     private fun parseDefaultIpPort(): Pair<String, Int> {
diff --git a/mobile_app/app/src/main/java/com/smartcar/supervision/ui/screens/MainScreen.kt b/mobile_app/app/src/main/java/com/smartcar/supervision/ui/screens/MainScreen.kt
index 4b8f431..6085891 100644
--- a/mobile_app/app/src/main/java/com/smartcar/supervision/ui/screens/MainScreen.kt
+++ b/mobile_app/app/src/main/java/com/smartcar/supervision/ui/screens/MainScreen.kt
@@ -9,7 +9,6 @@ import androidx.compose.foundation.layout.Column
 import androidx.compose.foundation.layout.Row
 import androidx.compose.foundation.layout.Spacer
 import androidx.compose.foundation.layout.fillMaxSize
-import androidx.compose.foundation.layout.fillMaxWidth
 import androidx.compose.foundation.layout.height
 import androidx.compose.foundation.layout.padding
 import androidx.compose.foundation.layout.width
@@ -62,10 +61,8 @@ import okhttp3.Request
 import com.smartcar.supervision.BuildConfig
 import com.smartcar.supervision.data.AppSettings
 import com.smartcar.supervision.ui.AppStatus
-import com.smartcar.supervision.ui.BackendLogService
 import com.smartcar.supervision.ui.AppViewModel
 import com.smartcar.supervision.ui.ConnectionStatus
-import com.smartcar.supervision.ui.LogCategory
 import com.smartcar.supervision.ui.TaskPhase
 import com.smartcar.supervision.ui.TaskType
 import java.time.Instant
@@ -73,12 +70,10 @@ import java.time.ZoneId
 import java.time.format.DateTimeFormatter
 
 private enum class MainTab(val label: String) {
-    HOME("HOME"),
-    CONTROL("CTRL"),
-    VISION("VSN"),
-    SENSORS("SNS"),
-    LOGS("LOGS"),
-    SETTINGS("SET"),
+    STATUS("Status"),
+    CONTROL("Control"),
+    VISION("Vision"),
+    SETTINGS("Settings"),
 }
 
 @Composable
@@ -86,7 +81,7 @@ private enum class MainTab(val label: String) {
 fun MainScreen(viewModel: AppViewModel) {
     val state by viewModel.state.collectAsStateWithLifecycle()
     val context = LocalContext.current
-    var selectedTab by rememberSaveable { mutableStateOf(MainTab.HOME) }
+    var selectedTab by rememberSaveable { mutableStateOf(MainTab.STATUS) }
 
     LaunchedEffect(Unit) {
         viewModel.bindContext(context)
@@ -99,7 +94,7 @@ fun MainScreen(viewModel: AppViewModel) {
                     Column(verticalArrangement = Arrangement.spacedBy(2.dp)) {
                         Text("Smart Car Console")
                         Text(
-                            "${state.appStatus} ??? ${connectionLabel(state.connection)} ??? ${state.blockingReason ?: "ready"}",
+                            "${state.appStatus} ??? ${state.blockingReason ?: "ready"}",
                             style = MaterialTheme.typography.labelSmall
                         )
                     }
@@ -114,10 +109,10 @@ fun MainScreen(viewModel: AppViewModel) {
         bottomBar = {
             NavigationBar {
                 NavigationBarItem(
-                    selected = selectedTab == MainTab.HOME,
-                    onClick = { selectedTab = MainTab.HOME },
+                    selected = selectedTab == MainTab.STATUS,
+                    onClick = { selectedTab = MainTab.STATUS },
                     icon = { Icon(Icons.Filled.Info, contentDescription = null) },
-                    label = { Text(MainTab.HOME.label) },
+                    label = { Text(MainTab.STATUS.label) },
                 )
                 NavigationBarItem(
                     selected = selectedTab == MainTab.CONTROL,
@@ -131,18 +126,6 @@ fun MainScreen(viewModel: AppViewModel) {
                     icon = { Icon(Icons.Filled.Visibility, contentDescription = null) },
                     label = { Text(MainTab.VISION.label) },
                 )
-                NavigationBarItem(
-                    selected = selectedTab == MainTab.SENSORS,
-                    onClick = { selectedTab = MainTab.SENSORS },
-                    icon = { Icon(Icons.Filled.Tune, contentDescription = null) },
-                    label = { Text(MainTab.SENSORS.label) },
-                )
-                NavigationBarItem(
-                    selected = selectedTab == MainTab.LOGS,
-                    onClick = { selectedTab = MainTab.LOGS },
-                    icon = { Icon(Icons.Filled.Info, contentDescription = null) },
-                    label = { Text(MainTab.LOGS.label) },
-                )
                 NavigationBarItem(
                     selected = selectedTab == MainTab.SETTINGS,
                     onClick = { selectedTab = MainTab.SETTINGS },
@@ -157,7 +140,7 @@ fun MainScreen(viewModel: AppViewModel) {
             .padding(innerPadding)
 
         when (selectedTab) {
-            MainTab.HOME -> HomeScreen(
+            MainTab.STATUS -> StatusScreen(
                 modifier = contentModifier,
                 viewModel = viewModel,
                 onOpenSettings = { selectedTab = MainTab.SETTINGS },
@@ -165,22 +148,15 @@ fun MainScreen(viewModel: AppViewModel) {
             MainTab.CONTROL -> ControlScreen(
                 modifier = contentModifier,
                 viewModel = viewModel,
-                onOpenStatus = { selectedTab = MainTab.HOME },
+                onOpenStatus = { selectedTab = MainTab.STATUS },
                 onOpenSettings = { selectedTab = MainTab.SETTINGS },
             )
-            MainTab.SENSORS -> SensorsScreen(
-                modifier = contentModifier,
-                viewModel = viewModel,
-            )
             MainTab.VISION -> VisionScreen(
                 modifier = contentModifier,
                 viewModel = viewModel,
+                onOpenStatus = { selectedTab = MainTab.STATUS },
                 onOpenSettings = { selectedTab = MainTab.SETTINGS },
             )
-            MainTab.LOGS -> LogsScreen(
-                modifier = contentModifier,
-                viewModel = viewModel,
-            )
             MainTab.SETTINGS -> SettingsScreen(
                 modifier = contentModifier,
                 viewModel = viewModel,
@@ -190,20 +166,24 @@ fun MainScreen(viewModel: AppViewModel) {
 }
 
 @Composable
-private fun HomeScreen(
+private fun StatusScreen(
     modifier: Modifier,
     viewModel: AppViewModel,
     onOpenSettings: () -> Unit,
 ) {
     val state by viewModel.state.collectAsStateWithLifecycle()
+    val context = LocalContext.current
     val now = System.currentTimeMillis()
     val sessionActive = (state.telemetry?.remote_session_active == true) || (state.status?.remote_session_active == true)
-    val lastIntentAge = state.lastIntentAt?.let { now - it }
-    val commandRecent = lastIntentAge != null && lastIntentAge < 5_000
-    val lastIntentLabel = state.lastIntentSent ?: "UNAVAILABLE"
-    val motor = state.telemetry?.motor
-    val motorActive = motor?.let { it.left != 0 || it.right != 0 } ?: false
-    val safety = state.telemetry?.sensor
+    val busy = state.intentInFlight || state.task.phase == TaskPhase.EXECUTING
+    val telemetryAgeMs = state.lastTelemetryAt?.let { now - it }
+    val telemetryStale = telemetryAgeMs != null && telemetryAgeMs > 5_000
+    val telemetryFreshness = when {
+        state.lastTelemetryAt == null -> "unknown"
+        telemetryStale -> "stale"
+        else -> "ok"
+    }
+    val streamUrl = (state.telemetry?.stream_url ?: state.status?.stream_url).orEmpty().trim()
 
     Column(
         modifier = modifier
@@ -212,71 +192,126 @@ private fun HomeScreen(
         verticalArrangement = Arrangement.spacedBy(12.dp)
     ) {
         Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
-                Text("Robot Status", style = MaterialTheme.typography.titleLarge)
-                val statusLabel = when (state.appStatus) {
-                    AppStatus.ONLINE_IDLE -> "READY"
-                    AppStatus.ONLINE_BUSY -> "BUSY"
-                    AppStatus.ONLINE_EXECUTING_TASK -> "BUSY"
-                    AppStatus.ERROR -> "ERROR"
-                    AppStatus.OFFLINE, AppStatus.CONNECTING -> "OFFLINE"
-                }
-                Text(statusLabel, style = MaterialTheme.typography.headlineSmall)
+            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
+                Text("Connection", style = MaterialTheme.typography.titleMedium)
                 Text(
-                    "Connection: " + when (state.connection) {
-                        ConnectionStatus.Online -> "ONLINE"
-                        ConnectionStatus.Offline -> "OFFLINE"
-                        is ConnectionStatus.Error -> "ERROR"
+                    when (val c = state.connection) {
+                        ConnectionStatus.Online -> "online"
+                        ConnectionStatus.Offline -> "offline"
+                        is ConnectionStatus.Error -> "error: ${c.message}"
                     }
                 )
-                Text("Blocking: ${state.blockingReason ?: "UNAVAILABLE"}")
-                Text("Remote session: ${triState(sessionActive)}")
+                Text("App state: ${state.appStatus}")
+                Text("Blocking: ${state.blockingReason ?: "none"}")
+                Text("Health: ${confidenceLabel(state.health?.ok, state.lastStatusAt)}")
+                Text("Remote session: ${confidenceLabel(state.telemetry?.remote_session_active ?: state.status?.remote_session_active, state.lastTelemetryAt)}")
+                Text("Telemetry freshness: $telemetryFreshness")
+                Text("Status mode: ${confidenceLabel(state.status?.mode, state.lastStatusAt)}")
+                Text("Status display: ${confidenceLabel(state.status?.display_text, state.lastStatusAt)}")
+                Text("Telemetry mode: ${confidenceLabel(state.telemetry?.mode, state.lastTelemetryAt)}")
+                Text("Telemetry display: ${confidenceLabel(state.telemetry?.display_text, state.lastTelemetryAt)}")
+                Text("Vision mode: ${confidenceLabel(state.telemetry?.vision_mode, state.lastTelemetryAt)}")
+                Text("Safety stop: ${confidenceLabel(state.telemetry?.safety_stop, state.lastTelemetryAt)}")
+                Text("Intent busy: ${triState(if (busy) true else false)}")
+                Text("Last connect attempt: ${formatTimestamp(state.lastConnectAttemptAt)}")
                 Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
-                    Button(onClick = { viewModel.refreshNow() }) { Text("Retry now") }
-                    TextButton(onClick = onOpenSettings) { Text("Open settings") }
+                    Button(onClick = { viewModel.refreshNow() }) {
+                        Text("Retry now")
+                    }
+                    TextButton(onClick = onOpenSettings) {
+                        Text("Open settings")
+                    }
                 }
             }
         }
 
         Card {
             Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                Text("System snapshot", style = MaterialTheme.typography.titleMedium)
-                Text("Task: ${state.task.label.ifBlank { "UNAVAILABLE" }}")
-                Text("Last command: $lastIntentLabel")
-                Text("Last result: ${state.lastIntentResult ?: "UNAVAILABLE"}")
-                if (commandRecent) {
-                    Text("Command sent @ ${formatTimestamp(state.lastIntentAt)}")
+                Text("Failure surface", style = MaterialTheme.typography.titleMedium)
+                if (state.connection is ConnectionStatus.Error) {
+                    Text("Network failure: ${(state.connection as ConnectionStatus.Error).message}")
+                    Text("Operator action: check Tailscale connectivity")
+                }
+                if (!sessionActive) {
+                    Text("Session loss: remote session inactive")
+                    Text("Operator action: open telemetry or send intent when session re-established")
+                }
+                if (state.telemetry == null) {
+                    Text("Partial telemetry: /telemetry missing")
+                    Text("Operator action: wait for telemetry refresh")
+                }
+                if (state.status == null) {
+                    Text("Partial telemetry: /status missing")
+                    Text("Operator action: wait for status refresh")
+                }
+                if (state.telemetry?.vision_mode == "on_with_stream" && streamUrl.isBlank()) {
+                    Text("Vision unavailable: stream URL not provided")
+                    Text("Operator action: confirm backend stream URL")
+                }
+                if (state.lastIntentResult?.startsWith("rejected") == true) {
+                    Text("Intent rejected: ${state.lastIntentResult}")
+                    Text("Operator action: check session and intent validity")
+                }
+                if (state.lastIntentResult?.startsWith("timed_out") == true) {
+                    Text("Intent timeout: ${state.lastIntentResult}")
+                    Text("Operator action: retry manually when online")
+                }
+                if (state.lastIntentResult?.startsWith("failed") == true) {
+                    Text("Intent failure: ${state.lastIntentResult}")
+                    Text("Operator action: check network and retry")
+                }
+                if (state.connection is ConnectionStatus.Online && sessionActive &&
+                    state.status != null && state.telemetry != null &&
+                    state.lastIntentResult == null && !busy
+                ) {
+                    Text("No active failures")
                 }
-                Text("Motor active: ${triState(motorActive)}")
-                Text("Vision mode: ${confidenceLabel(state.telemetry?.vision_mode, state.lastTelemetryAt)}")
             }
         }
 
         Card {
             Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                Text("Safety", style = MaterialTheme.typography.titleMedium)
-                Text("Is safe: ${confidenceLabel(safety?.is_safe, state.telemetry?.sensor_ts)}")
-                Text("Obstacle: ${confidenceLabel(safety?.obstacle, state.telemetry?.sensor_ts)}")
-                Text("Warning: ${confidenceLabel(safety?.warning, state.telemetry?.sensor_ts)}")
-                Text("Sensor buffer: ${state.telemetry?.sensor_buffer ?: "UNAVAILABLE"}")
+                Text("Diagnostics", style = MaterialTheme.typography.titleMedium)
+                Text("App version: ${BuildConfig.VERSION_NAME}")
+                Text("Robot base URL: ${state.settings?.baseUrl() ?: BuildConfig.ROBOT_BASE_URL}")
+                Text("Last status: ${formatTimestamp(state.lastStatusAt)}")
+                Text("Last telemetry: ${formatTimestamp(state.lastTelemetryAt)}")
+                Text("Log export: ${state.logExportResult ?: "not exported"}")
+
+                Button(onClick = { viewModel.exportLogs(context) }) {
+                    Text("Export logs")
+                }
+
+                Text("Recent logs")
+                val recent = state.logs.takeLast(8)
+                if (recent.isEmpty()) {
+                    Text("No logs yet")
+                } else {
+                    recent.forEach { line ->
+                        Text(line, maxLines = 2, overflow = TextOverflow.Ellipsis)
+                    }
+                }
+
+                Button(onClick = { viewModel.toggleDebugPanel() }) {
+                    Text(if (state.debugPanelVisible) "Hide debug panel" else "Show debug panel")
+                }
+                if (state.debugPanelVisible) {
+                    Text("Debug panel")
+                    Text("Last intent: ${state.lastIntentSent ?: "unknown"}")
+                    Text("Last intent result: ${state.lastIntentResult ?: "unknown"}")
+                    Text("Last remote_event: ${state.lastRemoteEvent ?: "unknown"}")
+                    Text("Last status ts: ${formatTimestamp(state.lastStatusAt)}")
+                    Text("Last telemetry ts: ${formatTimestamp(state.lastTelemetryAt)}")
+                }
             }
         }
 
         Card {
             Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                Text("Quick indicators", style = MaterialTheme.typography.titleMedium)
-                val llm = state.telemetry?.last_llm_response ?: "UNAVAILABLE"
-                val tts = state.telemetry?.last_tts_text ?: "UNAVAILABLE"
-                val ttsStatus = state.telemetry?.last_tts_status ?: "UNAVAILABLE"
-                val det = state.telemetry?.vision_last_detection
-                Text("Last LLM response: ${confidenceLabel(llm, state.telemetry?.last_llm_ts)}")
-                Text("Last TTS: ${confidenceLabel(tts, state.telemetry?.last_tts_ts)}")
-                Text("TTS status: $ttsStatus")
-                if (det == null) {
-                    Text("Last detection: UNAVAILABLE")
-                } else {
-                    Text("Last detection: ${det.label ?: "UNAVAILABLE"} conf=${det.confidence ?: "?"}")
-                }
+                Text("Known limitations", style = MaterialTheme.typography.titleMedium)
+                Text("- No auto-retry for intents")
+                Text("- Telemetry may be stale or missing fields")
+                Text("- Streaming depends on backend-provided URL and format")
             }
         }
         Spacer(modifier = Modifier.height(12.dp))
@@ -292,20 +327,12 @@ private fun ControlScreen(
 ) {
     val state by viewModel.state.collectAsStateWithLifecycle()
     val intentsEnabled = state.appStatus == AppStatus.ONLINE_IDLE
+    val stopEnabled = state.appStatus == AppStatus.ONLINE_EXECUTING_TASK || state.appStatus == AppStatus.ONLINE_BUSY
     val sessionActive = (state.telemetry?.remote_session_active == true) || (state.status?.remote_session_active == true)
-    val stopEnabled = sessionActive
-    val lastIntentAge = state.lastIntentAt?.let { System.currentTimeMillis() - it }
-    val commandRecent = lastIntentAge != null && lastIntentAge < 5_000
-    val lastIntentLabel = state.lastIntentSent ?: "UNAVAILABLE"
-    val hasFailure = state.connection is ConnectionStatus.Error || !sessionActive ||
-        state.lastIntentResult?.startsWith("rejected") == true ||
-        state.lastIntentResult?.startsWith("timed_out") == true ||
-        state.lastIntentResult?.startsWith("failed") == true
     var confirmScan by rememberSaveable { mutableStateOf(false) }
     var confirmStop by rememberSaveable { mutableStateOf(false) }
     var confirmStartForward by rememberSaveable { mutableStateOf(false) }
     var actionBlockedReason by rememberSaveable { mutableStateOf<String?>(null) }
-    var customMessage by rememberSaveable { mutableStateOf("") }
 
     Column(
         modifier = modifier
@@ -335,8 +362,6 @@ private fun ControlScreen(
                 Text("Blocking: ${state.blockingReason ?: "none"}")
                 Button(
                     onClick = {
-                        val blocked = if (intentsEnabled) null else state.blockingReason ?: "invalid_state"
-                        viewModel.logUiAction("start_scan_observe_stop", intentsEnabled, blocked)
                         if (intentsEnabled) {
                             confirmScan = true
                         } else {
@@ -349,9 +374,6 @@ private fun ControlScreen(
                 }
                 Button(
                     onClick = {
-                        val allowed = intentsEnabled && state.task.phase == TaskPhase.OBSERVE
-                        val blocked = if (allowed) null else state.blockingReason ?: "invalid_state"
-                        viewModel.logUiAction("mark_observe", allowed, blocked)
                         if (intentsEnabled && state.task.phase == TaskPhase.OBSERVE) {
                             viewModel.markObservation()
                         } else {
@@ -364,9 +386,6 @@ private fun ControlScreen(
                 }
                 Button(
                     onClick = {
-                        val allowed = stopEnabled && state.task.type != TaskType.NONE
-                        val blocked = if (allowed) null else state.blockingReason ?: "invalid_state"
-                        viewModel.logUiAction("stop_task", allowed, blocked)
                         if (stopEnabled && state.task.type != TaskType.NONE) {
                             confirmStop = true
                         } else {
@@ -379,9 +398,6 @@ private fun ControlScreen(
                 }
                 Button(
                     onClick = {
-                        val allowed = !state.intentInFlight && state.task.type != TaskType.NONE
-                        val blocked = if (allowed) null else state.blockingReason ?: "invalid_state"
-                        viewModel.logUiAction("clear_task", allowed, blocked)
                         if (!state.intentInFlight && state.task.type != TaskType.NONE) {
                             viewModel.clearTask()
                         } else {
@@ -396,141 +412,22 @@ private fun ControlScreen(
         }
 
         Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
-                Text("Motion Control", style = MaterialTheme.typography.titleMedium)
-                Text("Controls require an active remote session")
-                Button(
-                    onClick = {
-                        viewModel.logUiAction("stop", stopEnabled, if (stopEnabled) null else state.blockingReason)
-                        if (stopEnabled) {
-                            confirmStop = true
-                        } else {
-                            actionBlockedReason = state.blockingReason ?: "invalid_state"
-                        }
-                    },
-                    enabled = stopEnabled,
-                    modifier = Modifier.fillMaxWidth().height(56.dp),
-                    colors = androidx.compose.material3.ButtonDefaults.buttonColors(
-                        containerColor = MaterialTheme.colorScheme.error,
-                        contentColor = MaterialTheme.colorScheme.onError,
-                    )
-                ) { Text("STOP") }
-
-                Row(modifier = Modifier.fillMaxSize(), horizontalArrangement = Arrangement.Center) {
-                    Button(
-                        onClick = {
-                            viewModel.logUiAction("start_forward", intentsEnabled, if (intentsEnabled) null else state.blockingReason)
-                            if (intentsEnabled) {
-                                confirmStartForward = true
-                            } else {
-                                actionBlockedReason = state.blockingReason ?: "invalid_state"
-                            }
-                        },
-                        enabled = intentsEnabled,
-                    ) {
-                        Text("Forward")
-                    }
-                }
-                Row(horizontalArrangement = Arrangement.SpaceBetween) {
-                    Button(
-                        onClick = {
-                            viewModel.logUiAction("rotate_left", intentsEnabled, if (intentsEnabled) null else state.blockingReason)
-                            viewModel.sendIntent("rotate_left")
-                        },
-                        enabled = intentsEnabled,
-                    ) { Text("Left") }
-                    Button(
-                        onClick = {
-                            viewModel.logUiAction("rotate_right", intentsEnabled, if (intentsEnabled) null else state.blockingReason)
-                            viewModel.sendIntent("rotate_right")
-                        },
-                        enabled = intentsEnabled,
-                    ) { Text("Right") }
-                }
-                Row(modifier = Modifier.fillMaxSize(), horizontalArrangement = Arrangement.Center) {
-                    Button(
-                        onClick = {
-                            viewModel.logUiAction("move_backward", intentsEnabled, if (intentsEnabled) null else state.blockingReason)
-                            viewModel.sendIntent("move_backward")
-                        },
-                        enabled = intentsEnabled,
-                    ) { Text("Backward") }
-                }
-                Row(modifier = Modifier.fillMaxSize(), horizontalArrangement = Arrangement.Center) {
-                    Button(
-                        onClick = {
-                            viewModel.logUiAction("scan", intentsEnabled, if (intentsEnabled) null else state.blockingReason)
-                            if (intentsEnabled) {
-                                confirmScan = true
-                            } else {
-                                actionBlockedReason = state.blockingReason ?: "invalid_state"
-                            }
-                        },
-                        enabled = intentsEnabled,
-                    ) { Text("Scan") }
-                }
-
+            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
+                Text("Intent", style = MaterialTheme.typography.titleMedium)
                 if (!intentsEnabled) {
-                    Text("Controls disabled: ${state.blockingReason ?: "invalid_state"}")
-                }
-                if (!stopEnabled) {
-                    Text("Stop disabled: ${state.blockingReason ?: "invalid_state"}")
-                }
-                if (commandRecent) {
-                    Text("Command sent: $lastIntentLabel @ ${formatTimestamp(state.lastIntentAt)}")
-                } else {
-                    Text("Last command: $lastIntentLabel")
-                    Text("Last result: ${state.lastIntentResult ?: "UNAVAILABLE"}")
-                }
-            }
-        }
-
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
-                Text("Assistant Control", style = MaterialTheme.typography.titleMedium)
-                Button(onClick = {
-                    viewModel.logUiAction("invoke_assistant", intentsEnabled, if (intentsEnabled) null else state.blockingReason)
-                    viewModel.sendIntent("invoke_assistant")
-                }, enabled = intentsEnabled) {
-                    Text("Invoke Assistant")
-                }
-                OutlinedTextField(
-                    value = customMessage,
-                    onValueChange = { customMessage = it },
-                    label = { Text("Custom message") },
-                    singleLine = false,
-                    modifier = Modifier.fillMaxWidth(),
-                )
-                Button(onClick = {
-                    viewModel.logUiAction("assistant_text", intentsEnabled, if (intentsEnabled) null else state.blockingReason)
-                    viewModel.sendIntent("assistant_text", mapOf("text" to customMessage.trim()))
-                    customMessage = ""
-                }, enabled = intentsEnabled && customMessage.isNotBlank()) {
-                    Text("Send to Assistant")
-                }
-            }
-        }
-
-        if (hasFailure) {
-            Card {
-                Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                    Text("Failure surface", style = MaterialTheme.typography.titleMedium)
-                    if (state.connection is ConnectionStatus.Error) {
-                        Text("Network failure: ${(state.connection as ConnectionStatus.Error).message}")
-                    }
-                    if (!sessionActive) {
-                        Text("Session loss: remote session inactive")
-                    }
-                    if (state.lastIntentResult?.startsWith("rejected") == true) {
-                        Text("Intent rejected: ${state.lastIntentResult}")
-                    }
-                    if (state.lastIntentResult?.startsWith("timed_out") == true) {
-                        Text("Intent timeout: ${state.lastIntentResult}")
-                    }
-                    if (state.lastIntentResult?.startsWith("failed") == true) {
-                        Text("Intent failure: ${state.lastIntentResult}")
-                    }
+                    Text("Intents disabled: offline, no remote session, or busy")
                 }
+                Button(onClick = { viewModel.sendIntent("enable_vision") }, enabled = intentsEnabled) { Text("Enable vision") }
+                Button(onClick = { viewModel.sendIntent("disable_vision") }, enabled = intentsEnabled) { Text("Disable vision") }
+                Button(onClick = { viewModel.sendIntent("enable_stream") }, enabled = intentsEnabled) { Text("Enable stream") }
+                Button(onClick = { viewModel.sendIntent("disable_stream") }, enabled = intentsEnabled) { Text("Disable stream") }
+                HorizontalDivider()
+                Button(onClick = { confirmScan = true }, enabled = intentsEnabled) { Text("Scan") }
+                Button(onClick = { confirmStop = true }, enabled = intentsEnabled) { Text("Stop") }
+                Button(onClick = { viewModel.sendIntent("rotate_left") }, enabled = intentsEnabled) { Text("Rotate left") }
+                Button(onClick = { viewModel.sendIntent("rotate_right") }, enabled = intentsEnabled) { Text("Rotate right") }
+                Button(onClick = { confirmStartForward = true }, enabled = intentsEnabled) { Text("Start forward") }
+                Text("Last intent result: ${state.lastIntentResult ?: ""}")
             }
         }
         Spacer(modifier = Modifier.height(12.dp))
@@ -555,7 +452,6 @@ private fun ControlScreen(
             confirmButton = {
                 Button(onClick = {
                     confirmScan = false
-                    viewModel.logUiAction("confirm_scan", true, null)
                     viewModel.startScanObserveTask()
                 }) { Text("Confirm") }
             },
@@ -573,7 +469,6 @@ private fun ControlScreen(
             confirmButton = {
                 Button(onClick = {
                     confirmStop = false
-                    viewModel.logUiAction("confirm_stop", true, null)
                     viewModel.stopTask()
                 }) { Text("Confirm") }
             },
@@ -591,7 +486,6 @@ private fun ControlScreen(
             confirmButton = {
                 Button(onClick = {
                     confirmStartForward = false
-                    viewModel.logUiAction("confirm_start_forward", true, null)
                     viewModel.sendIntent("start")
                 }) { Text("Confirm") }
             },
@@ -606,6 +500,7 @@ private fun ControlScreen(
 private fun VisionScreen(
     modifier: Modifier,
     viewModel: AppViewModel,
+    onOpenStatus: () -> Unit,
     onOpenSettings: () -> Unit,
 ) {
     val state by viewModel.state.collectAsStateWithLifecycle()
@@ -613,13 +508,6 @@ private fun VisionScreen(
     val intentsEnabled = state.appStatus == AppStatus.ONLINE_IDLE && sessionActive
     val streamUrl = resolveStreamUrl(state.telemetry?.stream_url ?: state.status?.stream_url, state.settings)
     val visionMode = state.telemetry?.vision_mode ?: state.status?.vision_mode
-    val visionModeLabel = when (visionMode) {
-        "off" -> "OFF"
-        "on" -> "ON_NO_STREAM"
-        "on_with_stream" -> "ON_WITH_STREAM"
-        null -> "UNKNOWN"
-        else -> visionMode.uppercase()
-    }
     val canStream = intentsEnabled && visionMode == "on_with_stream" && streamUrl.isNotBlank()
     var isStreaming by rememberSaveable { mutableStateOf(false) }
     var streamError by rememberSaveable { mutableStateOf<String?>(null) }
@@ -643,6 +531,7 @@ private fun VisionScreen(
                     Text("Vision offline", style = MaterialTheme.typography.titleMedium)
                     Text("Reason: ${state.blockingReason ?: "session inactive"}")
                     Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
+                        TextButton(onClick = onOpenStatus) { Text("View status") }
                         TextButton(onClick = onOpenSettings) { Text("Open settings") }
                     }
                 }
@@ -651,36 +540,15 @@ private fun VisionScreen(
 
         Card {
             Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                Text("Vision mode: $visionModeLabel", style = MaterialTheme.typography.titleMedium)
-                Text("Stream URL: ${if (streamUrl.isBlank()) "missing" else "available"}")
-                Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
-                    Button(onClick = {
-                        viewModel.logUiAction("enable_vision", intentsEnabled, if (intentsEnabled) null else state.blockingReason)
-                        viewModel.sendIntent("enable_vision")
-                    }, enabled = intentsEnabled) { Text("Vision ON") }
-                    Button(onClick = {
-                        viewModel.logUiAction("disable_vision", intentsEnabled, if (intentsEnabled) null else state.blockingReason)
-                        viewModel.sendIntent("disable_vision")
-                    }, enabled = intentsEnabled) { Text("Vision OFF") }
-                }
-                Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
-                    Button(onClick = {
-                        viewModel.logUiAction("enable_stream", intentsEnabled, if (intentsEnabled) null else state.blockingReason)
-                        viewModel.sendIntent("enable_stream")
-                    }, enabled = intentsEnabled) { Text("Stream ON") }
-                    Button(onClick = {
-                        viewModel.logUiAction("disable_stream", intentsEnabled, if (intentsEnabled) null else state.blockingReason)
-                        viewModel.sendIntent("disable_stream")
-                    }, enabled = intentsEnabled) { Text("Stream OFF") }
-                }
-
-                HorizontalDivider()
                 Text("Streaming", style = MaterialTheme.typography.titleMedium)
+                Text("Vision mode: ${visionMode ?: "unknown"}")
                 if (streamUrl.isBlank()) {
                     Text("No stream URL provided by backend")
-                    Text("Streaming disabled: stream URL missing")
+                    Text("Streaming is disabled until a valid URL is present")
+                    Text("No auto-connect is performed")
                 } else if (!intentsEnabled) {
                     Text("Streaming disabled: ${state.blockingReason ?: "invalid_state"}")
+                    Text("No auto-connect is performed")
                 } else if (visionMode != "on_with_stream") {
                     Text("Streaming disabled: vision mode is not on_with_stream")
                     Text("Enable streaming via intent first")
@@ -692,21 +560,16 @@ private fun VisionScreen(
                         Button(onClick = {
                             streamError = null
                             isStreaming = true
-                            viewModel.logUiAction("vision_stream_start", canStream, if (canStream) null else state.blockingReason)
                         }, enabled = canStream) {
                             Text("Start stream")
                         }
                     } else {
-                        Button(onClick = {
-                            isStreaming = false
-                            viewModel.logUiAction("vision_stream_stop", true, null)
-                        }) { Text("Stop stream") }
+                        Button(onClick = { isStreaming = false }) { Text("Stop stream") }
                         MjpegStreamingView(
                             url = streamUrl,
                             onError = { msg ->
                                 streamError = msg
                                 isStreaming = false
-                                viewModel.logUiAction("vision_stream_error", false, msg)
                             },
                             onStop = { isStreaming = false },
                         )
@@ -724,7 +587,6 @@ private fun VisionScreen(
                     if (det == null) {
                         Text("No detection available")
                     } else {
-                        Text("Latest detection", style = MaterialTheme.typography.titleMedium)
                         Text("Label: ${confidenceLabel(det.label, state.lastTelemetryAt)}")
                         Text("Confidence: ${confidenceLabel(det.confidence, state.lastTelemetryAt)}")
                         Text("BBox: ${confidenceLabel(det.bbox?.joinToString(prefix = "[", postfix = "]"), state.lastTelemetryAt)}")
@@ -736,19 +598,9 @@ private fun VisionScreen(
 
                 HorizontalDivider()
                 Text("Capture", style = MaterialTheme.typography.titleMedium)
-                Button(
-                    onClick = {
-                        viewModel.logUiAction("capture_frame", intentsEnabled, if (intentsEnabled) null else state.blockingReason)
-                        viewModel.sendIntent("capture_frame")
-                    },
-                    enabled = intentsEnabled
-                ) {
+                Button(onClick = { viewModel.sendIntent("capture_frame") }, enabled = intentsEnabled) {
                     Text("Capture frame")
                 }
-                if (state.lastIntentSent == "capture_frame") {
-                    Text("Capture status: ${state.lastIntentResult ?: "pending"}")
-                    Text("Capture ts: ${formatTimestamp(state.lastIntentAt)}")
-                }
 
                 HorizontalDivider()
                 Text("Detection history", style = MaterialTheme.typography.titleMedium)
@@ -756,14 +608,11 @@ private fun VisionScreen(
                 if (history.isEmpty()) {
                     Text("No detections yet")
                 } else {
-                    val recent = history.takeLast(10).reversed()
-                    recent.forEachIndexed { index, item ->
-                        val style = if (index == 0) MaterialTheme.typography.titleSmall else MaterialTheme.typography.bodySmall
+                    history.takeLast(10).reversed().forEach { item ->
                         Text(
                             "${item.label ?: "unknown"} " +
                                 "conf=${item.confidence ?: "?"} " +
-                                "bbox=${item.bbox?.joinToString(prefix = "[", postfix = "]") ?: "[]"}",
-                            style = style,
+                                "bbox=${item.bbox?.joinToString(prefix = "[", postfix = "]") ?: "[]"}"
                         )
                     }
                 }
@@ -773,265 +622,17 @@ private fun VisionScreen(
     }
 }
 
-@Composable
-private fun SensorsScreen(
-    modifier: Modifier,
-    viewModel: AppViewModel,
-) {
-    val state by viewModel.state.collectAsStateWithLifecycle()
-    val sessionActive = (state.telemetry?.remote_session_active == true) || (state.status?.remote_session_active == true)
-
-    Column(
-        modifier = modifier
-            .verticalScroll(rememberScrollState())
-            .padding(16.dp),
-        verticalArrangement = Arrangement.spacedBy(12.dp)
-    ) {
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                Text("Robot state", style = MaterialTheme.typography.titleMedium)
-                Text("Session: ${triState(sessionActive)}")
-                Text("Status mode: ${confidenceLabel(state.status?.mode, state.lastStatusAt)}")
-                Text("Status display: ${confidenceLabel(state.status?.display_text, state.lastStatusAt)}")
-                Text("Telemetry mode: ${confidenceLabel(state.telemetry?.mode, state.lastTelemetryAt)}")
-                Text("Telemetry display: ${confidenceLabel(state.telemetry?.display_text, state.lastTelemetryAt)}")
-            }
-        }
-
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                Text("Sensor health", style = MaterialTheme.typography.titleMedium)
-                Text("Sensor timestamp: ${confidenceLabel(state.telemetry?.sensor_ts, state.lastTelemetryAt)}")
-                Text("Buffer size: ${state.telemetry?.sensor_buffer ?: "unknown"}")
-                Text("Safety stop: ${confidenceLabel(state.telemetry?.safety_stop, state.lastTelemetryAt)}")
-                Text("Blocking: ${state.blockingReason ?: "none"}")
-            }
-        }
-
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                Text("Motor feedback", style = MaterialTheme.typography.titleMedium)
-                val motor = state.telemetry?.motor
-                Text("Motor enabled: ${confidenceLabel(state.telemetry?.motor_enabled, state.lastTelemetryAt)}")
-                Text("Left motor: ${confidenceLabel(motor?.left, state.lastTelemetryAt)}")
-                Text("Right motor: ${confidenceLabel(motor?.right, state.lastTelemetryAt)}")
-                Text("Intent busy: ${triState(state.intentInFlight)}")
-                Text("Last intent: ${state.lastIntentSent ?: "unknown"}")
-                Text("Last intent result: ${state.lastIntentResult ?: "unknown"}")
-            }
-        }
-
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                Text("Sensor values", style = MaterialTheme.typography.titleMedium)
-                val sensor = state.telemetry?.sensor
-                Text("Is safe: ${confidenceLabel(sensor?.is_safe, state.telemetry?.sensor_ts)}")
-                Text("Obstacle: ${confidenceLabel(sensor?.obstacle, state.telemetry?.sensor_ts)}")
-                Text("Warning: ${confidenceLabel(sensor?.warning, state.telemetry?.sensor_ts)}")
-                Text("Raw telemetry: ${state.telemetry?.toString() ?: "telemetry_missing"}")
-            }
-        }
-        Spacer(modifier = Modifier.height(12.dp))
-    }
-}
-
-@Composable
-private fun LogsScreen(
-    modifier: Modifier,
-    viewModel: AppViewModel,
-) {
-    val state by viewModel.state.collectAsStateWithLifecycle()
-    val context = LocalContext.current
-    var showUi by rememberSaveable { mutableStateOf(true) }
-    var showNetwork by rememberSaveable { mutableStateOf(true) }
-    var showIntent by rememberSaveable { mutableStateOf(true) }
-    var showState by rememberSaveable { mutableStateOf(true) }
-    val backendServices = listOf(
-        BackendLogService.APP,
-        BackendLogService.REMOTE_INTERFACE,
-        BackendLogService.ORCHESTRATOR,
-        BackendLogService.UART,
-        BackendLogService.VISION,
-        BackendLogService.LLM_TTS,
-    )
-    var selectedServices by remember {
-        mutableStateOf(backendServices.associateWith { true })
-    }
-    val scrollState = rememberScrollState()
-
-    val filtered = state.logs.filter { entry ->
-        when (entry.category) {
-            LogCategory.UI -> showUi
-            LogCategory.NETWORK -> showNetwork
-            LogCategory.INTENT -> showIntent
-            LogCategory.STATE -> showState
-        }
-    }
-
-    val lastCritical = filtered.lastOrNull { entry ->
-        when (entry.category) {
-            LogCategory.INTENT -> {
-                val result = entry.data["result"]?.toString() ?: ""
-                result.contains("rejected") || result.contains("failed") || result.contains("timed_out")
-            }
-            LogCategory.NETWORK -> entry.event.contains("error")
-            LogCategory.STATE -> entry.event.contains("error")
-            LogCategory.UI -> false
-        }
-    }
-
-    val byCategory = filtered.groupBy { it.category }
-
-    LaunchedEffect(filtered.size) {
-        scrollState.animateScrollTo(scrollState.maxValue)
-    }
-
-    Column(
-        modifier = modifier
-            .verticalScroll(scrollState)
-            .padding(16.dp),
-        verticalArrangement = Arrangement.spacedBy(12.dp)
-    ) {
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
-                Text("Backend logs", style = MaterialTheme.typography.titleMedium)
-                Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
-                    Text("Auto refresh")
-                    Switch(
-                        checked = state.logAutoRefresh,
-                        onCheckedChange = { viewModel.setLogAutoRefresh(it) }
-                    )
-                    Text("Lines: ${state.logLinesLimit}")
-                }
-                Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
-                    Button(onClick = { viewModel.refreshBackendLogs() }) { Text("Refresh now") }
-                    Text("Updated: ${formatTimestamp(state.backendLogsUpdatedAt)}")
-                }
-                backendServices.forEach { service ->
-                    Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
-                        Text(service.label)
-                        Switch(
-                            checked = selectedServices[service] == true,
-                            onCheckedChange = { enabled ->
-                                selectedServices = selectedServices.toMutableMap().also { it[service] = enabled }
-                            }
-                        )
-                    }
-                }
-            }
-        }
-
-        backendServices.filter { selectedServices[it] == true }.forEach { service ->
-            val snapshot = state.backendLogs[service]
-            val appLogLines = filtered.takeLast(200).map { it.toDisplayLine() }
-            Card {
-                Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                    Text(service.label, style = MaterialTheme.typography.titleMedium)
-                    if (service == BackendLogService.APP) {
-                        if (appLogLines.isEmpty()) {
-                            Text("No app logs")
-                        } else {
-                            appLogLines.forEach { line ->
-                                Text(line, style = MaterialTheme.typography.bodySmall)
-                            }
-                        }
-                    } else if (snapshot == null) {
-                        Text("No data yet")
-                    } else {
-                        if (!snapshot.error.isNullOrBlank()) {
-                            Text("Error: ${snapshot.error}")
-                        }
-                        if (snapshot.lines.isEmpty()) {
-                            Text("No log lines")
-                        } else {
-                            snapshot.lines.takeLast(200).forEach { line ->
-                                Text(line, style = MaterialTheme.typography.bodySmall)
-                            }
-                        }
-                    }
-                }
-            }
-        }
-
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
-                Text("Log controls", style = MaterialTheme.typography.titleMedium)
-                Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
-                    Text("UI (button actions)")
-                    Switch(checked = showUi, onCheckedChange = { showUi = it })
-                    Text("Network (HTTP)")
-                    Switch(checked = showNetwork, onCheckedChange = { showNetwork = it })
-                }
-                Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
-                    Text("Intent (sent/result)")
-                    Switch(checked = showIntent, onCheckedChange = { showIntent = it })
-                    Text("State (app)")
-                    Switch(checked = showState, onCheckedChange = { showState = it })
-                }
-                Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
-                    Button(onClick = { viewModel.exportLogs(context) }) {
-                        Text("Export JSONL")
-                    }
-                    TextButton(onClick = { viewModel.clearLogs() }) {
-                        Text("Clear logs")
-                    }
-                }
-                Text("Log export: ${state.logExportResult ?: "not exported"}")
-            }
-        }
-
-        if (lastCritical != null) {
-            Card {
-                Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                    Text("Last critical log", style = MaterialTheme.typography.titleMedium)
-                    Text(lastCritical.toDisplayLine())
-                }
-            }
-        }
-
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                Text("Logs", style = MaterialTheme.typography.titleMedium)
-                Text("Showing ${filtered.size} of ${state.logs.size}")
-                if (filtered.isEmpty()) {
-                    Text("No logs match current filters")
-                } else {
-                    val order = listOf(LogCategory.INTENT, LogCategory.UI, LogCategory.NETWORK, LogCategory.STATE)
-                    order.forEach { category ->
-                        val entries = byCategory[category].orEmpty()
-                        if (entries.isNotEmpty()) {
-                            Text(category.name, style = MaterialTheme.typography.titleSmall)
-                            entries.takeLast(100).forEach { entry ->
-                                val style = if (entry.category == LogCategory.INTENT) {
-                                    MaterialTheme.typography.bodyMedium
-                                } else {
-                                    MaterialTheme.typography.bodySmall
-                                }
-                                Text(entry.toDisplayLine(), maxLines = 3, overflow = TextOverflow.Ellipsis, style = style)
-                            }
-                        }
-                    }
-                }
-            }
-        }
-        Spacer(modifier = Modifier.height(12.dp))
-    }
-}
-
 @Composable
 private fun SettingsScreen(
     modifier: Modifier,
     viewModel: AppViewModel,
 ) {
     val state by viewModel.state.collectAsStateWithLifecycle()
-    val context = LocalContext.current
     var ip by rememberSaveable { mutableStateOf(state.settings?.robotIp ?: "") }
     var port by rememberSaveable { mutableStateOf(state.settings?.robotPort?.toString() ?: "") }
     var pollMs by rememberSaveable { mutableStateOf(state.settings?.pollIntervalMs?.toString() ?: "1000") }
     var debugEnabled by rememberSaveable { mutableStateOf(state.settings?.debugEnabled ?: false) }
     var errorMessage by rememberSaveable { mutableStateOf<String?>(null) }
-    var showDiagnostics by rememberSaveable { mutableStateOf(false) }
-    var showLimitations by rememberSaveable { mutableStateOf(false) }
 
     LaunchedEffect(state.settings) {
         val settings = state.settings
@@ -1051,8 +652,7 @@ private fun SettingsScreen(
     ) {
         Card {
             Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
-                Text("Connection", style = MaterialTheme.typography.titleMedium)
-                Text("Base URL (read-only): ${state.settings?.baseUrl() ?: BuildConfig.ROBOT_BASE_URL}")
+                Text("Connection settings", style = MaterialTheme.typography.titleMedium)
                 OutlinedTextField(
                     value = ip,
                     onValueChange = { ip = it.trim() },
@@ -1071,6 +671,14 @@ private fun SettingsScreen(
                     label = { Text("Poll interval (ms)") },
                     singleLine = true,
                 )
+                Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
+                    Text("Debug panel")
+                    Switch(checked = debugEnabled, onCheckedChange = { debugEnabled = it })
+                }
+                Text(
+                    "Current base URL: ${state.settings?.baseUrl() ?: BuildConfig.ROBOT_BASE_URL}",
+                    style = MaterialTheme.typography.bodySmall,
+                )
                 if (errorMessage != null) {
                     Text(errorMessage!!, color = MaterialTheme.colorScheme.error)
                 }
@@ -1099,55 +707,6 @@ private fun SettingsScreen(
                 }
             }
         }
-
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
-                Text("Diagnostics", style = MaterialTheme.typography.titleMedium)
-                Text("App version: ${BuildConfig.VERSION_NAME}")
-                Text("Log export: ${state.logExportResult ?: "not exported"}")
-                Button(onClick = { viewModel.exportLogs(context) }) {
-                    Text("Export logs")
-                }
-                TextButton(onClick = { showDiagnostics = !showDiagnostics }) {
-                    Text(if (showDiagnostics) "Hide runtime details" else "Show runtime details")
-                }
-                if (showDiagnostics) {
-                    Text("Robot base URL: ${state.settings?.baseUrl() ?: BuildConfig.ROBOT_BASE_URL}")
-                    Text("Last status: ${formatTimestamp(state.lastStatusAt)}")
-                    Text("Last telemetry: ${formatTimestamp(state.lastTelemetryAt)}")
-                    Text("Last intent: ${state.lastIntentSent ?: "unknown"}")
-                    Text("Last intent result: ${state.lastIntentResult ?: "unknown"}")
-                }
-            }
-        }
-
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
-                TextButton(onClick = { showLimitations = !showLimitations }) {
-                    Text(if (showLimitations) "Hide known limitations" else "Show known limitations")
-                }
-                if (showLimitations) {
-                    Text("Known limitations", style = MaterialTheme.typography.titleMedium)
-                    Text("- No auto-retry for intents")
-                    Text("- Telemetry may be stale or missing fields")
-                    Text("- Streaming depends on backend-provided URL and format")
-                }
-            }
-        }
-
-        Card {
-            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
-                Text("Advanced", style = MaterialTheme.typography.titleMedium)
-                Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
-                    Text("Debug panel")
-                    Switch(checked = debugEnabled, onCheckedChange = { debugEnabled = it })
-                }
-                Text(
-                    "Enables extra diagnostics on app screens.",
-                    style = MaterialTheme.typography.bodySmall,
-                )
-            }
-        }
         Spacer(modifier = Modifier.height(12.dp))
     }
 }
@@ -1237,21 +796,15 @@ private fun MjpegStreamingView(
 }
 
 private fun triState(value: Boolean?): String = when (value) {
-    null -> "UNAVAILABLE"
+    null -> "unknown"
     true -> "true"
     false -> "false"
 }
 
-private fun connectionLabel(status: ConnectionStatus): String = when (status) {
-    ConnectionStatus.Online -> "ONLINE"
-    ConnectionStatus.Offline -> "OFFLINE"
-    is ConnectionStatus.Error -> "ERROR"
-}
-
 private fun confidenceLabel(value: Any?, lastTs: Long?): String {
     val now = System.currentTimeMillis()
-    val freshness = if (lastTs == null) "UNAVAILABLE" else if (now - lastTs > 5_000) "STALE" else "LIVE"
-    val v = value?.toString() ?: "UNAVAILABLE"
+    val freshness = if (lastTs == null) "UNKNOWN" else if (now - lastTs > 5_000) "STALE" else "LIVE"
+    val v = value?.toString() ?: "unknown"
     return "$v ($freshness)"
 }
 
@@ -1275,7 +828,7 @@ private fun parseBoundary(contentType: String?): String {
 }
 
 private fun formatTimestamp(ts: Long?): String {
-    if (ts == null) return "UNAVAILABLE"
+    if (ts == null) return "unknown"
     val formatter = DateTimeFormatter.ofPattern("HH:mm:ss")
     return Instant.ofEpochMilli(ts).atZone(ZoneId.systemDefault()).format(formatter)
 }
diff --git a/mobile_app/app/src/main/java/com/smartcar/supervision/ui/theme/Theme.kt b/mobile_app/app/src/main/java/com/smartcar/supervision/ui/theme/Theme.kt
deleted file mode 100644
index 89e2f3e..0000000
--- a/mobile_app/app/src/main/java/com/smartcar/supervision/ui/theme/Theme.kt
+++ /dev/null
@@ -1,31 +0,0 @@
-package com.smartcar.supervision.ui.theme
-
-import android.os.Build
-import androidx.compose.foundation.isSystemInDarkTheme
-import androidx.compose.material3.MaterialTheme
-import androidx.compose.material3.darkColorScheme
-import androidx.compose.material3.dynamicDarkColorScheme
-import androidx.compose.material3.dynamicLightColorScheme
-import androidx.compose.material3.lightColorScheme
-import androidx.compose.runtime.Composable
-import androidx.compose.ui.platform.LocalContext
-
-@Composable
-fun SupervisionTheme(
-    darkTheme: Boolean = isSystemInDarkTheme(),
-    content: @Composable () -> Unit,
-) {
-    val colorScheme = when {
-        Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
-            val context = LocalContext.current
-            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
-        }
-        darkTheme -> darkColorScheme()
-        else -> lightColorScheme()
-    }
-
-    MaterialTheme(
-        colorScheme = colorScheme,
-        content = content,
-    )
-}
diff --git a/src/core/orchestrator.py b/src/core/orchestrator.py
index c88f0d1..54ce998 100644
--- a/src/core/orchestrator.py
+++ b/src/core/orchestrator.py
@@ -1,869 +1,688 @@
-"""Phase-driven orchestrator: single source of truth state machine.
-
-LED COLOR SCHEME (granular feedback):
-    idle                - Dim cyan breathing (waiting for wakeword)
-    wakeword_detected   - Bright GREEN flash (acknowledged!)
-    listening           - Bright BLUE sweep (capturing audio)
-    transcribing        - PURPLE pulse (STT processing)
-    thinking            - PINK pulse (LLM processing)
-    tts_processing      - ORANGE pulse (generating speech)
-    speaking            - Dark GREEN chase (playing audio)
-    error               - RED blink (system error)
-"""
-from __future__ import annotations
-
-import json
-import random
-import time
-from enum import Enum, auto
-from pathlib import Path
-from typing import Any, Dict, Optional
-
-import zmq
-
-from src.core.config_loader import load_config
-from src.core.ipc import (
-    TOPIC_CMD_LISTEN_START,
-    TOPIC_CMD_LISTEN_STOP,
-    TOPIC_CMD_PAUSE_VISION,
-    TOPIC_CMD_VISN_CAPTURE,
-    TOPIC_CMD_VISION_MODE,
-    TOPIC_DISPLAY_STATE,
-    TOPIC_DISPLAY_TEXT,
-    TOPIC_ESP,
-    TOPIC_HEALTH,
-    TOPIC_LLM_REQ,
-    TOPIC_LLM_RESP,
-    TOPIC_NAV,
-    TOPIC_REMOTE_EVENT,
-    TOPIC_REMOTE_INTENT,
-    TOPIC_REMOTE_SESSION,
-    TOPIC_STT,
-    TOPIC_TTS,
-    TOPIC_VISN,
-    TOPIC_VISN_CAPTURED,
-    TOPIC_VISN_FRAME,
-    TOPIC_WW_DETECTED,
-    make_publisher,
-    make_subscriber,
-    publish_json,
-)
-from src.core.logging_setup import get_logger
-from src.core.world_context import WorldContextAggregator
-
-logger = get_logger("orchestrator", Path("logs"))
-
-
-class Phase(Enum):
-    IDLE = auto()
-    LISTENING = auto()
-    THINKING = auto()
-    SPEAKING = auto()
-    SCANNING = auto()
-    ERROR = auto()
-
-
-class VisionMode(Enum):
-    OFF = "off"
-    ON_NO_STREAM = "on_no_stream"
-    ON_WITH_STREAM = "on_with_stream"
-
-
-class Orchestrator:
-    TRANSITIONS = {
-        (Phase.IDLE, "wakeword"): Phase.LISTENING,
-        (Phase.IDLE, "auto_trigger"): Phase.LISTENING,
-        (Phase.IDLE, "manual_trigger"): Phase.LISTENING,
-        (Phase.IDLE, "manual_think"): Phase.THINKING,
-        (Phase.IDLE, "manual_text"): Phase.THINKING,
-        (Phase.IDLE, "manual_speak"): Phase.SPEAKING,
-        (Phase.IDLE, "scan_start"): Phase.SCANNING,
-        (Phase.LISTENING, "stt_valid"): Phase.THINKING,
-        (Phase.LISTENING, "stt_invalid"): Phase.IDLE,
-        (Phase.LISTENING, "stt_timeout"): Phase.IDLE,
-        (Phase.THINKING, "llm_with_speech"): Phase.SPEAKING,
-        (Phase.THINKING, "llm_no_speech"): Phase.IDLE,
-        (Phase.SPEAKING, "tts_done"): Phase.IDLE,
-        (Phase.SCANNING, "scan_complete"): Phase.IDLE,
-        (Phase.SCANNING, "scan_abort"): Phase.IDLE,
-        (Phase.IDLE, "health_error"): Phase.ERROR,
-        (Phase.LISTENING, "health_error"): Phase.ERROR,
-        (Phase.THINKING, "health_error"): Phase.ERROR,
-        (Phase.SPEAKING, "health_error"): Phase.ERROR,
-        (Phase.SCANNING, "health_error"): Phase.ERROR,
-        (Phase.ERROR, "health_ok"): Phase.IDLE,
-        (Phase.ERROR, "error_timeout"): Phase.IDLE,
-    }
-
-    def __init__(self) -> None:
-        self.config = load_config(Path("config/system.yaml"))
-        self.cmd_pub = make_publisher(self.config, channel="downstream", bind=True)
-        self.events_sub = make_subscriber(self.config, channel="upstream", bind=True)
-        self._world_context = WorldContextAggregator(self.config)
-        self._world_context.start()
-        self._phase = Phase.IDLE
-        self._phase_entered_ts = time.time()
-        self._last_interaction_ts = time.time()
-        self._last_transcript = ""
-        self._last_vision: Optional[Dict[str, Any]] = None
-        self._last_nav_direction = "stopped"
-        self._vision_capture_pending: Optional[str] = None
-        self._vision_capture_requested_ts: Optional[float] = None
-        self._esp_obstacle = False
-        self._esp_min_distance = -1
-        self._obstacle_latched = False
-
-        self._scan_end_ts: Optional[float] = None
-        self._scan_labels: list[str] = []
-        self._capture_labels: Dict[str, list[str]] = {}
-        self._last_scan_summary: Optional[str] = None
-        self._scan_prev_vision_mode: Optional[VisionMode] = None
-
-        self._gas_warning = False
-        self._gas_level: Optional[int] = None
-
-        self._remote_session_active = False
-        self._remote_last_seen = 0.0
-        self._last_led_state = "idle"
-        
-        orch_cfg = self.config.get("orchestrator", {}) or {}
-        self.auto_trigger_enabled = bool(orch_cfg.get("auto_trigger_enabled", True))
-        self.auto_trigger_interval = float(orch_cfg.get("auto_trigger_interval", 60.0))
-        self.scan_duration_s = float(orch_cfg.get("scan_duration_s", 4.0))
-        self.gas_threshold = int(orch_cfg.get("gas_threshold", 800))
-        
-        stt_cfg = self.config.get("stt", {}) or {}
-        self.stt_timeout_s = float(stt_cfg.get("timeout_seconds", 30.0))
-        self.stt_min_confidence = float(stt_cfg.get("min_confidence", 0.3))
-        self.error_recovery_s = 2.0
-
-        remote_cfg = self.config.get("remote_interface", {}) or {}
-        self.remote_session_timeout_s = float(remote_cfg.get("session_timeout_s", 15.0))
-
-        vision_cfg = self.config.get("vision", {}) or {}
-        default_mode = str(vision_cfg.get("default_mode", "off")).lower()
-        self.vision_mode = self._coerce_vision_mode(default_mode)
-
-    def _publish_led_state(self, state: str) -> None:
-        if state != "gas_danger":
-            self._last_led_state = state
-        effective_state = "gas_danger" if self._gas_warning else state
-        publish_json(self.cmd_pub, TOPIC_DISPLAY_STATE, {
-            "state": effective_state,
-            "phase": self._phase.name,
-            "timestamp": int(time.time()),
-            "source": "orchestrator",
-        })
-        logger.debug("LED: %s", effective_state)
-
-    def _publish_display_text(self, text: str) -> None:
-        publish_json(self.cmd_pub, TOPIC_DISPLAY_TEXT, {
-            "text": text,
-            "timestamp": int(time.time()),
-            "source": "orchestrator",
-        })
-
-    @property
-    def phase(self) -> Phase:
-        return self._phase
-
-    def _transition(self, event_type: str) -> bool:
-        key = (self._phase, event_type)
-        next_phase = self.TRANSITIONS.get(key)
-        if next_phase is None:
-            logger.debug("IGNORED: event '%s' illegal in phase %s", event_type, self._phase.name)
-            return False
-        if next_phase == self._phase:
-            return False
-        old_phase = self._phase
-        self._phase = next_phase
-        self._phase_entered_ts = time.time()
-        logger.info("PHASE: %s -> %s (event: %s)", old_phase.name, next_phase.name, event_type)
-        return True
-
-    @staticmethod
-    def _normalize_direction(direction: Optional[str]) -> str:
-        allowed = {"forward", "backward", "left", "right", "stop", "scan"}
-        if not direction:
-            return "stop"
-        value = str(direction).strip().lower()
-        return value if value in allowed else "stop"
-
-    def _enter_listening(self, from_wakeword: bool = False) -> None:
-        self._last_interaction_ts = time.time()
-        if from_wakeword:
-            self._publish_led_state("wakeword_detected")
-            self._publish_display_text("Wakeword detected")
-        else:
-            self._publish_led_state("listening")
-            self._publish_display_text("Listening...")
-        if self.vision_mode != VisionMode.OFF:
-            publish_json(self.cmd_pub, TOPIC_CMD_PAUSE_VISION, {"pause": True, "source": "orchestrator"})
-        publish_json(self.cmd_pub, TOPIC_CMD_LISTEN_START, {"start": True, "source": "orchestrator"})
-
-    def _exit_listening(self, reason: str) -> None:
-        publish_json(self.cmd_pub, TOPIC_CMD_LISTEN_STOP, {"stop": True, "reason": reason, "source": "orchestrator"})
-        if self.vision_mode != VisionMode.OFF:
-            publish_json(self.cmd_pub, TOPIC_CMD_PAUSE_VISION, {"pause": False, "source": "orchestrator"})
-
-    def _enter_thinking(
-        self,
-        text: str,
-        vision: Optional[Dict[str, Any]] = None,
-        *,
-        source: str = "orchestrator",
-        mode: Optional[str] = None,
-    ) -> None:
-        self._publish_led_state("thinking")
-        self._publish_display_text(f"Heard: {text[:120]}")
-        payload: Dict[str, Any] = {"text": text}
-        if vision:
-            payload["vision"] = vision
-        payload["direction"] = self._last_nav_direction
-        payload["world_context"] = self._world_context.get_snapshot()
-        payload["context_note"] = "system_observation_only_last_known_state"
-        payload["source"] = source
-        if mode:
-            payload["mode"] = mode
-        publish_json(self.cmd_pub, TOPIC_LLM_REQ, payload)
-        logger.info("LLM request text: %s", text[:120])
-
-    def _enter_speaking(self, text: str, direction: Optional[str] = None) -> None:
-        self._publish_led_state("tts_processing")
-        self._publish_display_text(f"Saying: {text[:120]}")
-        normalized = self._normalize_direction(direction)
-        if normalized != "stop":
-            if self._esp_obstacle and normalized == "forward":
-                logger.warning("Blocked forward command due to obstacle")
-                publish_json(
-                    self.cmd_pub,
-                    TOPIC_NAV,
-                    {"direction": "stop", "reason": "obstacle", "source": "orchestrator"},
-                )
-                self._last_nav_direction = "stop"
-            else:
-                self._last_nav_direction = normalized
-                publish_json(self.cmd_pub, TOPIC_NAV, {"direction": normalized, "source": "orchestrator"})
-        publish_json(self.cmd_pub, TOPIC_TTS, {"text": text, "source": "orchestrator"})
-
-    def _maybe_speak_status(self, text: str, *, context: str) -> None:
-        if self._phase != Phase.IDLE:
-            logger.info("Status TTS skipped context=%s phase=%s text=%s", context, self._phase.name, text[:120])
-            self._publish_remote_event("tts_skipped", {"reason": "busy", "context": context, "text": text})
-            return
-        if self._transition("manual_speak"):
-            self._enter_speaking(text)
-        else:
-            logger.info("Status TTS skipped context=%s reason=transition_blocked text=%s", context, text[:120])
-            self._publish_remote_event("tts_skipped", {"reason": "transition_blocked", "context": context, "text": text})
-
-    @staticmethod
-    def _summarize_labels(labels: list[str]) -> str:
-        counts: Dict[str, int] = {}
-        for label in labels:
-            label_value = (label or "").strip()
-            if not label_value or label_value == "none":
-                continue
-            counts[label_value] = counts.get(label_value, 0) + 1
-        if not counts:
-            return "no objects detected"
-        parts = []
-        for label_value, count in sorted(counts.items(), key=lambda item: (-item[1], item[0])):
-            if count == 1 or label_value.endswith("s"):
-                parts.append(f"{count} {label_value}")
-            else:
-                parts.append(f"{count} {label_value}s")
-        return ", ".join(parts)
-
-    @staticmethod
-    def _count_labels(labels: list[str]) -> Dict[str, int]:
-        counts: Dict[str, int] = {}
-        for label in labels:
-            label_value = (label or "").strip()
-            if not label_value or label_value == "none":
-                continue
-            counts[label_value] = counts.get(label_value, 0) + 1
-        return counts
-
-    def _start_scan(self, *, source: str) -> bool:
-        if self._phase != Phase.IDLE:
-            logger.warning("scan_start rejected reason=busy phase=%s", self._phase.name)
-            self._publish_remote_event("rejected", {"reason": "busy", "intent": "scan"})
-            return False
-        if not self._transition("scan_start"):
-            logger.warning("scan_start rejected reason=transition_blocked phase=%s", self._phase.name)
-            self._publish_remote_event("rejected", {"reason": "transition_blocked", "intent": "scan"})
-            return False
-        self._scan_end_ts = time.time() + self.scan_duration_s
-        self._scan_labels = []
-        self._scan_prev_vision_mode = self.vision_mode
-        if self.vision_mode == VisionMode.OFF:
-            self._set_vision_mode(VisionMode.ON_NO_STREAM, source="scan")
-        self._publish_led_state("scanning")
-        self._publish_display_text("Scanning 360")
-        publish_json(
-            self.cmd_pub,
-            TOPIC_NAV,
-            {
-                "direction": "right",
-                "source": source,
-                "duration_s": self.scan_duration_s,
-                "intent": "scan",
-            },
-        )
-        self._last_nav_direction = "right"
-        logger.info("scan_start source=%s duration_s=%.2f", source, self.scan_duration_s)
-        self._publish_remote_event("scan_start", {"source": source, "duration_s": self.scan_duration_s})
-        return True
-
-    def _finish_scan(self, *, reason: str, transition_event: str = "scan_complete") -> None:
-        publish_json(self.cmd_pub, TOPIC_NAV, {"direction": "stop", "source": "scan", "reason": reason})
-        self._last_nav_direction = "stop"
-        if self._scan_prev_vision_mode == VisionMode.OFF:
-            self._set_vision_mode(VisionMode.OFF, source="scan")
-        self._scan_prev_vision_mode = None
-        summary = self._summarize_labels(self._scan_labels)
-        counts = self._count_labels(self._scan_labels)
-        self._last_scan_summary = summary
-        self._scan_end_ts = None
-        self._scan_labels = []
-        logger.info("object_summary summary=%s counts=%s", summary, counts)
-        if self._transition(transition_event):
-            self._enter_idle()
-        if transition_event == "scan_abort":
-            logger.info("scan_abort reason=%s", reason)
-        else:
-            logger.info("scan_complete reason=%s", reason)
-        self._publish_remote_event(
-            "scan_complete",
-            {"summary": summary, "counts": counts, "reason": reason},
-        )
-        if summary == "no objects detected":
-            speak_text = "Scan complete. I detected no objects."
-        else:
-            speak_text = f"Scan complete. I detected {summary}."
-        self._maybe_speak_status(speak_text, context="scan_complete")
-
-    def _abort_scan(self, *, reason: str) -> None:
-        if self._phase != Phase.SCANNING:
-            return
-        logger.warning("scan_abort reason=%s", reason)
-        self._finish_scan(reason=reason, transition_event="scan_abort")
-
-    def _update_gas_warning(self, mq2_value: Optional[int]) -> None:
-        if mq2_value is None:
-            return
-        self._gas_level = mq2_value
-        gas_warning = mq2_value >= self.gas_threshold
-        if gas_warning == self._gas_warning:
-            return
-        self._gas_warning = gas_warning
-        if gas_warning:
-            logger.warning("gas_warning level=%s threshold=%s", mq2_value, self.gas_threshold)
-            self._publish_led_state("gas_danger")
-            self._publish_display_text("Gas danger detected")
-            publish_json(
-                self.cmd_pub,
-                TOPIC_TTS,
-                {"text": "Warning. Gas level is above safe limits.", "source": "orchestrator"},
-            )
-            self._publish_remote_event(
-                "gas_warning",
-                {"level": mq2_value, "threshold": self.gas_threshold},
-            )
-        else:
-            logger.info("gas_clear level=%s threshold=%s", mq2_value, self.gas_threshold)
-            self._publish_led_state(self._last_led_state or "idle")
-            self._publish_remote_event("gas_clear", {"level": mq2_value, "threshold": self.gas_threshold})
-
-    def _enter_idle(self) -> None:
-        self._publish_led_state("idle")
-        self._publish_display_text("Idle")
-        # Vision lifecycle is managed explicitly; do not auto-resume here.
-
-    def _notify_stt_failure(self, reason: str) -> None:
-        feedback_messages = {
-            "timeout": [
-                "I didn't catch anything. Try again?",
-                "I lost you there. Say it once more.",
-                "I waited but heard nothing. Please try again.",
-            ],
-            "empty": [
-                "I couldn't make that out. Please speak clearly.",
-                "That came through empty. Try a bit louder.",
-                "I missed that. Please repeat.",
-            ],
-            "low_confidence": [
-                "I'm not sure I got that. Please repeat.",
-                "That was unclear. Say it again for me.",
-                "I didn't get enough confidence. Try again.",
-            ],
-        }
-        choices = feedback_messages.get(reason)
-        if choices:
-            message = random.choice(choices)
-        else:
-            message = "Something went wrong. Please try again."
-        publish_json(self.cmd_pub, TOPIC_TTS, {"text": message, "notification": True, "source": "orchestrator"})
-        logger.info("STT failure feedback: %s", reason)
-
-    def on_wakeword(self, payload: Dict[str, Any]) -> None:
-        if self._phase != Phase.IDLE:
-            logger.debug("Wakeword ignored: not in IDLE (current: %s)", self._phase.name)
-            return
-        logger.info("Wakeword detected: %s", payload.get("keyword", "unknown"))
-        if self._transition("wakeword"):
-            self._enter_listening(from_wakeword=True)
-
-    def on_manual_trigger(self, payload: Dict[str, Any]) -> None:
-        if self._phase != Phase.IDLE:
-            logger.debug("Manual trigger ignored: not in IDLE (current: %s)", self._phase.name)
-            return
-        logger.info("Manual trigger received")
-        if self._transition("manual_trigger"):
-            self._enter_listening(from_wakeword=False)
-
-    def on_stt(self, payload: Dict[str, Any]) -> None:
-        if self._phase != Phase.LISTENING:
-            logger.debug("STT result ignored: not in LISTENING (current: %s)", self._phase.name)
-            return
-        text = str(payload.get("text", "")).strip()
-        confidence = float(payload.get("confidence", 0.0) or 0.0)
-        logger.info("STT payload: text='%s' conf=%.2f", text[:120], confidence)
-        
-        if not text:
-            logger.warning("Empty transcription received")
-            self._exit_listening("empty")
-            self._notify_stt_failure("empty")
-            self._transition("stt_invalid")
-            self._enter_idle()
-            return
-        
-        if confidence < self.stt_min_confidence:
-            logger.info("Low confidence (%.3f < %.3f): '%s'", confidence, self.stt_min_confidence, text[:50])
-            self._exit_listening("low_confidence")
-            self._notify_stt_failure("low_confidence")
-            self._transition("stt_invalid")
-            self._enter_idle()
-            return
-        
-        logger.info("STT valid (%d chars, conf=%.2f)", len(text), confidence)
-        self._last_transcript = text
-        self._exit_listening("success")
-        
-        if self._transition("stt_valid"):
-            if self._should_request_vision(text):
-                self._request_vision_capture(text)
-            else:
-                self._enter_thinking(text)
-
-    def _should_request_vision(self, text: str) -> bool:
-        keywords = ["what do you see", "what are you seeing", "describe", "look at"]
-        return any(k in text.lower() for k in keywords)
-
-    def _request_vision_capture(self, text: str) -> None:
-        if self.vision_mode == VisionMode.OFF:
-            self._set_vision_mode(VisionMode.ON_NO_STREAM, source="internal")
-        request_id = f"visn-{int(time.time() * 1000)}"
-        self._vision_capture_pending = request_id
-        self._vision_capture_requested_ts = time.time()
-        self._last_transcript = text
-        publish_json(self.cmd_pub, TOPIC_CMD_VISN_CAPTURE, {"request_id": request_id, "source": "orchestrator"})
-
-    def _request_frame_capture(self, source: str) -> str:
-        if self.vision_mode == VisionMode.OFF:
-            self._set_vision_mode(VisionMode.ON_NO_STREAM, source=source)
-        request_id = f"capture-{int(time.time() * 1000)}"
-        publish_json(
-            self.cmd_pub,
-            TOPIC_CMD_VISN_CAPTURE,
-            {"request_id": request_id, "source": source, "save": True, "purpose": "capture_frame"},
-        )
-        return request_id
-
-    def on_vision(self, payload: Dict[str, Any]) -> None:
-        self._last_vision = payload
-        label_value = payload.get("label")
-        if self._phase == Phase.SCANNING:
-            self._scan_labels.append(str(label_value or "none"))
-            if len(self._scan_labels) > 50:
-                self._scan_labels = self._scan_labels[-50:]
-        request_id = payload.get("request_id")
-        if request_id:
-            bucket = self._capture_labels.setdefault(str(request_id), [])
-            bucket.append(str(label_value or "none"))
-            if len(bucket) > 25:
-                del bucket[0]
-        if self._vision_capture_pending:
-            request_id = payload.get("request_id")
-            if request_id == self._vision_capture_pending:
-                self._vision_capture_pending = None
-                self._vision_capture_requested_ts = None
-                if self._phase == Phase.THINKING:
-                    self._enter_thinking(self._last_transcript, vision=payload)
-
-    def on_vision_captured(self, payload: Dict[str, Any]) -> None:
-        request_id = payload.get("request_id")
-        labels: list[str] = []
-        if request_id:
-            labels = self._capture_labels.pop(str(request_id), [])
-        summary = self._summarize_labels(labels)
-        self._maybe_speak_status(f"Capture complete: {summary}.", context="capture_complete")
-
-    def on_llm(self, payload: Dict[str, Any]) -> None:
-        if self._phase != Phase.THINKING:
-            logger.debug("LLM response ignored: not in THINKING (current: %s)", self._phase.name)
-            return
-        logger.info("LLM response received")
-        body = payload.get("json") or {}
-        speak = body.get("speak") or payload.get("text", "")
-        direction = self._normalize_direction(body.get("direction"))
-        if self._esp_obstacle and direction == "forward":
-            direction = "stop"
-            if speak:
-                speak = f"{speak} Obstacle ahead, stopping."
-        logger.info("LLM response speak: %s", (speak or "")[:120])
-        
-        if speak:
-            if self._transition("llm_with_speech"):
-                self._enter_speaking(speak, direction)
-        else:
-            logger.info("LLM response has no speak text; TTS skipped")
-            self._publish_remote_event("tts_skipped", {"reason": "empty_speak"})
-            if direction and direction != "stop":
-                publish_json(self.cmd_pub, TOPIC_NAV, {"direction": direction, "source": "orchestrator"})
-                self._last_nav_direction = direction
-            self._transition("llm_no_speech")
-            self._enter_idle()
-
-    def on_tts(self, payload: Dict[str, Any]) -> None:
-        if payload.get("started"):
-            self._publish_led_state("speaking")
-            return
-        done = payload.get("done") or payload.get("final") or payload.get("completed")
-        if payload.get("notification"):
-            return
-        if not done:
-            return
-        if self._phase != Phase.SPEAKING:
-            logger.debug("TTS done ignored: not in SPEAKING (current: %s)", self._phase.name)
-            return
-        logger.info("TTS completed")
-        if self._transition("tts_done"):
-            self._enter_idle()
-
-    def on_esp(self, payload: Dict[str, Any]) -> None:
-        data = payload.get("data")
-        if data:
-            self._esp_obstacle = bool(data.get("obstacle", False)) or (data.get("is_safe") is False)
-            self._esp_min_distance = int(data.get("min_distance", -1))
-            mq2_value = data.get("mq2")
-            try:
-                mq2_value = int(mq2_value) if mq2_value is not None else None
-            except Exception:
-                mq2_value = None
-            self._update_gas_warning(mq2_value)
-            if self._esp_obstacle and not self._obstacle_latched:
-                self._obstacle_latched = True
-                logger.warning("Obstacle detected by ESP32; forcing stop")
-                publish_json(self.cmd_pub, TOPIC_NAV, {"direction": "stop", "reason": "obstacle"})
-                self._last_nav_direction = "stop"
-                self._publish_display_text("Obstacle detected - stopping")
-                if self._phase == Phase.SCANNING:
-                    self._abort_scan(reason="obstacle")
-            elif not self._esp_obstacle and self._obstacle_latched:
-                self._obstacle_latched = False
-                logger.info("Obstacle cleared by ESP32")
-        alert = payload.get("alert")
-        if alert == "COLLISION":
-            logger.critical("ESP32 collision alert!")
-            publish_json(self.cmd_pub, TOPIC_NAV, {"direction": "stop", "reason": "collision"})
-            self._last_nav_direction = "stop"
-
-    def on_health(self, payload: Dict[str, Any]) -> None:
-        ok = bool(payload.get("ok", True))
-        if not ok and self._phase != Phase.ERROR:
-            logger.error("Health error: %s", payload)
-            self._publish_led_state("error")
-            self._transition("health_error")
-        elif ok and self._phase == Phase.ERROR:
-            logger.info("Health restored")
-            self._transition("health_ok")
-            self._enter_idle()
-
-    def _check_timeouts(self) -> None:
-        now = time.time()
-        elapsed = now - self._phase_entered_ts
-        if self._phase == Phase.LISTENING and elapsed > self.stt_timeout_s:
-            logger.warning("STT timeout (%.1fs)", self.stt_timeout_s)
-            self._exit_listening("timeout")
-            self._notify_stt_failure("timeout")
-            self._transition("stt_timeout")
-            self._enter_idle()
-        elif self._phase == Phase.ERROR and elapsed > self.error_recovery_s:
-            logger.info("Error auto-recovery after %.1fs", self.error_recovery_s)
-            self._transition("error_timeout")
-            self._publish_display_text("Recovered. Ready.")
-            self._enter_idle()
-
-        if self._vision_capture_pending and self._vision_capture_requested_ts:
-            if (now - self._vision_capture_requested_ts) > 3.0:
-                logger.warning("Vision capture timeout; proceeding without vision")
-                self._vision_capture_pending = None
-                self._vision_capture_requested_ts = None
-                if self._phase == Phase.THINKING:
-                    self._enter_thinking(self._last_transcript)
-
-        if self._phase == Phase.SCANNING and self._scan_end_ts and now >= self._scan_end_ts:
-            self._finish_scan(reason="time_bound")
-
-        if self._remote_session_active and self._remote_last_seen:
-            if (now - self._remote_last_seen) > self.remote_session_timeout_s:
-                self._remote_session_active = False
-                publish_json(self.cmd_pub, TOPIC_REMOTE_SESSION, {
-                    "active": False,
-                    "last_seen": int(self._remote_last_seen) if self._remote_last_seen else None,
-                    "source": "orchestrator",
-                })
-
-    def _check_auto_trigger(self) -> None:
-        if not self.auto_trigger_enabled:
-            return
-        if self._phase != Phase.IDLE:
-            return
-        idle_time = time.time() - self._last_interaction_ts
-        if idle_time > self.auto_trigger_interval:
-            logger.info("Auto-trigger after %.1fs idle", idle_time)
-            if self._transition("auto_trigger"):
-                self._enter_listening(from_wakeword=False)
-
-    def run(self) -> None:
-        logger.info(
-            "Orchestrator running (Phase FSM) auto_trigger=%s interval=%.1fs stt_timeout=%.1fs",
-            self.auto_trigger_enabled,
-            self.auto_trigger_interval,
-            self.stt_timeout_s,
-        )
-        logger.info("Initial phase: %s", self._phase.name)
-        self._publish_led_state("idle")
-        self._set_vision_mode(self.vision_mode, source="internal")
-
-        poller = zmq.Poller()
-        poller.register(self.events_sub, zmq.POLLIN)
-
-        while True:
-            socks = dict(poller.poll(timeout=100))
-            if self.events_sub in socks:
-                try:
-                    topic, data = self.events_sub.recv_multipart()
-                    if topic == TOPIC_VISN_FRAME:
-                        self.cmd_pub.send_multipart([topic, data])
-                        continue
-                    payload = json.loads(data)
-                except Exception as exc:
-                    logger.error("Recv/parse error: %s", exc)
-                    continue
-
-                if topic == TOPIC_WW_DETECTED:
-                    self.on_wakeword(payload)
-                elif topic == TOPIC_CMD_LISTEN_START:
-                    self.on_manual_trigger(payload)
-                elif topic == TOPIC_STT:
-                    self.on_stt(payload)
-                elif topic == TOPIC_LLM_RESP:
-                    self.on_llm(payload)
-                elif topic == TOPIC_TTS:
-                    self.on_tts(payload)
-                elif topic == TOPIC_VISN:
-                    self.on_vision(payload)
-                    publish_json(self.cmd_pub, TOPIC_VISN, payload)
-                elif topic == TOPIC_VISN_CAPTURED:
-                    self.on_vision_captured(payload)
-                    publish_json(self.cmd_pub, TOPIC_VISN_CAPTURED, payload)
-                elif topic == TOPIC_ESP:
-                    self.on_esp(payload)
-                    publish_json(self.cmd_pub, TOPIC_ESP, payload)
-                elif topic == TOPIC_HEALTH:
-                    self.on_health(payload)
-                elif topic == TOPIC_REMOTE_SESSION:
-                    self.on_remote_session(payload)
-                elif topic == TOPIC_REMOTE_INTENT:
-                    self.on_remote_intent(payload)
-
-            self._check_timeouts()
-            self._check_auto_trigger()
-
-    def _coerce_vision_mode(self, raw: str) -> VisionMode:
-        raw = (raw or "").lower().strip()
-        if raw in {"off", "disabled", "false", "0"}:
-            return VisionMode.OFF
-        if raw in {"on_with_stream", "with_stream", "stream"}:
-            return VisionMode.ON_WITH_STREAM
-        return VisionMode.ON_NO_STREAM
-
-    def _set_vision_mode(self, mode: VisionMode, *, source: str) -> None:
-        if mode == self.vision_mode:
-            return
-        self.vision_mode = mode
-        publish_json(
-            self.cmd_pub,
-            TOPIC_CMD_VISION_MODE,
-            {"mode": mode.value, "timestamp": int(time.time()), "source": source},
-        )
-
-    def _publish_remote_event(self, event: str, payload: Dict[str, Any]) -> None:
-        message = {"event": event, "timestamp": int(time.time()), **payload}
-        publish_json(self.cmd_pub, TOPIC_REMOTE_EVENT, message)
-
-    def on_remote_session(self, payload: Dict[str, Any]) -> None:
-        active = bool(payload.get("active", False))
-        self._remote_session_active = active
-        if active:
-            self._remote_last_seen = time.time()
-
-    def on_remote_intent(self, payload: Dict[str, Any]) -> None:
-        source = payload.get("source", "unknown")
-        logger.info("remote_intent received source=%s payload=%s", source, payload)
-        if source != "remote_app":
-            logger.warning("remote_intent rejected reason=invalid_source payload=%s", payload)
-            self._publish_remote_event("rejected", {"reason": "invalid_source", "payload": payload})
-            return
-
-        if not self._remote_session_active:
-            logger.warning("remote_intent rejected reason=no_active_session payload=%s", payload)
-            self._publish_remote_event("rejected", {"reason": "no_active_session", "payload": payload})
-            return
-
-        intent = str(payload.get("intent", "")).strip().lower()
-        if not intent:
-            logger.warning("remote_intent rejected reason=missing_intent payload=%s", payload)
-            self._publish_remote_event("rejected", {"reason": "missing_intent", "payload": payload})
-            return
-
-        if self._phase == Phase.SCANNING:
-            logger.warning("remote_intent rejected reason=scan_in_progress payload=%s", payload)
-            self._publish_remote_event("rejected", {"reason": "scan_in_progress", "payload": payload})
-            return
-
-        if intent in {"enable_vision", "enable_perception"}:
-            self._set_vision_mode(VisionMode.ON_NO_STREAM, source="remote_app")
-            logger.info("remote_intent accepted intent=%s", intent)
-            self._publish_remote_event("accepted", {"intent": intent})
-            return
-        if intent in {"disable_vision", "disable_perception"}:
-            self._set_vision_mode(VisionMode.OFF, source="remote_app")
-            logger.info("remote_intent accepted intent=%s", intent)
-            self._publish_remote_event("accepted", {"intent": intent})
-            return
-        if intent in {"enable_stream"}:
-            self._set_vision_mode(VisionMode.ON_WITH_STREAM, source="remote_app")
-            logger.info("remote_intent accepted intent=%s", intent)
-            self._publish_remote_event("accepted", {"intent": intent})
-            return
-        if intent in {"disable_stream"}:
-            self._set_vision_mode(VisionMode.ON_NO_STREAM, source="remote_app")
-            logger.info("remote_intent accepted intent=%s", intent)
-            self._publish_remote_event("accepted", {"intent": intent})
-            return
-        if intent in {"capture_frame"}:
-            request_id = self._request_frame_capture("remote_app")
-            self._maybe_speak_status("Capturing frame.", context="capture_start")
-            logger.info("remote_intent accepted intent=%s request_id=%s", intent, request_id)
-            self._publish_remote_event("accepted", {"intent": intent, "request_id": request_id})
-            return
-        if intent in {"invoke_assistant"}:
-            if self._transition("manual_think"):
-                text = str(payload.get("text", "manual_invoke")).strip() or "manual_invoke"
-                self._last_transcript = text
-                self._enter_thinking(text, source="remote_app", mode="manual_invoke")
-                logger.info("remote_intent accepted intent=%s", intent)
-                self._publish_remote_event("accepted", {"intent": intent})
-            else:
-                logger.warning("remote_intent rejected reason=busy payload=%s", payload)
-                self._publish_remote_event("rejected", {"reason": "busy", "payload": payload})
-            return
-        if intent in {"assistant_text"}:
-            text = str(payload.get("text", "")).strip()
-            if not text:
-                logger.warning("remote_intent rejected reason=missing_text payload=%s", payload)
-                self._publish_remote_event("rejected", {"reason": "missing_text", "payload": payload})
-                return
-            if self._transition("manual_text"):
-                self._last_transcript = text
-                self._enter_thinking(text, source="remote_app", mode="manual_text")
-                logger.info("remote_intent accepted intent=%s", intent)
-                self._publish_remote_event("accepted", {"intent": intent})
-            else:
-                logger.warning("remote_intent rejected reason=busy payload=%s", payload)
-                self._publish_remote_event("rejected", {"reason": "busy", "payload": payload})
-            return
-        if intent in {"scan", "start_scan"}:
-            if self._start_scan(source="remote_app"):
-                logger.info("remote_intent accepted intent=%s", intent)
-                self._publish_remote_event("accepted", {"intent": intent})
-            return
-        if intent in {"stop", "stop_motion"}:
-            logger.info(
-                "nav.command publish intent=%s direction=stop speed=%s duration=%s payload=%s",
-                intent,
-                payload.get("speed"),
-                payload.get("duration"),
-                {"direction": "stop", "source": "remote_app"},
-            )
-            publish_json(self.cmd_pub, TOPIC_NAV, {"direction": "stop", "source": "remote_app"})
-            logger.info("remote_intent accepted intent=%s", intent)
-            self._publish_remote_event("accepted", {"intent": intent})
-            return
-        if intent in {"move_backward"}:
-            logger.info(
-                "nav.command publish intent=%s direction=backward speed=%s duration=%s payload=%s",
-                intent,
-                payload.get("speed"),
-                payload.get("duration"),
-                {"direction": "backward", "source": "remote_app"},
-            )
-            publish_json(self.cmd_pub, TOPIC_NAV, {"direction": "backward", "source": "remote_app"})
-            logger.info("remote_intent accepted intent=%s direction=backward", intent)
-            self._publish_remote_event("accepted", {"intent": intent, "direction": "backward"})
-            return
-        if intent in {"rotate", "rotate_left", "rotate_right", "start_motion", "start"}:
-            direction = str(payload.get("direction", "")).strip().lower()
-            if not direction:
-                if intent == "rotate_left":
-                    direction = "left"
-                elif intent == "rotate_right":
-                    direction = "right"
-                elif intent in {"start_motion", "start"}:
-                    direction = "forward"
-
-            if direction not in {"forward", "backward", "left", "right"}:
-                logger.warning("remote_intent rejected reason=invalid_direction payload=%s", payload)
-                self._publish_remote_event("rejected", {"reason": "invalid_direction", "payload": payload})
-                return
-            logger.info(
-                "nav.command publish intent=%s direction=%s speed=%s duration=%s payload=%s",
-                intent,
-                direction,
-                payload.get("speed"),
-                payload.get("duration"),
-                {"direction": direction, "source": "remote_app"},
-            )
-            publish_json(self.cmd_pub, TOPIC_NAV, {"direction": direction, "source": "remote_app"})
-            logger.info("remote_intent accepted intent=%s direction=%s", intent, direction)
-            self._publish_remote_event("accepted", {"intent": intent, "direction": direction})
-            return
-
-        logger.warning("remote_intent rejected reason=unsupported_intent payload=%s", payload)
-        self._publish_remote_event("rejected", {"reason": "unsupported_intent", "payload": payload})
-
-
-def main() -> None:
-    try:
-        Orchestrator().run()
-    except Exception as exc:
-        logger.error("Fatal error: %s", exc)
-        raise
-
-
-if __name__ == "__main__":
-    main()
+"""Phase-driven orchestrator: single source of truth state machine.
+
+LED COLOR SCHEME (granular feedback):
+    idle                - Dim cyan breathing (waiting for wakeword)
+    wakeword_detected   - Bright GREEN flash (acknowledged!)
+    listening           - Bright BLUE sweep (capturing audio)
+    transcribing        - PURPLE pulse (STT processing)
+    thinking            - PINK pulse (LLM processing)
+    tts_processing      - ORANGE pulse (generating speech)
+    speaking            - Dark GREEN chase (playing audio)
+    error               - RED blink (system error)
+"""
+from __future__ import annotations
+
+import json
+import random
+import time
+from enum import Enum, auto
+from pathlib import Path
+from typing import Any, Dict, Optional
+
+import zmq
+
+from src.core.config_loader import load_config
+from src.core.ipc import (
+    TOPIC_CMD_LISTEN_START,
+    TOPIC_CMD_LISTEN_STOP,
+    TOPIC_CMD_PAUSE_VISION,
+    TOPIC_CMD_VISN_CAPTURE,
+    TOPIC_CMD_VISION_MODE,
+    TOPIC_DISPLAY_STATE,
+    TOPIC_DISPLAY_TEXT,
+    TOPIC_ESP,
+    TOPIC_HEALTH,
+    TOPIC_LLM_REQ,
+    TOPIC_LLM_RESP,
+    TOPIC_NAV,
+    TOPIC_REMOTE_EVENT,
+    TOPIC_REMOTE_INTENT,
+    TOPIC_REMOTE_SESSION,
+    TOPIC_STT,
+    TOPIC_TTS,
+    TOPIC_VISN,
+    TOPIC_VISN_CAPTURED,
+    TOPIC_VISN_FRAME,
+    TOPIC_WW_DETECTED,
+    make_publisher,
+    make_subscriber,
+    publish_json,
+)
+from src.core.logging_setup import get_logger
+from src.core.world_context import WorldContextAggregator
+
+logger = get_logger("orchestrator", Path("logs"))
+
+
+class Phase(Enum):
+    IDLE = auto()
+    LISTENING = auto()
+    THINKING = auto()
+    SPEAKING = auto()
+    ERROR = auto()
+
+
+class VisionMode(Enum):
+    OFF = "off"
+    ON_NO_STREAM = "on_no_stream"
+    ON_WITH_STREAM = "on_with_stream"
+
+
+class Orchestrator:
+    TRANSITIONS = {
+        (Phase.IDLE, "wakeword"): Phase.LISTENING,
+        (Phase.IDLE, "auto_trigger"): Phase.LISTENING,
+        (Phase.IDLE, "manual_trigger"): Phase.LISTENING,
+        (Phase.IDLE, "manual_think"): Phase.THINKING,
+        (Phase.IDLE, "manual_text"): Phase.THINKING,
+        (Phase.LISTENING, "stt_valid"): Phase.THINKING,
+        (Phase.LISTENING, "stt_invalid"): Phase.IDLE,
+        (Phase.LISTENING, "stt_timeout"): Phase.IDLE,
+        (Phase.THINKING, "llm_with_speech"): Phase.SPEAKING,
+        (Phase.THINKING, "llm_no_speech"): Phase.IDLE,
+        (Phase.SPEAKING, "tts_done"): Phase.IDLE,
+        (Phase.IDLE, "health_error"): Phase.ERROR,
+        (Phase.LISTENING, "health_error"): Phase.ERROR,
+        (Phase.THINKING, "health_error"): Phase.ERROR,
+        (Phase.SPEAKING, "health_error"): Phase.ERROR,
+        (Phase.ERROR, "health_ok"): Phase.IDLE,
+        (Phase.ERROR, "error_timeout"): Phase.IDLE,
+    }
+
+    def __init__(self) -> None:
+        self.config = load_config(Path("config/system.yaml"))
+        self.cmd_pub = make_publisher(self.config, channel="downstream", bind=True)
+        self.events_sub = make_subscriber(self.config, channel="upstream", bind=True)
+        self._world_context = WorldContextAggregator(self.config)
+        self._world_context.start()
+        self._phase = Phase.IDLE
+        self._phase_entered_ts = time.time()
+        self._last_interaction_ts = time.time()
+        self._last_transcript = ""
+        self._last_vision: Optional[Dict[str, Any]] = None
+        self._last_nav_direction = "stopped"
+        self._vision_capture_pending: Optional[str] = None
+        self._vision_capture_requested_ts: Optional[float] = None
+        self._esp_obstacle = False
+        self._esp_min_distance = -1
+        self._obstacle_latched = False
+
+        self._remote_session_active = False
+        self._remote_last_seen = 0.0
+        
+        orch_cfg = self.config.get("orchestrator", {}) or {}
+        self.auto_trigger_enabled = bool(orch_cfg.get("auto_trigger_enabled", True))
+        self.auto_trigger_interval = float(orch_cfg.get("auto_trigger_interval", 60.0))
+        
+        stt_cfg = self.config.get("stt", {}) or {}
+        self.stt_timeout_s = float(stt_cfg.get("timeout_seconds", 30.0))
+        self.stt_min_confidence = float(stt_cfg.get("min_confidence", 0.3))
+        self.error_recovery_s = 2.0
+
+        remote_cfg = self.config.get("remote_interface", {}) or {}
+        self.remote_session_timeout_s = float(remote_cfg.get("session_timeout_s", 15.0))
+
+        vision_cfg = self.config.get("vision", {}) or {}
+        default_mode = str(vision_cfg.get("default_mode", "off")).lower()
+        self.vision_mode = self._coerce_vision_mode(default_mode)
+
+    def _publish_led_state(self, state: str) -> None:
+        publish_json(self.cmd_pub, TOPIC_DISPLAY_STATE, {
+            "state": state,
+            "phase": self._phase.name,
+            "timestamp": int(time.time()),
+            "source": "orchestrator",
+        })
+        logger.debug("LED: %s", state)
+
+    def _publish_display_text(self, text: str) -> None:
+        publish_json(self.cmd_pub, TOPIC_DISPLAY_TEXT, {
+            "text": text,
+            "timestamp": int(time.time()),
+            "source": "orchestrator",
+        })
+
+    @property
+    def phase(self) -> Phase:
+        return self._phase
+
+    def _transition(self, event_type: str) -> bool:
+        key = (self._phase, event_type)
+        next_phase = self.TRANSITIONS.get(key)
+        if next_phase is None:
+            logger.debug("IGNORED: event '%s' illegal in phase %s", event_type, self._phase.name)
+            return False
+        if next_phase == self._phase:
+            return False
+        old_phase = self._phase
+        self._phase = next_phase
+        self._phase_entered_ts = time.time()
+        logger.info("PHASE: %s -> %s (event: %s)", old_phase.name, next_phase.name, event_type)
+        return True
+
+    @staticmethod
+    def _normalize_direction(direction: Optional[str]) -> str:
+        allowed = {"forward", "backward", "left", "right", "stop", "scan"}
+        if not direction:
+            return "stop"
+        value = str(direction).strip().lower()
+        return value if value in allowed else "stop"
+
+    def _enter_listening(self, from_wakeword: bool = False) -> None:
+        self._last_interaction_ts = time.time()
+        if from_wakeword:
+            self._publish_led_state("wakeword_detected")
+            self._publish_display_text("Wakeword detected")
+        else:
+            self._publish_led_state("listening")
+            self._publish_display_text("Listening...")
+        if self.vision_mode != VisionMode.OFF:
+            publish_json(self.cmd_pub, TOPIC_CMD_PAUSE_VISION, {"pause": True, "source": "orchestrator"})
+        publish_json(self.cmd_pub, TOPIC_CMD_LISTEN_START, {"start": True, "source": "orchestrator"})
+
+    def _exit_listening(self, reason: str) -> None:
+        publish_json(self.cmd_pub, TOPIC_CMD_LISTEN_STOP, {"stop": True, "reason": reason, "source": "orchestrator"})
+        if self.vision_mode != VisionMode.OFF:
+            publish_json(self.cmd_pub, TOPIC_CMD_PAUSE_VISION, {"pause": False, "source": "orchestrator"})
+
+    def _enter_thinking(
+        self,
+        text: str,
+        vision: Optional[Dict[str, Any]] = None,
+        *,
+        source: str = "orchestrator",
+        mode: Optional[str] = None,
+    ) -> None:
+        self._publish_led_state("thinking")
+        self._publish_display_text(f"Heard: {text[:120]}")
+        payload: Dict[str, Any] = {"text": text}
+        if vision:
+            payload["vision"] = vision
+        payload["direction"] = self._last_nav_direction
+        payload["world_context"] = self._world_context.get_snapshot()
+        payload["context_note"] = "system_observation_only_last_known_state"
+        payload["source"] = source
+        if mode:
+            payload["mode"] = mode
+        publish_json(self.cmd_pub, TOPIC_LLM_REQ, payload)
+        logger.info("LLM request text: %s", text[:120])
+
+    def _enter_speaking(self, text: str, direction: Optional[str] = None) -> None:
+        self._publish_led_state("tts_processing")
+        self._publish_display_text(f"Saying: {text[:120]}")
+        normalized = self._normalize_direction(direction)
+        if normalized != "stop":
+            if self._esp_obstacle and normalized == "forward":
+                logger.warning("Blocked forward command due to obstacle")
+                publish_json(
+                    self.cmd_pub,
+                    TOPIC_NAV,
+                    {"direction": "stop", "reason": "obstacle", "source": "orchestrator"},
+                )
+                self._last_nav_direction = "stop"
+            else:
+                self._last_nav_direction = normalized
+                publish_json(self.cmd_pub, TOPIC_NAV, {"direction": normalized, "source": "orchestrator"})
+        publish_json(self.cmd_pub, TOPIC_TTS, {"text": text, "source": "orchestrator"})
+
+    def _enter_idle(self) -> None:
+        self._publish_led_state("idle")
+        self._publish_display_text("Idle")
+        # Vision lifecycle is managed explicitly; do not auto-resume here.
+
+    def _notify_stt_failure(self, reason: str) -> None:
+        feedback_messages = {
+            "timeout": [
+                "I didn't catch anything. Try again?",
+                "I lost you there. Say it once more.",
+                "I waited but heard nothing. Please try again.",
+            ],
+            "empty": [
+                "I couldn't make that out. Please speak clearly.",
+                "That came through empty. Try a bit louder.",
+                "I missed that. Please repeat.",
+            ],
+            "low_confidence": [
+                "I'm not sure I got that. Please repeat.",
+                "That was unclear. Say it again for me.",
+                "I didn't get enough confidence. Try again.",
+            ],
+        }
+        choices = feedback_messages.get(reason)
+        if choices:
+            message = random.choice(choices)
+        else:
+            message = "Something went wrong. Please try again."
+        publish_json(self.cmd_pub, TOPIC_TTS, {"text": message, "notification": True, "source": "orchestrator"})
+        logger.info("STT failure feedback: %s", reason)
+
+    def on_wakeword(self, payload: Dict[str, Any]) -> None:
+        if self._phase != Phase.IDLE:
+            logger.debug("Wakeword ignored: not in IDLE (current: %s)", self._phase.name)
+            return
+        logger.info("Wakeword detected: %s", payload.get("keyword", "unknown"))
+        if self._transition("wakeword"):
+            self._enter_listening(from_wakeword=True)
+
+    def on_manual_trigger(self, payload: Dict[str, Any]) -> None:
+        if self._phase != Phase.IDLE:
+            logger.debug("Manual trigger ignored: not in IDLE (current: %s)", self._phase.name)
+            return
+        logger.info("Manual trigger received")
+        if self._transition("manual_trigger"):
+            self._enter_listening(from_wakeword=False)
+
+    def on_stt(self, payload: Dict[str, Any]) -> None:
+        if self._phase != Phase.LISTENING:
+            logger.debug("STT result ignored: not in LISTENING (current: %s)", self._phase.name)
+            return
+        text = str(payload.get("text", "")).strip()
+        confidence = float(payload.get("confidence", 0.0) or 0.0)
+        logger.info("STT payload: text='%s' conf=%.2f", text[:120], confidence)
+        
+        if not text:
+            logger.warning("Empty transcription received")
+            self._exit_listening("empty")
+            self._notify_stt_failure("empty")
+            self._transition("stt_invalid")
+            self._enter_idle()
+            return
+        
+        if confidence < self.stt_min_confidence:
+            logger.info("Low confidence (%.3f < %.3f): '%s'", confidence, self.stt_min_confidence, text[:50])
+            self._exit_listening("low_confidence")
+            self._notify_stt_failure("low_confidence")
+            self._transition("stt_invalid")
+            self._enter_idle()
+            return
+        
+        logger.info("STT valid (%d chars, conf=%.2f)", len(text), confidence)
+        self._last_transcript = text
+        self._exit_listening("success")
+        
+        if self._transition("stt_valid"):
+            if self._should_request_vision(text):
+                self._request_vision_capture(text)
+            else:
+                self._enter_thinking(text)
+
+    def _should_request_vision(self, text: str) -> bool:
+        keywords = ["what do you see", "what are you seeing", "describe", "look at"]
+        return any(k in text.lower() for k in keywords)
+
+    def _request_vision_capture(self, text: str) -> None:
+        if self.vision_mode == VisionMode.OFF:
+            self._set_vision_mode(VisionMode.ON_NO_STREAM, source="internal")
+        request_id = f"visn-{int(time.time() * 1000)}"
+        self._vision_capture_pending = request_id
+        self._vision_capture_requested_ts = time.time()
+        self._last_transcript = text
+        publish_json(self.cmd_pub, TOPIC_CMD_VISN_CAPTURE, {"request_id": request_id, "source": "orchestrator"})
+
+    def _request_frame_capture(self, source: str) -> str:
+        if self.vision_mode == VisionMode.OFF:
+            self._set_vision_mode(VisionMode.ON_NO_STREAM, source=source)
+        request_id = f"capture-{int(time.time() * 1000)}"
+        publish_json(
+            self.cmd_pub,
+            TOPIC_CMD_VISN_CAPTURE,
+            {"request_id": request_id, "source": source, "save": True, "purpose": "capture_frame"},
+        )
+        return request_id
+
+    def on_vision(self, payload: Dict[str, Any]) -> None:
+        self._last_vision = payload
+        if self._vision_capture_pending:
+            request_id = payload.get("request_id")
+            if request_id == self._vision_capture_pending:
+                self._vision_capture_pending = None
+                self._vision_capture_requested_ts = None
+                if self._phase == Phase.THINKING:
+                    self._enter_thinking(self._last_transcript, vision=payload)
+
+    def on_llm(self, payload: Dict[str, Any]) -> None:
+        if self._phase != Phase.THINKING:
+            logger.debug("LLM response ignored: not in THINKING (current: %s)", self._phase.name)
+            return
+        logger.info("LLM response received")
+        body = payload.get("json") or {}
+        speak = body.get("speak") or payload.get("text", "")
+        direction = self._normalize_direction(body.get("direction"))
+        if self._esp_obstacle and direction == "forward":
+            direction = "stop"
+            if speak:
+                speak = f"{speak} Obstacle ahead, stopping."
+        logger.info("LLM response speak: %s", (speak or "")[:120])
+        
+        if speak:
+            if self._transition("llm_with_speech"):
+                self._enter_speaking(speak, direction)
+        else:
+            logger.info("LLM response has no speak text; TTS skipped")
+            self._publish_remote_event("tts_skipped", {"reason": "empty_speak"})
+            if direction and direction != "stop":
+                publish_json(self.cmd_pub, TOPIC_NAV, {"direction": direction, "source": "orchestrator"})
+                self._last_nav_direction = direction
+            self._transition("llm_no_speech")
+            self._enter_idle()
+
+    def on_tts(self, payload: Dict[str, Any]) -> None:
+        if payload.get("started"):
+            self._publish_led_state("speaking")
+            return
+        done = payload.get("done") or payload.get("final") or payload.get("completed")
+        if payload.get("notification"):
+            return
+        if not done:
+            return
+        if self._phase != Phase.SPEAKING:
+            logger.debug("TTS done ignored: not in SPEAKING (current: %s)", self._phase.name)
+            return
+        logger.info("TTS completed")
+        if self._transition("tts_done"):
+            self._enter_idle()
+
+    def on_esp(self, payload: Dict[str, Any]) -> None:
+        data = payload.get("data")
+        if data:
+            self._esp_obstacle = bool(data.get("obstacle", False)) or (data.get("is_safe") is False)
+            self._esp_min_distance = int(data.get("min_distance", -1))
+            if self._esp_obstacle and not self._obstacle_latched:
+                self._obstacle_latched = True
+                logger.warning("Obstacle detected by ESP32; forcing stop")
+                publish_json(self.cmd_pub, TOPIC_NAV, {"direction": "stop", "reason": "obstacle"})
+                self._last_nav_direction = "stop"
+                self._publish_display_text("Obstacle detected - stopping")
+            elif not self._esp_obstacle and self._obstacle_latched:
+                self._obstacle_latched = False
+                logger.info("Obstacle cleared by ESP32")
+        alert = payload.get("alert")
+        if alert == "COLLISION":
+            logger.critical("ESP32 collision alert!")
+            publish_json(self.cmd_pub, TOPIC_NAV, {"direction": "stop", "reason": "collision"})
+            self._last_nav_direction = "stop"
+
+    def on_health(self, payload: Dict[str, Any]) -> None:
+        ok = bool(payload.get("ok", True))
+        if not ok and self._phase != Phase.ERROR:
+            logger.error("Health error: %s", payload)
+            self._publish_led_state("error")
+            self._transition("health_error")
+        elif ok and self._phase == Phase.ERROR:
+            logger.info("Health restored")
+            self._transition("health_ok")
+            self._enter_idle()
+
+    def _check_timeouts(self) -> None:
+        now = time.time()
+        elapsed = now - self._phase_entered_ts
+        if self._phase == Phase.LISTENING and elapsed > self.stt_timeout_s:
+            logger.warning("STT timeout (%.1fs)", self.stt_timeout_s)
+            self._exit_listening("timeout")
+            self._notify_stt_failure("timeout")
+            self._transition("stt_timeout")
+            self._enter_idle()
+        elif self._phase == Phase.ERROR and elapsed > self.error_recovery_s:
+            logger.info("Error auto-recovery after %.1fs", self.error_recovery_s)
+            self._transition("error_timeout")
+            self._publish_display_text("Recovered. Ready.")
+            self._enter_idle()
+
+        if self._vision_capture_pending and self._vision_capture_requested_ts:
+            if (now - self._vision_capture_requested_ts) > 3.0:
+                logger.warning("Vision capture timeout; proceeding without vision")
+                self._vision_capture_pending = None
+                self._vision_capture_requested_ts = None
+                if self._phase == Phase.THINKING:
+                    self._enter_thinking(self._last_transcript)
+
+        if self._remote_session_active and self._remote_last_seen:
+            if (now - self._remote_last_seen) > self.remote_session_timeout_s:
+                self._remote_session_active = False
+                publish_json(self.cmd_pub, TOPIC_REMOTE_SESSION, {
+                    "active": False,
+                    "last_seen": int(self._remote_last_seen) if self._remote_last_seen else None,
+                    "source": "orchestrator",
+                })
+
+    def _check_auto_trigger(self) -> None:
+        if not self.auto_trigger_enabled:
+            return
+        if self._phase != Phase.IDLE:
+            return
+        idle_time = time.time() - self._last_interaction_ts
+        if idle_time > self.auto_trigger_interval:
+            logger.info("Auto-trigger after %.1fs idle", idle_time)
+            if self._transition("auto_trigger"):
+                self._enter_listening(from_wakeword=False)
+
+    def run(self) -> None:
+        logger.info(
+            "Orchestrator running (Phase FSM) auto_trigger=%s interval=%.1fs stt_timeout=%.1fs",
+            self.auto_trigger_enabled,
+            self.auto_trigger_interval,
+            self.stt_timeout_s,
+        )
+        logger.info("Initial phase: %s", self._phase.name)
+        self._publish_led_state("idle")
+        self._set_vision_mode(self.vision_mode, source="internal")
+
+        poller = zmq.Poller()
+        poller.register(self.events_sub, zmq.POLLIN)
+
+        while True:
+            socks = dict(poller.poll(timeout=100))
+            if self.events_sub in socks:
+                try:
+                    topic, data = self.events_sub.recv_multipart()
+                    if topic == TOPIC_VISN_FRAME:
+                        self.cmd_pub.send_multipart([topic, data])
+                        continue
+                    payload = json.loads(data)
+                except Exception as exc:
+                    logger.error("Recv/parse error: %s", exc)
+                    continue
+
+                if topic == TOPIC_WW_DETECTED:
+                    self.on_wakeword(payload)
+                elif topic == TOPIC_CMD_LISTEN_START:
+                    self.on_manual_trigger(payload)
+                elif topic == TOPIC_STT:
+                    self.on_stt(payload)
+                elif topic == TOPIC_LLM_RESP:
+                    self.on_llm(payload)
+                elif topic == TOPIC_TTS:
+                    self.on_tts(payload)
+                elif topic == TOPIC_VISN:
+                    self.on_vision(payload)
+                    publish_json(self.cmd_pub, TOPIC_VISN, payload)
+                elif topic == TOPIC_VISN_CAPTURED:
+                    publish_json(self.cmd_pub, TOPIC_VISN_CAPTURED, payload)
+                elif topic == TOPIC_ESP:
+                    self.on_esp(payload)
+                    publish_json(self.cmd_pub, TOPIC_ESP, payload)
+                elif topic == TOPIC_HEALTH:
+                    self.on_health(payload)
+                elif topic == TOPIC_REMOTE_SESSION:
+                    self.on_remote_session(payload)
+                elif topic == TOPIC_REMOTE_INTENT:
+                    self.on_remote_intent(payload)
+
+            self._check_timeouts()
+            self._check_auto_trigger()
+
+    def _coerce_vision_mode(self, raw: str) -> VisionMode:
+        raw = (raw or "").lower().strip()
+        if raw in {"off", "disabled", "false", "0"}:
+            return VisionMode.OFF
+        if raw in {"on_with_stream", "with_stream", "stream"}:
+            return VisionMode.ON_WITH_STREAM
+        return VisionMode.ON_NO_STREAM
+
+    def _set_vision_mode(self, mode: VisionMode, *, source: str) -> None:
+        if mode == self.vision_mode:
+            return
+        self.vision_mode = mode
+        publish_json(
+            self.cmd_pub,
+            TOPIC_CMD_VISION_MODE,
+            {"mode": mode.value, "timestamp": int(time.time()), "source": source},
+        )
+
+    def _publish_remote_event(self, event: str, payload: Dict[str, Any]) -> None:
+        message = {"event": event, "timestamp": int(time.time()), **payload}
+        publish_json(self.cmd_pub, TOPIC_REMOTE_EVENT, message)
+
+    def on_remote_session(self, payload: Dict[str, Any]) -> None:
+        active = bool(payload.get("active", False))
+        self._remote_session_active = active
+        if active:
+            self._remote_last_seen = time.time()
+
+    def on_remote_intent(self, payload: Dict[str, Any]) -> None:
+        source = payload.get("source", "unknown")
+        logger.info("remote_intent received source=%s payload=%s", source, payload)
+        if source != "remote_app":
+            logger.warning("remote_intent rejected reason=invalid_source payload=%s", payload)
+            self._publish_remote_event("rejected", {"reason": "invalid_source", "payload": payload})
+            return
+
+        if not self._remote_session_active:
+            logger.warning("remote_intent rejected reason=no_active_session payload=%s", payload)
+            self._publish_remote_event("rejected", {"reason": "no_active_session", "payload": payload})
+            return
+
+        intent = str(payload.get("intent", "")).strip().lower()
+        if not intent:
+            logger.warning("remote_intent rejected reason=missing_intent payload=%s", payload)
+            self._publish_remote_event("rejected", {"reason": "missing_intent", "payload": payload})
+            return
+
+        if intent in {"enable_vision", "enable_perception"}:
+            self._set_vision_mode(VisionMode.ON_NO_STREAM, source="remote_app")
+            logger.info("remote_intent accepted intent=%s", intent)
+            self._publish_remote_event("accepted", {"intent": intent})
+            return
+        if intent in {"disable_vision", "disable_perception"}:
+            self._set_vision_mode(VisionMode.OFF, source="remote_app")
+            logger.info("remote_intent accepted intent=%s", intent)
+            self._publish_remote_event("accepted", {"intent": intent})
+            return
+        if intent in {"enable_stream"}:
+            self._set_vision_mode(VisionMode.ON_WITH_STREAM, source="remote_app")
+            logger.info("remote_intent accepted intent=%s", intent)
+            self._publish_remote_event("accepted", {"intent": intent})
+            return
+        if intent in {"disable_stream"}:
+            self._set_vision_mode(VisionMode.ON_NO_STREAM, source="remote_app")
+            logger.info("remote_intent accepted intent=%s", intent)
+            self._publish_remote_event("accepted", {"intent": intent})
+            return
+        if intent in {"capture_frame"}:
+            request_id = self._request_frame_capture("remote_app")
+            logger.info("remote_intent accepted intent=%s request_id=%s", intent, request_id)
+            self._publish_remote_event("accepted", {"intent": intent, "request_id": request_id})
+            return
+        if intent in {"invoke_assistant"}:
+            if self._transition("manual_think"):
+                text = str(payload.get("text", "manual_invoke")).strip() or "manual_invoke"
+                self._last_transcript = text
+                self._enter_thinking(text, source="remote_app", mode="manual_invoke")
+                logger.info("remote_intent accepted intent=%s", intent)
+                self._publish_remote_event("accepted", {"intent": intent})
+            else:
+                logger.warning("remote_intent rejected reason=busy payload=%s", payload)
+                self._publish_remote_event("rejected", {"reason": "busy", "payload": payload})
+            return
+        if intent in {"assistant_text"}:
+            text = str(payload.get("text", "")).strip()
+            if not text:
+                logger.warning("remote_intent rejected reason=missing_text payload=%s", payload)
+                self._publish_remote_event("rejected", {"reason": "missing_text", "payload": payload})
+                return
+            if self._transition("manual_text"):
+                self._last_transcript = text
+                self._enter_thinking(text, source="remote_app", mode="manual_text")
+                logger.info("remote_intent accepted intent=%s", intent)
+                self._publish_remote_event("accepted", {"intent": intent})
+            else:
+                logger.warning("remote_intent rejected reason=busy payload=%s", payload)
+                self._publish_remote_event("rejected", {"reason": "busy", "payload": payload})
+            return
+        if intent in {"scan", "start_scan"}:
+            logger.info(
+                "nav.command publish intent=%s direction=scan speed=%s duration=%s payload=%s",
+                intent,
+                payload.get("speed"),
+                payload.get("duration"),
+                {"direction": "scan", "source": "remote_app"},
+            )
+            publish_json(self.cmd_pub, TOPIC_NAV, {"direction": "scan", "source": "remote_app"})
+            logger.info("remote_intent accepted intent=%s", intent)
+            self._publish_remote_event("accepted", {"intent": intent})
+            return
+        if intent in {"stop", "stop_motion"}:
+            logger.info(
+                "nav.command publish intent=%s direction=stop speed=%s duration=%s payload=%s",
+                intent,
+                payload.get("speed"),
+                payload.get("duration"),
+                {"direction": "stop", "source": "remote_app"},
+            )
+            publish_json(self.cmd_pub, TOPIC_NAV, {"direction": "stop", "source": "remote_app"})
+            logger.info("remote_intent accepted intent=%s", intent)
+            self._publish_remote_event("accepted", {"intent": intent})
+            return
+        if intent in {"move_backward"}:
+            logger.info(
+                "nav.command publish intent=%s direction=backward speed=%s duration=%s payload=%s",
+                intent,
+                payload.get("speed"),
+                payload.get("duration"),
+                {"direction": "backward", "source": "remote_app"},
+            )
+            publish_json(self.cmd_pub, TOPIC_NAV, {"direction": "backward", "source": "remote_app"})
+            logger.info("remote_intent accepted intent=%s direction=backward", intent)
+            self._publish_remote_event("accepted", {"intent": intent, "direction": "backward"})
+            return
+        if intent in {"rotate", "rotate_left", "rotate_right", "start_motion", "start"}:
+            direction = str(payload.get("direction", "")).strip().lower()
+            if not direction:
+                if intent == "rotate_left":
+                    direction = "left"
+                elif intent == "rotate_right":
+                    direction = "right"
+                elif intent in {"start_motion", "start"}:
+                    direction = "forward"
+
+            if direction not in {"forward", "backward", "left", "right"}:
+                logger.warning("remote_intent rejected reason=invalid_direction payload=%s", payload)
+                self._publish_remote_event("rejected", {"reason": "invalid_direction", "payload": payload})
+                return
+            logger.info(
+                "nav.command publish intent=%s direction=%s speed=%s duration=%s payload=%s",
+                intent,
+                direction,
+                payload.get("speed"),
+                payload.get("duration"),
+                {"direction": direction, "source": "remote_app"},
+            )
+            publish_json(self.cmd_pub, TOPIC_NAV, {"direction": direction, "source": "remote_app"})
+            logger.info("remote_intent accepted intent=%s direction=%s", intent, direction)
+            self._publish_remote_event("accepted", {"intent": intent, "direction": direction})
+            return
+
+        logger.warning("remote_intent rejected reason=unsupported_intent payload=%s", payload)
+        self._publish_remote_event("rejected", {"reason": "unsupported_intent", "payload": payload})
+
+
+def main() -> None:
+    try:
+        Orchestrator().run()
+    except Exception as exc:
+        logger.error("Fatal error: %s", exc)
+        raise
+
+
+if __name__ == "__main__":
+    main()
diff --git a/src/piled/led_ring_service.py b/src/piled/led_ring_service.py
index 09aa79c..03f64d3 100644
--- a/src/piled/led_ring_service.py
+++ b/src/piled/led_ring_service.py
@@ -13,8 +13,6 @@ LED STATES (user-specified color scheme):
     thinking                 - PINK pulse (LLM processing)
     tts_processing           - ORANGE pulse (generating speech)
     speaking                 - Dark GREEN chase pattern (playing audio)
-    scanning                 - White/teal rotating sweep (360 scan)
-    gas_danger               - Red pulse (gas danger)
     error                    - RED blink (system error)
 
 DESIGN PRINCIPLE:
@@ -135,8 +133,6 @@ class LedAnimator:
         thinking                 - PINK pulse (LLM processing)
         tts_processing           - ORANGE pulse (generating speech)
         speaking                 - Dark GREEN chase pattern (playing audio)
-        scanning                 - White/teal rotating sweep (360 scan)
-        gas_danger               - Red pulse (gas danger)
         error                    - RED blink (system error)
     """
 
@@ -229,23 +225,6 @@ class LedAnimator:
                 colors.append((0, 30, 10))   # Very dim
         self.hw.show(colors)
 
-    def _render_scanning(self, now: float) -> None:
-        """SCANNING: Rotating teal/white sweep to show 360 scan."""
-        pos = int(now * 10) % self.hw.pixel_count
-        colors: list[RGB] = []
-        for idx in range(self.hw.pixel_count):
-            delta = min((idx - pos) % self.hw.pixel_count, (pos - idx) % self.hw.pixel_count)
-            fade = max(0.0, 1.0 - delta / 2.0)
-            base = int(50 + 205 * fade)
-            colors.append((base, base, int(180 * fade)))
-        self.hw.show(colors)
-
-    def _render_gas_danger(self, now: float) -> None:
-        """GAS DANGER: Strong red pulse for hazardous gas detection."""
-        phase = 0.5 + 0.5 * math.sin(now * 4)
-        level = int(80 + 175 * phase)
-        self.hw.fill((level, 0, 0))
-
     def _render_error(self, now: float) -> None:
         """ERROR: RED blink - something is wrong."""
         on = int(now * 4) % 2 == 0
diff --git a/src/remote/remote_interface.py b/src/remote/remote_interface.py
index 3a3de2e..2a1a765 100644
--- a/src/remote/remote_interface.py
+++ b/src/remote/remote_interface.py
@@ -1,559 +1,458 @@
-#!/usr/bin/env python3
-"""Remote supervision interface (read-only status + intent commands).
-
-Exposes HTTP endpoints bound to a private network address and translates
-remote intents into internal IPC topics for the orchestrator.
-"""
-from __future__ import annotations
-
-import json
-import time
-import threading
-import time
-from collections import deque
-from http.server import BaseHTTPRequestHandler, ThreadingHTTPServer
-from ipaddress import ip_address, ip_network
-from pathlib import Path
-from typing import Any, Dict, List, Optional
-from urllib.parse import urlparse, parse_qs
-
-import zmq
-
-from src.core.config_loader import load_config
-from src.core.ipc import (
-    TOPIC_CMD_VISION_MODE,
-    TOPIC_CMD_PAUSE_VISION,
-    TOPIC_DISPLAY_STATE,
-    TOPIC_DISPLAY_TEXT,
-    TOPIC_ESP,
-    TOPIC_HEALTH,
-    TOPIC_LLM_RESP,
-    TOPIC_REMOTE_EVENT,
-    TOPIC_REMOTE_INTENT,
-    TOPIC_REMOTE_SESSION,
-    TOPIC_TTS,
-    TOPIC_VISN,
-    TOPIC_VISN_CAPTURED,
-    TOPIC_VISN_FRAME,
-    make_publisher,
-    make_subscriber,
-    publish_json,
-)
-from src.core.logging_setup import get_logger
-
-
-class TelemetryState:
-    def __init__(self) -> None:
-        self.lock = threading.Lock()
-        self.display_state: str = "unknown"
-        self.display_text: str = ""
-        self.vision_mode: str = "off"
-        self.vision_paused: bool = False
-        self.last_detection: Optional[Dict[str, Any]] = None
-        self.detection_history: List[Dict[str, Any]] = []
-        self.last_esp: Optional[Dict[str, Any]] = None
-        self.last_alert: Optional[str] = None
-        self.last_health: Optional[Dict[str, Any]] = None
-        self.remote_session_active: bool = False
-        self.remote_last_seen: float = 0.0
-        self.last_remote_event: Optional[Dict[str, Any]] = None
-        self.last_capture: Optional[Dict[str, Any]] = None
-        self.last_llm_response: Optional[str] = None
-        self.last_llm_ts: Optional[float] = None
-        self.last_tts_text: Optional[str] = None
-        self.last_tts_status: Optional[str] = None
-        self.last_tts_ts: Optional[float] = None
-        self.last_scan_summary: Optional[str] = None
-        self.last_scan_ts: Optional[float] = None
-        self.gas_threshold: int = 800
-
-    def snapshot(self) -> Dict[str, Any]:
-        with self.lock:
-            safety_stop = False
-            motor_enabled: Optional[bool] = None
-            motor: Optional[Dict[str, Any]] = None
-            min_distance: Optional[int] = None
-            obstacle = False
-            warning = False
-            gas_level: Optional[int] = None
-            gas_warning = False
-            if self.last_esp and "data" in self.last_esp:
-                data = self.last_esp["data"] or {}
-                obstacle = bool(data.get("obstacle", False))
-                warning = bool(data.get("warning", False))
-                min_distance = data.get("min_distance")
-                gas_level = data.get("mq2")
-                try:
-                    gas_level = int(gas_level) if gas_level is not None else None
-                except Exception:
-                    gas_level = None
-                gas_warning = gas_level is not None and gas_level >= self.gas_threshold
-                is_safe = data.get("is_safe")
-                if isinstance(is_safe, bool):
-                    motor_enabled = is_safe
-                lmotor = data.get("lmotor")
-                rmotor = data.get("rmotor")
-                if lmotor is not None or rmotor is not None:
-                    motor = {
-                        "left": lmotor,
-                        "right": rmotor,
-                        "ts": self.last_esp.get("data_ts"),
-                    }
-            if obstacle or warning or (self.last_alert is not None):
-                safety_stop = True
-
-            stream_url = "/stream/mjpeg" if self.vision_mode == "on_with_stream" else None
-            return {
-                "remote_session_active": self.remote_session_active,
-                "remote_last_seen": int(self.remote_last_seen) if self.remote_last_seen else None,
-                "mode": self.display_state,
-                "display_text": self.display_text,
-                "vision_mode": self.vision_mode,
-                "stream_url": stream_url,
-                "vision_active": self.vision_mode != "off",
-                "vision_paused": self.vision_paused,
-                "motor_enabled": motor_enabled,
-                "motor": motor,
-                "safety_stop": safety_stop,
-                "safety_alert": self.last_alert,
-                "gas_level": gas_level,
-                "gas_warning": gas_warning,
-                "last_scan_summary": self.last_scan_summary,
-                "last_scan_ts": int(self.last_scan_ts) if self.last_scan_ts else None,
-                "sensor": self.last_esp.get("data") if self.last_esp else None,
-                "sensor_ts": self.last_esp.get("data_ts") if self.last_esp else None,
-                "sensor_buffer": self.last_esp.get("buffer") if self.last_esp else None,
-                "vision_last_detection": self.last_detection,
-                "detection_history": list(self.detection_history),
-                "last_capture": self.last_capture,
-                "last_llm_response": self.last_llm_response,
-                "last_llm_ts": int(self.last_llm_ts) if self.last_llm_ts else None,
-                "last_tts_text": self.last_tts_text,
-                "last_tts_status": self.last_tts_status,
-                "last_tts_ts": int(self.last_tts_ts) if self.last_tts_ts else None,
-                "health": self.last_health,
-                "remote_event": self.last_remote_event,
-            }
-
-
-class RemoteSupervisor:
-    def __init__(self, config_path: Path) -> None:
-        self.config = load_config(config_path)
-        log_dir = Path(self.config.get("logs", {}).get("directory", "logs"))
-        if not log_dir.is_absolute():
-            log_dir = Path.cwd() / log_dir
-        self.log_dir = log_dir
-        self.logger = get_logger("remote.interface", log_dir)
-
-        remote_cfg = self.config.get("remote_interface", {}) or {}
-        self.bind_host = remote_cfg.get("bind_host", "127.0.0.1")
-        self.bind_port = int(remote_cfg.get("port", 8770))
-        self.allowed_cidrs = self._parse_cidrs(remote_cfg.get("allowed_cidrs", ["100.64.0.0/10"]))
-        self.session_timeout_s = float(remote_cfg.get("session_timeout_s", 15.0))
-        self._detection_history_max = int(remote_cfg.get("detection_history_max", 200))
-        self.telemetry.gas_threshold = int(self.config.get("orchestrator", {}).get("gas_threshold", 800))
-
-        self.telemetry = TelemetryState()
-        self._ctx = zmq.Context.instance()
-        self._pub = make_publisher(self.config, channel="upstream")
-        self._sub_up = make_subscriber(self.config, channel="upstream")
-        self._sub_down = make_subscriber(self.config, channel="downstream")
-
-        # Subscribe to key telemetry topics
-        for topic in [
-            TOPIC_ESP,
-            TOPIC_VISN,
-            TOPIC_VISN_FRAME,
-            TOPIC_VISN_CAPTURED,
-            TOPIC_HEALTH,
-            TOPIC_LLM_RESP,
-            TOPIC_TTS,
-            TOPIC_REMOTE_EVENT,
-        ]:
-            self._sub_up.setsockopt(zmq.SUBSCRIBE, topic)
-
-        for topic in [
-            TOPIC_DISPLAY_STATE,
-            TOPIC_DISPLAY_TEXT,
-            TOPIC_CMD_VISION_MODE,
-            TOPIC_CMD_PAUSE_VISION,
-            TOPIC_VISN,
-            TOPIC_VISN_FRAME,
-            TOPIC_VISN_CAPTURED,
-            TOPIC_TTS,
-        ]:
-            self._sub_down.setsockopt(zmq.SUBSCRIBE, topic)
-
-        self._poller = zmq.Poller()
-        self._poller.register(self._sub_up, zmq.POLLIN)
-        self._poller.register(self._sub_down, zmq.POLLIN)
-
-        self._running = True
-        self._last_session_emit = False
-        self._stream_lock = threading.Condition()
-        self._latest_frame: Optional[bytes] = None
-        self._latest_frame_ts: float = 0.0
-        self._log_services = {
-            "remote_interface": ["remote.interface.log", "remote-interface.log"],
-            "orchestrator": ["orchestrator.log"],
-            "uart": ["uart.motor_bridge.log", "uart.bridge.log", "uart.log"],
-            "vision": ["vision.log", "vision.runner.log"],
-            "llm_tts": [
-                "llm.azure_openai.log",
-                "llm.gemini.log",
-                "llm.local.log",
-                "tts.azure.log",
-                "tts.piper.log",
-                "tts.log",
-            ],
-        }
-
-    def _tail_lines(self, path: Path, max_lines: int) -> List[str]:
-        if max_lines <= 0:
-            return []
-        try:
-            with path.open("r", encoding="utf-8", errors="ignore") as handle:
-                buffer = deque(handle, maxlen=max_lines)
-            return [line.rstrip("\n") for line in buffer]
-        except FileNotFoundError:
-            return []
-        except OSError:
-            return []
-
-    def _fetch_logs(self, service: str, max_lines: int) -> Optional[Dict[str, Any]]:
-        filenames = self._log_services.get(service)
-        if not filenames:
-            return None
-        files = []
-        for name in filenames:
-            path = self.log_dir / name
-            if path.exists():
-                files.append(path)
-        if not files:
-            return {
-                "service": service,
-                "lines": [],
-                "sources": [str(self.log_dir / name) for name in filenames],
-                "ts": int(time.time()),
-                "error": "log_files_missing",
-            }
-        merged: List[str] = []
-        sources: List[str] = []
-        for path in files:
-            sources.append(str(path))
-            lines = self._tail_lines(path, max_lines)
-            if len(files) > 1:
-                merged.extend([f"[{path.name}] {line}" for line in lines])
-            else:
-                merged.extend(lines)
-        return {
-            "service": service,
-            "lines": merged[-max_lines:],
-            "sources": sources,
-            "ts": int(time.time()),
-        }
-
-    @staticmethod
-    def _parse_cidrs(raw: Any) -> List[Any]:
-        cidrs = raw if isinstance(raw, list) else [raw]
-        nets = []
-        for entry in cidrs:
-            if not entry:
-                continue
-            try:
-                nets.append(ip_network(str(entry)))
-            except ValueError:
-                continue
-        return nets
-
-    def _client_allowed(self, client_ip: str) -> bool:
-        if not self.allowed_cidrs:
-            return True
-        try:
-            addr = ip_address(client_ip)
-        except ValueError:
-            return False
-        return any(addr in net for net in self.allowed_cidrs)
-
-    def _touch_session(self) -> None:
-        now = time.time()
-        with self.telemetry.lock:
-            self.telemetry.remote_last_seen = now
-            self.telemetry.remote_session_active = True
-
-    def _publish_session_state(self) -> None:
-        with self.telemetry.lock:
-            active = self.telemetry.remote_session_active
-            last_seen = self.telemetry.remote_last_seen
-        publish_json(
-            self._pub,
-            TOPIC_REMOTE_SESSION,
-            {
-                "active": bool(active),
-                "last_seen": int(last_seen) if last_seen else None,
-                "source": "remote_app",
-            },
-        )
-
-    def _session_watchdog(self) -> None:
-        while self._running:
-            now = time.time()
-            with self.telemetry.lock:
-                active = self.telemetry.remote_session_active
-                last_seen = self.telemetry.remote_last_seen
-            if active and last_seen and (now - last_seen) > self.session_timeout_s:
-                with self.telemetry.lock:
-                    self.telemetry.remote_session_active = False
-                self._publish_session_state()
-            time.sleep(1.0)
-
-    def _telemetry_loop(self) -> None:
-        while self._running:
-            events = dict(self._poller.poll(timeout=200))
-            if self._sub_up in events:
-                self._drain_socket(self._sub_up)
-            if self._sub_down in events:
-                self._drain_socket(self._sub_down)
-
-    def _drain_socket(self, sock: zmq.Socket) -> None:
-        while True:
-            try:
-                topic, raw = sock.recv_multipart(flags=zmq.NOBLOCK)
-            except zmq.Again:
-                break
-            if topic == TOPIC_VISN_FRAME:
-                with self._stream_lock:
-                    self._latest_frame = raw
-                    self._latest_frame_ts = time.time()
-                    self._stream_lock.notify_all()
-                continue
-
-            try:
-                payload = json.loads(raw)
-            except json.JSONDecodeError:
-                continue
-
-            with self.telemetry.lock:
-                if topic == TOPIC_DISPLAY_STATE:
-                    self.telemetry.display_state = str(payload.get("state", "unknown"))
-                elif topic == TOPIC_DISPLAY_TEXT:
-                    self.telemetry.display_text = str(payload.get("text", ""))
-                elif topic == TOPIC_CMD_VISION_MODE:
-                    self.telemetry.vision_mode = str(payload.get("mode", "off"))
-                elif topic == TOPIC_CMD_PAUSE_VISION:
-                    self.telemetry.vision_paused = bool(payload.get("pause", False))
-                elif topic == TOPIC_VISN:
-                    self.telemetry.last_detection = payload
-                    label = str(payload.get("label", ""))
-                    if label and label != "none":
-                        entry = {
-                            "label": label,
-                            "bbox": payload.get("bbox"),
-                            "confidence": payload.get("confidence"),
-                            "ts": payload.get("ts"),
-                        }
-                        self.telemetry.detection_history.append(entry)
-                        if len(self.telemetry.detection_history) > self._detection_history_max:
-                            self.telemetry.detection_history = self.telemetry.detection_history[-self._detection_history_max:]
-                elif topic == TOPIC_ESP:
-                    self.telemetry.last_esp = payload
-                    alert = payload.get("alert")
-                    if alert:
-                        self.telemetry.last_alert = str(alert)
-                    if payload.get("blocked"):
-                        self.telemetry.last_alert = str(payload.get("reason", "blocked"))
-                elif topic == TOPIC_HEALTH:
-                    self.telemetry.last_health = payload
-                elif topic == TOPIC_REMOTE_EVENT:
-                    self.telemetry.last_remote_event = payload
-                    if payload.get("event") == "scan_complete":
-                        summary = payload.get("summary")
-                        if summary:
-                            self.telemetry.last_scan_summary = str(summary)
-                            self.telemetry.last_scan_ts = payload.get("timestamp") or time.time()
-                elif topic == TOPIC_VISN_CAPTURED:
-                    self.telemetry.last_capture = payload
-                elif topic == TOPIC_LLM_RESP:
-                    body = payload.get("json") or {}
-                    speak = body.get("speak") or payload.get("text") or payload.get("raw")
-                    if speak:
-                        self.telemetry.last_llm_response = str(speak)[:240]
-                        self.telemetry.last_llm_ts = time.time()
-                elif topic == TOPIC_TTS:
-                    if payload.get("text"):
-                        self.telemetry.last_tts_text = str(payload.get("text"))[:240]
-                        self.telemetry.last_tts_status = "queued"
-                        self.telemetry.last_tts_ts = time.time()
-                    if payload.get("started"):
-                        self.telemetry.last_tts_status = "started"
-                        self.telemetry.last_tts_ts = time.time()
-                    if payload.get("done") or payload.get("final") or payload.get("completed"):
-                        self.telemetry.last_tts_status = "done"
-                        self.telemetry.last_tts_ts = time.time()
-
-    def serve(self) -> None:
-        threading.Thread(target=self._telemetry_loop, daemon=True).start()
-        threading.Thread(target=self._session_watchdog, daemon=True).start()
-
-        handler = self._make_handler()
-        server = ThreadingHTTPServer((self.bind_host, self.bind_port), handler)
-        self.logger.info("Remote interface listening on %s:%s", self.bind_host, self.bind_port)
-        try:
-            server.serve_forever()
-        except KeyboardInterrupt:
-            pass
-        finally:
-            self._running = False
-            server.server_close()
-
-    def _make_handler(self):
-        supervisor = self
-
-        class Handler(BaseHTTPRequestHandler):
-            def _send_json(self, code: int, payload: Dict[str, Any]) -> None:
-                data = json.dumps(payload).encode("utf-8")
-                self.send_response(code)
-                self.send_header("Content-Type", "application/json")
-                self.send_header("Content-Length", str(len(data)))
-                self.end_headers()
-                self.wfile.write(data)
-
-            def _read_json(self) -> Dict[str, Any]:
-                length = int(self.headers.get("Content-Length", "0"))
-                if length <= 0:
-                    return {}
-                raw = self.rfile.read(length)
-                try:
-                    return json.loads(raw)
-                except json.JSONDecodeError:
-                    supervisor.logger.warning("Remote interface received invalid JSON")
-                    return {}
-
-            def _allowed(self) -> bool:
-                client_ip = self.client_address[0]
-                if supervisor._client_allowed(client_ip):
-                    return True
-                supervisor.logger.warning("Remote interface rejected IP %s", client_ip)
-                return False
-
-            def do_GET(self) -> None:
-                if not self._allowed():
-                    self._send_json(403, {"error": "forbidden"})
-                    return
-                parsed = urlparse(self.path)
-                if parsed.path == "/stream/mjpeg":
-                    with supervisor.telemetry.lock:
-                        vision_mode = supervisor.telemetry.vision_mode
-                    if vision_mode != "on_with_stream":
-                        self._send_json(409, {"error": "stream_disabled"})
-                        return
-                    self.send_response(200)
-                    self.send_header("Content-Type", "multipart/x-mixed-replace; boundary=frame")
-                    self.send_header("Cache-Control", "no-cache")
-                    self.send_header("Connection", "close")
-                    self.end_headers()
-                    try:
-                        while True:
-                            with supervisor.telemetry.lock:
-                                if supervisor.telemetry.vision_mode != "on_with_stream":
-                                    break
-                            with supervisor._stream_lock:
-                                if supervisor._latest_frame is None:
-                                    supervisor._stream_lock.wait(timeout=1.0)
-                                frame = supervisor._latest_frame
-                            if frame is None:
-                                continue
-                            self.wfile.write(b"--frame\r\n")
-                            self.wfile.write(b"Content-Type: image/jpeg\r\n")
-                            self.wfile.write(f"Content-Length: {len(frame)}\r\n\r\n".encode("utf-8"))
-                            self.wfile.write(frame)
-                            self.wfile.write(b"\r\n")
-                            self.wfile.flush()
-                    except (BrokenPipeError, ConnectionResetError):
-                        return
-                    except Exception as exc:  # pragma: no cover - defensive
-                        supervisor.logger.info("Stream closed: %s", exc)
-                    return
-                if parsed.path in {"/status", "/telemetry"}:
-                    supervisor._touch_session()
-                    supervisor._publish_session_state()
-                    self._send_json(200, supervisor.telemetry.snapshot())
-                    return
-                if parsed.path == "/health":
-                    self._send_json(200, {"ok": True, "timestamp": int(time.time())})
-                    return
-                if parsed.path == "/logs":
-                    qs = parse_qs(parsed.query or "")
-                    service = (qs.get("service") or qs.get("name") or [None])[0]
-                    try:
-                        requested = int((qs.get("lines") or ["100"])[0])
-                    except ValueError:
-                        requested = 100
-                    max_lines = max(10, min(500, requested))
-                    if not service:
-                        self._send_json(200, {"services": list(supervisor._log_services.keys())})
-                        return
-                    payload = supervisor._fetch_logs(str(service), max_lines)
-                    if payload is None:
-                        self._send_json(404, {"error": "unknown_service"})
-                        return
-                    self._send_json(200, payload)
-                    return
-                log = getattr(supervisor, "logger", None)
-                if log:
-                    log.warning("/intent rejected reason=bad_path path=%s ts=%s", self.path, time.time())
-                self._send_json(404, {"error": "not_found"})
-
-            def do_POST(self) -> None:
-                if not self._allowed():
-                    log = getattr(supervisor, "logger", None)
-                    if log:
-                        log.warning("/intent rejected reason=forbidden ip=%s ts=%s", self.client_address[0], time.time())
-                    self._send_json(403, {"error": "forbidden"})
-                    return
-
-                if self.path == "/intent":
-                    payload = self._read_json()
-                    intent = str(payload.get("intent", "")).strip()
-                    if not intent:
-                        log = getattr(supervisor, "logger", None)
-                        if log:
-                            log.warning("/intent rejected reason=missing_intent ts=%s payload=%s", time.time(), payload)
-                        self._send_json(400, {"error": "missing_intent"})
-                        return
-
-                    supervisor._touch_session()
-                    supervisor._publish_session_state()
-
-                    intent_payload = {
-                        **payload,
-                        "intent": intent,
-                        "source": "remote_app",
-                        "timestamp": int(time.time()),
-                    }
-                    log = getattr(supervisor, "logger", None)
-                    if log:
-                        log.info("/intent received ts=%s payload=%s", time.time(), intent_payload)
-                        log.info("ipc publish topic=%s ts=%s", TOPIC_REMOTE_INTENT, time.time())
-                    publish_json(supervisor._pub, TOPIC_REMOTE_INTENT, intent_payload)
-                    self._send_json(202, {"accepted": True, "intent": intent})
-                    return
-
-                log = getattr(supervisor, "logger", None)
-                if log:
-                    log.warning("/intent rejected reason=bad_path path=%s ts=%s", self.path, time.time())
-                self._send_json(404, {"error": "not_found"})
-
-            def log_message(self, format: str, *args) -> None:
-                supervisor.logger.info("remote.http %s - %s", self.client_address[0], format % args)
-
-        return Handler
-
-
-def main() -> None:
-    supervisor = RemoteSupervisor(Path("config/system.yaml"))
-    supervisor.serve()
-
-
-if __name__ == "__main__":
-    main()
+#!/usr/bin/env python3
+"""Remote supervision interface (read-only status + intent commands).
+
+Exposes HTTP endpoints bound to a private network address and translates
+remote intents into internal IPC topics for the orchestrator.
+"""
+from __future__ import annotations
+
+import json
+import time
+import threading
+import time
+from http.server import BaseHTTPRequestHandler, ThreadingHTTPServer
+from ipaddress import ip_address, ip_network
+from pathlib import Path
+from typing import Any, Dict, List, Optional
+
+import zmq
+
+from src.core.config_loader import load_config
+from src.core.ipc import (
+    TOPIC_CMD_VISION_MODE,
+    TOPIC_CMD_PAUSE_VISION,
+    TOPIC_DISPLAY_STATE,
+    TOPIC_DISPLAY_TEXT,
+    TOPIC_ESP,
+    TOPIC_HEALTH,
+    TOPIC_LLM_RESP,
+    TOPIC_REMOTE_EVENT,
+    TOPIC_REMOTE_INTENT,
+    TOPIC_REMOTE_SESSION,
+    TOPIC_TTS,
+    TOPIC_VISN,
+    TOPIC_VISN_CAPTURED,
+    TOPIC_VISN_FRAME,
+    make_publisher,
+    make_subscriber,
+    publish_json,
+)
+from src.core.logging_setup import get_logger
+
+
+class TelemetryState:
+    def __init__(self) -> None:
+        self.lock = threading.Lock()
+        self.display_state: str = "unknown"
+        self.display_text: str = ""
+        self.vision_mode: str = "off"
+        self.vision_paused: bool = False
+        self.last_detection: Optional[Dict[str, Any]] = None
+        self.detection_history: List[Dict[str, Any]] = []
+        self.last_esp: Optional[Dict[str, Any]] = None
+        self.last_alert: Optional[str] = None
+        self.last_health: Optional[Dict[str, Any]] = None
+        self.remote_session_active: bool = False
+        self.remote_last_seen: float = 0.0
+        self.last_remote_event: Optional[Dict[str, Any]] = None
+        self.last_capture: Optional[Dict[str, Any]] = None
+        self.last_llm_response: Optional[str] = None
+        self.last_llm_ts: Optional[float] = None
+        self.last_tts_text: Optional[str] = None
+        self.last_tts_status: Optional[str] = None
+        self.last_tts_ts: Optional[float] = None
+
+    def snapshot(self) -> Dict[str, Any]:
+        with self.lock:
+            safety_stop = False
+            motor_enabled: Optional[bool] = None
+            motor: Optional[Dict[str, Any]] = None
+            min_distance: Optional[int] = None
+            obstacle = False
+            warning = False
+            if self.last_esp and "data" in self.last_esp:
+                data = self.last_esp["data"] or {}
+                obstacle = bool(data.get("obstacle", False))
+                warning = bool(data.get("warning", False))
+                min_distance = data.get("min_distance")
+                is_safe = data.get("is_safe")
+                if isinstance(is_safe, bool):
+                    motor_enabled = is_safe
+                lmotor = data.get("lmotor")
+                rmotor = data.get("rmotor")
+                if lmotor is not None or rmotor is not None:
+                    motor = {
+                        "left": lmotor,
+                        "right": rmotor,
+                        "ts": self.last_esp.get("data_ts"),
+                    }
+            if obstacle or warning or (self.last_alert is not None):
+                safety_stop = True
+
+            stream_url = "/stream/mjpeg" if self.vision_mode == "on_with_stream" else None
+            return {
+                "remote_session_active": self.remote_session_active,
+                "remote_last_seen": int(self.remote_last_seen) if self.remote_last_seen else None,
+                "mode": self.display_state,
+                "display_text": self.display_text,
+                "vision_mode": self.vision_mode,
+                "stream_url": stream_url,
+                "vision_active": self.vision_mode != "off",
+                "vision_paused": self.vision_paused,
+                "motor_enabled": motor_enabled,
+                "motor": motor,
+                "safety_stop": safety_stop,
+                "safety_alert": self.last_alert,
+                "sensor": self.last_esp.get("data") if self.last_esp else None,
+                "sensor_ts": self.last_esp.get("data_ts") if self.last_esp else None,
+                "sensor_buffer": self.last_esp.get("buffer") if self.last_esp else None,
+                "vision_last_detection": self.last_detection,
+                "detection_history": list(self.detection_history),
+                "last_capture": self.last_capture,
+                "last_llm_response": self.last_llm_response,
+                "last_llm_ts": int(self.last_llm_ts) if self.last_llm_ts else None,
+                "last_tts_text": self.last_tts_text,
+                "last_tts_status": self.last_tts_status,
+                "last_tts_ts": int(self.last_tts_ts) if self.last_tts_ts else None,
+                "health": self.last_health,
+                "remote_event": self.last_remote_event,
+            }
+
+
+class RemoteSupervisor:
+    def __init__(self, config_path: Path) -> None:
+        self.config = load_config(config_path)
+        log_dir = Path(self.config.get("logs", {}).get("directory", "logs"))
+        if not log_dir.is_absolute():
+            log_dir = Path.cwd() / log_dir
+        self.logger = get_logger("remote.interface", log_dir)
+
+        remote_cfg = self.config.get("remote_interface", {}) or {}
+        self.bind_host = remote_cfg.get("bind_host", "127.0.0.1")
+        self.bind_port = int(remote_cfg.get("port", 8770))
+        self.allowed_cidrs = self._parse_cidrs(remote_cfg.get("allowed_cidrs", ["100.64.0.0/10"]))
+        self.session_timeout_s = float(remote_cfg.get("session_timeout_s", 15.0))
+        self._detection_history_max = int(remote_cfg.get("detection_history_max", 200))
+
+        self.telemetry = TelemetryState()
+        self._ctx = zmq.Context.instance()
+        self._pub = make_publisher(self.config, channel="upstream")
+        self._sub_up = make_subscriber(self.config, channel="upstream")
+        self._sub_down = make_subscriber(self.config, channel="downstream")
+
+        # Subscribe to key telemetry topics
+        for topic in [
+            TOPIC_ESP,
+            TOPIC_VISN,
+            TOPIC_VISN_FRAME,
+            TOPIC_VISN_CAPTURED,
+            TOPIC_HEALTH,
+            TOPIC_LLM_RESP,
+            TOPIC_TTS,
+            TOPIC_REMOTE_EVENT,
+        ]:
+            self._sub_up.setsockopt(zmq.SUBSCRIBE, topic)
+
+        for topic in [
+            TOPIC_DISPLAY_STATE,
+            TOPIC_DISPLAY_TEXT,
+            TOPIC_CMD_VISION_MODE,
+            TOPIC_CMD_PAUSE_VISION,
+            TOPIC_VISN,
+            TOPIC_VISN_FRAME,
+            TOPIC_VISN_CAPTURED,
+            TOPIC_TTS,
+        ]:
+            self._sub_down.setsockopt(zmq.SUBSCRIBE, topic)
+
+        self._poller = zmq.Poller()
+        self._poller.register(self._sub_up, zmq.POLLIN)
+        self._poller.register(self._sub_down, zmq.POLLIN)
+
+        self._running = True
+        self._last_session_emit = False
+        self._stream_lock = threading.Condition()
+        self._latest_frame: Optional[bytes] = None
+        self._latest_frame_ts: float = 0.0
+
+    @staticmethod
+    def _parse_cidrs(raw: Any) -> List[Any]:
+        cidrs = raw if isinstance(raw, list) else [raw]
+        nets = []
+        for entry in cidrs:
+            if not entry:
+                continue
+            try:
+                nets.append(ip_network(str(entry)))
+            except ValueError:
+                continue
+        return nets
+
+    def _client_allowed(self, client_ip: str) -> bool:
+        if not self.allowed_cidrs:
+            return True
+        try:
+            addr = ip_address(client_ip)
+        except ValueError:
+            return False
+        return any(addr in net for net in self.allowed_cidrs)
+
+    def _touch_session(self) -> None:
+        now = time.time()
+        with self.telemetry.lock:
+            self.telemetry.remote_last_seen = now
+            self.telemetry.remote_session_active = True
+
+    def _publish_session_state(self) -> None:
+        with self.telemetry.lock:
+            active = self.telemetry.remote_session_active
+            last_seen = self.telemetry.remote_last_seen
+        publish_json(
+            self._pub,
+            TOPIC_REMOTE_SESSION,
+            {
+                "active": bool(active),
+                "last_seen": int(last_seen) if last_seen else None,
+                "source": "remote_app",
+            },
+        )
+
+    def _session_watchdog(self) -> None:
+        while self._running:
+            now = time.time()
+            with self.telemetry.lock:
+                active = self.telemetry.remote_session_active
+                last_seen = self.telemetry.remote_last_seen
+            if active and last_seen and (now - last_seen) > self.session_timeout_s:
+                with self.telemetry.lock:
+                    self.telemetry.remote_session_active = False
+                self._publish_session_state()
+            time.sleep(1.0)
+
+    def _telemetry_loop(self) -> None:
+        while self._running:
+            events = dict(self._poller.poll(timeout=200))
+            if self._sub_up in events:
+                self._drain_socket(self._sub_up)
+            if self._sub_down in events:
+                self._drain_socket(self._sub_down)
+
+    def _drain_socket(self, sock: zmq.Socket) -> None:
+        while True:
+            try:
+                topic, raw = sock.recv_multipart(flags=zmq.NOBLOCK)
+            except zmq.Again:
+                break
+            if topic == TOPIC_VISN_FRAME:
+                with self._stream_lock:
+                    self._latest_frame = raw
+                    self._latest_frame_ts = time.time()
+                    self._stream_lock.notify_all()
+                continue
+
+            try:
+                payload = json.loads(raw)
+            except json.JSONDecodeError:
+                continue
+
+            with self.telemetry.lock:
+                if topic == TOPIC_DISPLAY_STATE:
+                    self.telemetry.display_state = str(payload.get("state", "unknown"))
+                elif topic == TOPIC_DISPLAY_TEXT:
+                    self.telemetry.display_text = str(payload.get("text", ""))
+                elif topic == TOPIC_CMD_VISION_MODE:
+                    self.telemetry.vision_mode = str(payload.get("mode", "off"))
+                elif topic == TOPIC_CMD_PAUSE_VISION:
+                    self.telemetry.vision_paused = bool(payload.get("pause", False))
+                elif topic == TOPIC_VISN:
+                    self.telemetry.last_detection = payload
+                    label = str(payload.get("label", ""))
+                    if label and label != "none":
+                        entry = {
+                            "label": label,
+                            "bbox": payload.get("bbox"),
+                            "confidence": payload.get("confidence"),
+                            "ts": payload.get("ts"),
+                        }
+                        self.telemetry.detection_history.append(entry)
+                        if len(self.telemetry.detection_history) > self._detection_history_max:
+                            self.telemetry.detection_history = self.telemetry.detection_history[-self._detection_history_max:]
+                elif topic == TOPIC_ESP:
+                    self.telemetry.last_esp = payload
+                    alert = payload.get("alert")
+                    if alert:
+                        self.telemetry.last_alert = str(alert)
+                    if payload.get("blocked"):
+                        self.telemetry.last_alert = str(payload.get("reason", "blocked"))
+                elif topic == TOPIC_HEALTH:
+                    self.telemetry.last_health = payload
+                elif topic == TOPIC_REMOTE_EVENT:
+                    self.telemetry.last_remote_event = payload
+                elif topic == TOPIC_VISN_CAPTURED:
+                    self.telemetry.last_capture = payload
+                elif topic == TOPIC_LLM_RESP:
+                    body = payload.get("json") or {}
+                    speak = body.get("speak") or payload.get("text") or payload.get("raw")
+                    if speak:
+                        self.telemetry.last_llm_response = str(speak)[:240]
+                        self.telemetry.last_llm_ts = time.time()
+                elif topic == TOPIC_TTS:
+                    if payload.get("text"):
+                        self.telemetry.last_tts_text = str(payload.get("text"))[:240]
+                        self.telemetry.last_tts_status = "queued"
+                        self.telemetry.last_tts_ts = time.time()
+                    if payload.get("started"):
+                        self.telemetry.last_tts_status = "started"
+                        self.telemetry.last_tts_ts = time.time()
+                    if payload.get("done") or payload.get("final") or payload.get("completed"):
+                        self.telemetry.last_tts_status = "done"
+                        self.telemetry.last_tts_ts = time.time()
+
+    def serve(self) -> None:
+        threading.Thread(target=self._telemetry_loop, daemon=True).start()
+        threading.Thread(target=self._session_watchdog, daemon=True).start()
+
+        handler = self._make_handler()
+        server = ThreadingHTTPServer((self.bind_host, self.bind_port), handler)
+        self.logger.info("Remote interface listening on %s:%s", self.bind_host, self.bind_port)
+        try:
+            server.serve_forever()
+        except KeyboardInterrupt:
+            pass
+        finally:
+            self._running = False
+            server.server_close()
+
+    def _make_handler(self):
+        supervisor = self
+
+        class Handler(BaseHTTPRequestHandler):
+            def _send_json(self, code: int, payload: Dict[str, Any]) -> None:
+                data = json.dumps(payload).encode("utf-8")
+                self.send_response(code)
+                self.send_header("Content-Type", "application/json")
+                self.send_header("Content-Length", str(len(data)))
+                self.end_headers()
+                self.wfile.write(data)
+
+            def _read_json(self) -> Dict[str, Any]:
+                length = int(self.headers.get("Content-Length", "0"))
+                if length <= 0:
+                    return {}
+                raw = self.rfile.read(length)
+                try:
+                    return json.loads(raw)
+                except json.JSONDecodeError:
+                    supervisor.logger.warning("Remote interface received invalid JSON")
+                    return {}
+
+            def _allowed(self) -> bool:
+                client_ip = self.client_address[0]
+                if supervisor._client_allowed(client_ip):
+                    return True
+                supervisor.logger.warning("Remote interface rejected IP %s", client_ip)
+                return False
+
+            def do_GET(self) -> None:
+                if not self._allowed():
+                    self._send_json(403, {"error": "forbidden"})
+                    return
+                if self.path == "/stream/mjpeg":
+                    with supervisor.telemetry.lock:
+                        vision_mode = supervisor.telemetry.vision_mode
+                    if vision_mode != "on_with_stream":
+                        self._send_json(409, {"error": "stream_disabled"})
+                        return
+                    self.send_response(200)
+                    self.send_header("Content-Type", "multipart/x-mixed-replace; boundary=frame")
+                    self.send_header("Cache-Control", "no-cache")
+                    self.send_header("Connection", "close")
+                    self.end_headers()
+                    try:
+                        while True:
+                            with supervisor.telemetry.lock:
+                                if supervisor.telemetry.vision_mode != "on_with_stream":
+                                    break
+                            with supervisor._stream_lock:
+                                if supervisor._latest_frame is None:
+                                    supervisor._stream_lock.wait(timeout=1.0)
+                                frame = supervisor._latest_frame
+                            if frame is None:
+                                continue
+                            self.wfile.write(b"--frame\r\n")
+                            self.wfile.write(b"Content-Type: image/jpeg\r\n")
+                            self.wfile.write(f"Content-Length: {len(frame)}\r\n\r\n".encode("utf-8"))
+                            self.wfile.write(frame)
+                            self.wfile.write(b"\r\n")
+                            self.wfile.flush()
+                    except (BrokenPipeError, ConnectionResetError):
+                        return
+                    except Exception as exc:  # pragma: no cover - defensive
+                        supervisor.logger.info("Stream closed: %s", exc)
+                    return
+                if self.path in {"/status", "/telemetry"}:
+                    supervisor._touch_session()
+                    supervisor._publish_session_state()
+                    self._send_json(200, supervisor.telemetry.snapshot())
+                    return
+                if self.path == "/health":
+                    self._send_json(200, {"ok": True, "timestamp": int(time.time())})
+                    return
+                log = getattr(supervisor, "logger", None)
+                if log:
+                    log.warning("/intent rejected reason=bad_path path=%s ts=%s", self.path, time.time())
+                self._send_json(404, {"error": "not_found"})
+
+            def do_POST(self) -> None:
+                if not self._allowed():
+                    log = getattr(supervisor, "logger", None)
+                    if log:
+                        log.warning("/intent rejected reason=forbidden ip=%s ts=%s", self.client_address[0], time.time())
+                    self._send_json(403, {"error": "forbidden"})
+                    return
+
+                if self.path == "/intent":
+                    payload = self._read_json()
+                    intent = str(payload.get("intent", "")).strip()
+                    if not intent:
+                        log = getattr(supervisor, "logger", None)
+                        if log:
+                            log.warning("/intent rejected reason=missing_intent ts=%s payload=%s", time.time(), payload)
+                        self._send_json(400, {"error": "missing_intent"})
+                        return
+
+                    supervisor._touch_session()
+                    supervisor._publish_session_state()
+
+                    intent_payload = {
+                        **payload,
+                        "intent": intent,
+                        "source": "remote_app",
+                        "timestamp": int(time.time()),
+                    }
+                    log = getattr(supervisor, "logger", None)
+                    if log:
+                        log.info("/intent received ts=%s payload=%s", time.time(), intent_payload)
+                        log.info("ipc publish topic=%s ts=%s", TOPIC_REMOTE_INTENT, time.time())
+                    publish_json(supervisor._pub, TOPIC_REMOTE_INTENT, intent_payload)
+                    self._send_json(202, {"accepted": True, "intent": intent})
+                    return
+
+                log = getattr(supervisor, "logger", None)
+                if log:
+                    log.warning("/intent rejected reason=bad_path path=%s ts=%s", self.path, time.time())
+                self._send_json(404, {"error": "not_found"})
+
+            def log_message(self, format: str, *args) -> None:
+                supervisor.logger.info("remote.http %s - %s", self.client_address[0], format % args)
+
+        return Handler
+
+
+def main() -> None:
+    supervisor = RemoteSupervisor(Path("config/system.yaml"))
+    supervisor.serve()
+
+
+if __name__ == "__main__":
+    main()
diff --git a/src/uart/motor_bridge.py b/src/uart/motor_bridge.py
index d5568c8..e757995 100644
--- a/src/uart/motor_bridge.py
+++ b/src/uart/motor_bridge.py
@@ -1,552 +1,552 @@
-#!/usr/bin/env python3
-"""Enhanced UART bridge with bidirectional communication and ESP32 feedback.
-
-Supports:
-- Sending navigation commands to ESP32 motor controller
-- Receiving status/sensor feedback from ESP32
-- Speed control and duration parameters
-- Emergency stop handling
-"""
-from __future__ import annotations
-
-import argparse
-import json
-import threading
-import time
-from collections import deque
-from dataclasses import dataclass
-from pathlib import Path
-from queue import Queue
-from typing import Any, Dict, Optional
-
-from src.core.config_loader import load_config
-from src.core.ipc import (
-    TOPIC_ESP,
-    TOPIC_NAV,
-    make_publisher,
-    make_subscriber,
-    publish_json,
-)
-from src.core.logging_setup import get_logger
-
-import zmq
-
-try:
-    import serial
-    SERIAL_AVAILABLE = True
-except ImportError:
-    serial = None
-    SERIAL_AVAILABLE = False
-
-logger = get_logger("uart.motor_bridge", Path("logs"))
-
-
-@dataclass
-class MotorCommand:
-    """Motor control command structure."""
-    direction: str  # forward, backward, left, right, stop
-    speed: int = 100  # 0-100 percentage
-    duration_ms: int = 0  # 0 = continuous until next command
-    target: Optional[str] = None  # optional vision target
-    source: str = "unknown"
-
-
-@dataclass
-class SensorData:
-    """Parsed sensor data from ESP32."""
-    s1: int = -1  # Sensor 1 distance (cm)
-    s2: int = -1  # Sensor 2 distance (cm)
-    s3: int = -1  # Sensor 3 distance (cm)
-    mq2: int = 0  # Gas sensor value
-    lmotor: int = 0  # Left motor power
-    rmotor: int = 0  # Right motor power
-    obstacle: bool = False  # ESP32 detected obstacle
-    warning: bool = False   # ESP32 in warning zone
-    
-    @property
-    def min_distance(self) -> int:
-        """Get minimum valid distance from all sensors."""
-        valid = [d for d in [self.s1, self.s2, self.s3] if d > 0]
-        return min(valid) if valid else -1
-    
-    @property
-    def is_safe(self) -> bool:
-        """Check if it's safe to move forward."""
-        return not self.obstacle and not self.warning and self.min_distance > 20
-
-
-class UARTMotorBridge:
-    """Bidirectional UART bridge for ESP32 motor control with collision avoidance."""
-
-    # Safety thresholds (backup to ESP32 safety)
-    STOP_DISTANCE_CM = 10
-    WARNING_DISTANCE_CM = 20
-
-    # Default command mapping (can be overridden from config)
-    # Align with ESP32 sketch command tokens in esp-code.ino
-    DEFAULT_COMMANDS = {
-        "forward": "FORWARD",
-        "backward": "BACKWARD",
-        "left": "LEFT",
-        "right": "RIGHT",
-        "stop": "STOP",
-        "status": "STATUS",
-        "reset": "RESET",
-        "scan": "SCAN",
-        "clearblock": "CLEARBLOCK",
-    }
-
-    def __init__(self, config: Dict[str, Any], sim: bool = False):
-        self.config = config
-        self.sim = sim
-        nav_cfg = config.get("nav", {})
-
-        self.device = nav_cfg.get("uart_device", "/dev/ttyAMA0")
-        self.baud = int(nav_cfg.get("baud_rate", 115200))
-        self.timeout = float(nav_cfg.get("timeout", 1.0))
-        self.commands = {**self.DEFAULT_COMMANDS, **nav_cfg.get("commands", {})}
-
-        self.serial: Optional[serial.Serial] = None
-        self._running = False
-        self._rx_queue: Queue = Queue()
-        self._rx_thread: Optional[threading.Thread] = None
-
-        # IPC sockets
-        self.sub: Optional[Any] = None
-        self.pub: Optional[Any] = None
-        
-        # Safety state (Pi-side backup)
-        self._last_sensor_data: Optional[SensorData] = None
-        self._blocked_reason: Optional[str] = None
-        self._scan_in_progress = False
-        self._scan_results: list = []
-        self._sensor_buffer = deque(maxlen=int(nav_cfg.get("sensor_buffer_size", 50)))
-        self._last_rx_log_ts: float = 0.0
-
-    def _open_serial(self) -> bool:
-        """Open serial port connection."""
-        if self.sim:
-            logger.info("UART simulation mode - no serial port opened")
-            return True
-
-        if not SERIAL_AVAILABLE:
-            logger.error("pyserial not installed")
-            return False
-
-        try:
-            self.serial = serial.Serial(
-                port=self.device,
-                baudrate=self.baud,
-                timeout=self.timeout,
-                write_timeout=self.timeout,
-            )
-            logger.info("UART opened: %s @ %d baud", self.device, self.baud)
-            return True
-        except Exception as e:
-            logger.error("Failed to open UART %s: %s", self.device, e)
-            return False
-
-    def _close_serial(self) -> None:
-        """Close serial port."""
-        if self.serial:
-            try:
-                self.serial.close()
-            except Exception:
-                pass
-            self.serial = None
-
-    def _format_command(self, cmd: MotorCommand) -> str:
-        """Format command for ESP32 protocol (esp-code.ino).
-
-        Supported tokens:
-          - FORWARD, BACKWARD, LEFT, RIGHT, STOP, STATUS, RESET
-          - SCAN - 360 degree environment scan
-          - CLEARBLOCK - Clear obstacle block (manual override)
-          - SERVO:<angle> (when target field is used as angle)
-
-        Notes:
-          - The current .ino ignores speed/duration for basic moves; commands
-            are digital full-speed. We emit plain tokens accordingly.
-        """
-        direction = (cmd.direction or "").lower()
-        if direction == "servo":
-            # Use cmd.target to pass the angle when requested
-            try:
-                angle = int(cmd.target) if cmd.target is not None else 90
-            except Exception:
-                angle = 90
-            return f"SERVO:{angle}\n"
-
-        base_cmd = self.commands.get(direction, None)
-        if not base_cmd:
-            # Fallback to STOP if unknown
-            base_cmd = "STOP"
-        return f"{base_cmd}\n"
-    
-    def _parse_sensor_data(self, data_raw: str) -> Optional[SensorData]:
-        """Parse DATA line from ESP32 into SensorData object.
-        
-        Format: S1:<d1>,S2:<d2>,S3:<d3>,MQ2:<v>,SERVO:<a>,LMOTOR:<ls>,RMOTOR:<rs>,OBSTACLE:<0|1>,WARNING:<0|1>
-        """
-        try:
-            parts = data_raw.split(",")
-            data = SensorData()
-            for part in parts:
-                if ":" not in part:
-                    continue
-                key, val = part.split(":", 1)
-                key = key.strip().upper()
-                val = val.strip()
-                if key == "S1":
-                    data.s1 = int(val)
-                elif key == "S2":
-                    data.s2 = int(val)
-                elif key == "S3":
-                    data.s3 = int(val)
-                elif key == "MQ2":
-                    data.mq2 = int(val)
-                elif key == "LMOTOR":
-                    data.lmotor = int(val)
-                elif key == "RMOTOR":
-                    data.rmotor = int(val)
-                elif key == "OBSTACLE":
-                    data.obstacle = val == "1"
-                elif key == "WARNING":
-                    data.warning = val == "1"
-            return data
-        except Exception as e:
-            logger.warning("Failed to parse sensor data: %s - %s", data_raw, e)
-            return None
-    
-    def _check_pi_side_safety(self, cmd: MotorCommand) -> tuple[bool, str]:
-        """Pi-side safety check as backup to ESP32.
-        
-        Returns (allowed, reason) tuple.
-        """
-        direction = (cmd.direction or "").lower()
-        
-        # Always allow stop, backward, turns, and non-movement commands
-        if direction in ("stop", "backward", "left", "right", "status", "reset", "scan", "clearblock", "servo"):
-            return True, ""
-        
-        # For forward, check sensor data
-        if direction == "forward" and self._last_sensor_data:
-            sd = self._last_sensor_data
-            if sd.obstacle:
-                return False, "ESP32 obstacle detected"
-            if sd.warning:
-                return False, "ESP32 warning zone"
-            if sd.min_distance > 0 and sd.min_distance < self.STOP_DISTANCE_CM:
-                return False, f"Pi safety: distance {sd.min_distance}cm < {self.STOP_DISTANCE_CM}cm"
-            if sd.min_distance > 0 and sd.min_distance < self.WARNING_DISTANCE_CM:
-                return False, f"Pi safety: warning zone {sd.min_distance}cm"
-        
-        return True, ""
-
-    def _send_command(self, cmd: MotorCommand) -> bool:
-        """Send command to ESP32 with Pi-side safety check."""
-        # Pi-side safety check (backup to ESP32)
-        allowed, reason = self._check_pi_side_safety(cmd)
-        if not allowed:
-            logger.warning("Command %s BLOCKED by Pi safety: %s", cmd.direction, reason)
-            self._blocked_reason = reason
-            # Publish blocked status
-            if self.pub:
-                publish_json(self.pub, TOPIC_ESP, {
-                    "blocked": True,
-                    "command": cmd.direction,
-                    "reason": reason,
-                    "source": cmd.source,
-                })
-            return False
-        
-        self._blocked_reason = None
-        formatted = self._format_command(cmd)
-
-        if self.sim:
-            logger.info("UART TX payload (sim) direction=%s speed=%s duration_ms=%s target=%s source=%s formatted=%s",
-                        cmd.direction,
-                        cmd.speed,
-                        cmd.duration_ms,
-                        cmd.target,
-                        cmd.source,
-                        formatted.strip())
-            logger.info("[SIM] UART TX: %s", formatted.strip())
-            return True
-
-        if not self.serial or not self.serial.is_open:
-            logger.error("Serial port not open")
-            return False
-
-        try:
-            logger.info(
-                "UART TX payload direction=%s speed=%s duration_ms=%s target=%s source=%s formatted=%s",
-                cmd.direction,
-                cmd.speed,
-                cmd.duration_ms,
-                cmd.target,
-                cmd.source,
-                formatted.strip(),
-            )
-            self.serial.write(formatted.encode("utf-8"))
-            self.serial.flush()
-            logger.info("UART TX: %s (source=%s)", formatted.strip(), cmd.source)
-            return True
-        except Exception as e:
-            logger.error("UART write failed: %s", e)
-            return False
-
-    def _rx_loop(self) -> None:
-        """Background thread for reading ESP32 responses."""
-        while self._running:
-            if self.sim:
-                time.sleep(0.1)
-                continue
-
-            if not self.serial or not self.serial.is_open:
-                time.sleep(0.1)
-                continue
-
-            try:
-                if self.serial.in_waiting > 0:
-                    line = self.serial.readline().decode("utf-8", errors="replace").strip()
-                    if line:
-                        self._rx_queue.put(line)
-                        logger.debug("UART RX: %s", line)
-                else:
-                    # Brief sleep to prevent busy-spin when no data
-                    time.sleep(0.005)  # 5ms - balance responsiveness vs CPU
-            except Exception as e:
-                logger.warning("UART read error: %s", e)
-                time.sleep(0.1)
-
-    def _process_rx(self) -> None:
-        """Process received data from ESP32 and publish to IPC."""
-        while not self._rx_queue.empty():
-            try:
-                line = self._rx_queue.get_nowait()
-                now = time.time()
-                if now - self._last_rx_log_ts >= 1.0:
-                    logger.info("UART RX sample: %s", line)
-                    self._last_rx_log_ts = now
-                # Parse ESP32 feedback (expected format: STATUS:value or JSON)
-                if line.startswith("{"):
-                    # JSON response (future extension)
-                    payload = json.loads(line)
-                else:
-                    # Parse ACK/STATUS and sensor data formats from esp-code.ino
-                    # Examples:
-                    #   ACK:<CMD>:<STATUS>
-                    #   STATUS:SERVO:<angle>,LMOTOR:<ls>,RMOTOR:<rs>
-                    #   DATA:S1:<d1>,S2:<d2>,S3:<d3>,MQ2:<v>,SERVO:<a>,LMOTOR:<ls>,RMOTOR:<rs>,OBSTACLE:<0|1>,WARNING:<0|1>
-                    #   ALERT:COLLISION:<reason>,S1:<d1>,S2:<d2>,S3:<d3>
-                    #   SCAN:START|COMPLETE|POS:<angle>|BEST:<angle>
-                    parts = line.split(":")
-                    if not parts:
-                        payload = {"raw": line}
-                    elif parts[0] == "ACK" and len(parts) >= 3:
-                        payload = {"ack": parts[1], "status": ":".join(parts[2:])}
-                        # Check if forward was blocked by ESP32
-                        if parts[1] == "FORWARD" and "BLOCKED" in parts[2]:
-                            logger.warning("ESP32 blocked FORWARD: %s", parts[2])
-                    elif parts[0] == "STATUS":
-                        payload = {"status_raw": ":".join(parts[1:])}
-                    elif parts[0] == "DATA":
-                        data_raw = ":".join(parts[1:])
-                        sensor_data = self._parse_sensor_data(data_raw)
-                        if sensor_data:
-                            self._last_sensor_data = sensor_data
-                            ts = int(time.time())
-                            frame = {
-                                "ts": ts,
-                                "s1": sensor_data.s1,
-                                "s2": sensor_data.s2,
-                                "s3": sensor_data.s3,
-                                "mq2": sensor_data.mq2,
-                                "lmotor": sensor_data.lmotor,
-                                "rmotor": sensor_data.rmotor,
-                                "min_distance": sensor_data.min_distance,
-                                "obstacle": sensor_data.obstacle,
-                                "warning": sensor_data.warning,
-                                "is_safe": sensor_data.is_safe,
-                            }
-                            self._sensor_buffer.append(frame)
-                            payload = {
-                                "data": {
-                                    "s1": sensor_data.s1,
-                                    "s2": sensor_data.s2,
-                                    "s3": sensor_data.s3,
-                                    "mq2": sensor_data.mq2,
-                                    "lmotor": sensor_data.lmotor,
-                                    "rmotor": sensor_data.rmotor,
-                                    "min_distance": sensor_data.min_distance,
-                                    "obstacle": sensor_data.obstacle,
-                                    "warning": sensor_data.warning,
-                                    "is_safe": sensor_data.is_safe,
-                                },
-                                "data_ts": ts,
-                                "buffer": list(self._sensor_buffer),
-                            }
-                        else:
-                            payload = {"data_raw": data_raw}
-                    elif parts[0] == "ALERT" and len(parts) >= 2:
-                        # Handle collision alerts
-                        alert_type = parts[1] if len(parts) > 1 else "UNKNOWN"
-                        alert_data = ":".join(parts[2:]) if len(parts) > 2 else ""
-                        payload = {"alert": alert_type, "alert_data": alert_data}
-                        logger.warning("ESP32 ALERT: %s - %s", alert_type, alert_data)
-                        # Emergency stop on Pi side too
-                        if alert_type == "COLLISION" and "EMERGENCY" in alert_data:
-                            logger.critical("COLLISION ALERT - Emergency stop triggered!")
-                    elif parts[0] == "SCAN":
-                        # Handle scan updates
-                        scan_type = parts[1] if len(parts) > 1 else "UNKNOWN"
-                        if scan_type == "START":
-                            self._scan_in_progress = True
-                            self._scan_results = []
-                            logger.info("360?? scan started")
-                        elif scan_type == "COMPLETE":
-                            self._scan_in_progress = False
-                            logger.info("360?? scan complete with %d positions", len(self._scan_results))
-                        elif scan_type == "POS":
-                            # POS:<angle>,S1:<d1>,S2:<d2>,S3:<d3>
-                            scan_data = ":".join(parts[2:]) if len(parts) > 2 else ""
-                            self._scan_results.append({"raw": scan_data})
-                        elif scan_type == "BEST":
-                            # BEST:<angle>,DIST:<dist>
-                            best_data = ":".join(parts[2:]) if len(parts) > 2 else ""
-                            logger.info("Best direction from scan: %s", best_data)
-                        payload = {"scan": scan_type, "scan_data": ":".join(parts[2:]) if len(parts) > 2 else ""}
-                    else:
-                        payload = {"type": parts[0], "value": ":".join(parts[1:])}
-
-                if self.pub:
-                    publish_json(self.pub, TOPIC_ESP, payload)
-                    logger.debug("Published ESP32 feedback: %s", payload)
-
-            except Exception as e:
-                logger.warning("Failed to process RX: %s", e)
-
-    def _parse_nav_command(self, payload: Dict[str, Any]) -> MotorCommand:
-        """Parse IPC navigation payload into MotorCommand."""
-        direction = payload.get("direction", "stop")
-        speed = int(payload.get("speed", 100))
-        duration = int(payload.get("duration_ms", 0))
-        target = payload.get("target")
-        source = str(payload.get("source", "unknown"))
-
-        logger.info(
-            "nav.command parsed direction=%s speed=%s duration_ms=%s target=%s source=%s",
-            direction,
-            speed,
-            duration,
-            target,
-            source,
-        )
-
-        return MotorCommand(
-            direction=direction,
-            speed=max(0, min(100, speed)),
-            duration_ms=max(0, duration),
-            target=target,
-            source=source,
-        )
-    
-    def request_scan(self) -> bool:
-        """Request a 360-degree environment scan."""
-        if self._scan_in_progress:
-            logger.warning("Scan already in progress")
-            return False
-        return self._send_command(MotorCommand(direction="scan"))
-    
-    def get_sensor_data(self) -> Optional[SensorData]:
-        """Get the latest sensor data."""
-        return self._last_sensor_data
-    
-    def is_safe_to_move(self) -> bool:
-        """Check if it's safe to move forward."""
-        if self._last_sensor_data:
-            return self._last_sensor_data.is_safe
-        return True  # No data yet, assume safe (ESP32 will block anyway)
-
-    def run(self) -> None:
-        """Main bridge loop."""
-        if not self._open_serial():
-            if not self.sim:
-                logger.error("Cannot run bridge without serial port (use --sim for simulation)")
-                return
-
-        # Setup IPC
-        self.sub = make_subscriber(self.config, topic=TOPIC_NAV, channel="downstream")
-        self.pub = make_publisher(self.config, channel="upstream")
-
-        # Start RX thread
-        self._running = True
-        if not self.sim:
-            self._rx_thread = threading.Thread(target=self._rx_loop, daemon=True)
-            self._rx_thread.start()
-
-        logger.info("UART Motor Bridge running (device=%s, sim=%s)", self.device, self.sim)
-
-        try:
-            while self._running:
-                # Check for incoming nav commands (NON-BLOCKING with timeout)
-                try:
-                    # Use poller for non-blocking recv with timeout
-                    if self.sub.poll(timeout=50):  # 50ms timeout
-                        topic, data = self.sub.recv_multipart(zmq.NOBLOCK)
-                        payload = json.loads(data)
-                        logger.info("nav.command received payload=%s", payload)
-                        cmd = self._parse_nav_command(payload)
-                        self._send_command(cmd)
-                except zmq.Again:
-                    pass  # No message available, continue
-                except Exception as e:
-                    logger.error("Failed to process nav command: %s", e)
-
-                # Process any ESP32 feedback
-                self._process_rx()
-
-        except KeyboardInterrupt:
-            logger.info("Bridge interrupted")
-        finally:
-            self._running = False
-            self._close_serial()
-            logger.info("UART Motor Bridge stopped")
-
-    def stop(self) -> None:
-        """Stop the bridge."""
-        self._running = False
-        # Send emergency stop
-        if self.serial and self.serial.is_open:
-            self._send_command(MotorCommand(direction="stop"))
-
-
-def run() -> None:
-    """Legacy entry point for compatibility."""
-    cfg = load_config(Path("config/system.yaml"))
-    bridge = UARTMotorBridge(cfg)
-    bridge.run()
-
-
-def main() -> None:
-    parser = argparse.ArgumentParser(description="UART Motor Bridge for ESP32")
-    parser.add_argument("--sim", action="store_true", help="Run in simulation mode (no serial)")
-    parser.add_argument("--device", default=None, help="Override UART device path")
-    parser.add_argument("--baud", type=int, default=None, help="Override baud rate")
-    args = parser.parse_args()
-
-    cfg = load_config(Path("config/system.yaml"))
-
-    # Apply CLI overrides
-    if args.device:
-        cfg.setdefault("nav", {})["uart_device"] = args.device
-    if args.baud:
-        cfg.setdefault("nav", {})["baud_rate"] = args.baud
-
-    bridge = UARTMotorBridge(cfg, sim=args.sim)
-    bridge.run()
-
-
-if __name__ == "__main__":
-    main()
+#!/usr/bin/env python3
+"""Enhanced UART bridge with bidirectional communication and ESP32 feedback.
+
+Supports:
+- Sending navigation commands to ESP32 motor controller
+- Receiving status/sensor feedback from ESP32
+- Speed control and duration parameters
+- Emergency stop handling
+"""
+from __future__ import annotations
+
+import argparse
+import json
+import threading
+import time
+from collections import deque
+from dataclasses import dataclass
+from pathlib import Path
+from queue import Queue
+from typing import Any, Dict, Optional
+
+from src.core.config_loader import load_config
+from src.core.ipc import (
+    TOPIC_ESP,
+    TOPIC_NAV,
+    make_publisher,
+    make_subscriber,
+    publish_json,
+)
+from src.core.logging_setup import get_logger
+
+import zmq
+
+try:
+    import serial
+    SERIAL_AVAILABLE = True
+except ImportError:
+    serial = None
+    SERIAL_AVAILABLE = False
+
+logger = get_logger("uart.motor_bridge", Path("logs"))
+
+
+@dataclass
+class MotorCommand:
+    """Motor control command structure."""
+    direction: str  # forward, backward, left, right, stop
+    speed: int = 100  # 0-100 percentage
+    duration_ms: int = 0  # 0 = continuous until next command
+    target: Optional[str] = None  # optional vision target
+    source: str = "unknown"
+
+
+@dataclass
+class SensorData:
+    """Parsed sensor data from ESP32."""
+    s1: int = -1  # Sensor 1 distance (cm)
+    s2: int = -1  # Sensor 2 distance (cm)
+    s3: int = -1  # Sensor 3 distance (cm)
+    mq2: int = 0  # Gas sensor value
+    lmotor: int = 0  # Left motor power
+    rmotor: int = 0  # Right motor power
+    obstacle: bool = False  # ESP32 detected obstacle
+    warning: bool = False   # ESP32 in warning zone
+    
+    @property
+    def min_distance(self) -> int:
+        """Get minimum valid distance from all sensors."""
+        valid = [d for d in [self.s1, self.s2, self.s3] if d > 0]
+        return min(valid) if valid else -1
+    
+    @property
+    def is_safe(self) -> bool:
+        """Check if it's safe to move forward."""
+        return not self.obstacle and not self.warning and self.min_distance > 20
+
+
+class UARTMotorBridge:
+    """Bidirectional UART bridge for ESP32 motor control with collision avoidance."""
+
+    # Safety thresholds (backup to ESP32 safety)
+    STOP_DISTANCE_CM = 10
+    WARNING_DISTANCE_CM = 20
+
+    # Default command mapping (can be overridden from config)
+    # Align with ESP32 sketch command tokens in esp-code.ino
+    DEFAULT_COMMANDS = {
+        "forward": "FORWARD",
+        "backward": "BACKWARD",
+        "left": "LEFT",
+        "right": "RIGHT",
+        "stop": "STOP",
+        "status": "STATUS",
+        "reset": "RESET",
+        "scan": "SCAN",
+        "clearblock": "CLEARBLOCK",
+    }
+
+    def __init__(self, config: Dict[str, Any], sim: bool = False):
+        self.config = config
+        self.sim = sim
+        nav_cfg = config.get("nav", {})
+
+        self.device = nav_cfg.get("uart_device", "/dev/ttyAMA0")
+        self.baud = int(nav_cfg.get("baud_rate", 115200))
+        self.timeout = float(nav_cfg.get("timeout", 1.0))
+        self.commands = {**self.DEFAULT_COMMANDS, **nav_cfg.get("commands", {})}
+
+        self.serial: Optional[serial.Serial] = None
+        self._running = False
+        self._rx_queue: Queue = Queue()
+        self._rx_thread: Optional[threading.Thread] = None
+
+        # IPC sockets
+        self.sub: Optional[Any] = None
+        self.pub: Optional[Any] = None
+        
+        # Safety state (Pi-side backup)
+        self._last_sensor_data: Optional[SensorData] = None
+        self._blocked_reason: Optional[str] = None
+        self._scan_in_progress = False
+        self._scan_results: list = []
+        self._sensor_buffer = deque(maxlen=int(nav_cfg.get("sensor_buffer_size", 50)))
+        self._last_rx_log_ts: float = 0.0
+
+    def _open_serial(self) -> bool:
+        """Open serial port connection."""
+        if self.sim:
+            logger.info("UART simulation mode - no serial port opened")
+            return True
+
+        if not SERIAL_AVAILABLE:
+            logger.error("pyserial not installed")
+            return False
+
+        try:
+            self.serial = serial.Serial(
+                port=self.device,
+                baudrate=self.baud,
+                timeout=self.timeout,
+                write_timeout=self.timeout,
+            )
+            logger.info("UART opened: %s @ %d baud", self.device, self.baud)
+            return True
+        except Exception as e:
+            logger.error("Failed to open UART %s: %s", self.device, e)
+            return False
+
+    def _close_serial(self) -> None:
+        """Close serial port."""
+        if self.serial:
+            try:
+                self.serial.close()
+            except Exception:
+                pass
+            self.serial = None
+
+    def _format_command(self, cmd: MotorCommand) -> str:
+        """Format command for ESP32 protocol (esp-code.ino).
+
+        Supported tokens:
+          - FORWARD, BACKWARD, LEFT, RIGHT, STOP, STATUS, RESET
+          - SCAN - 360 degree environment scan
+          - CLEARBLOCK - Clear obstacle block (manual override)
+          - SERVO:<angle> (when target field is used as angle)
+
+        Notes:
+          - The current .ino ignores speed/duration for basic moves; commands
+            are digital full-speed. We emit plain tokens accordingly.
+        """
+        direction = (cmd.direction or "").lower()
+        if direction == "servo":
+            # Use cmd.target to pass the angle when requested
+            try:
+                angle = int(cmd.target) if cmd.target is not None else 90
+            except Exception:
+                angle = 90
+            return f"SERVO:{angle}\n"
+
+        base_cmd = self.commands.get(direction, None)
+        if not base_cmd:
+            # Fallback to STOP if unknown
+            base_cmd = "STOP"
+        return f"{base_cmd}\n"
+    
+    def _parse_sensor_data(self, data_raw: str) -> Optional[SensorData]:
+        """Parse DATA line from ESP32 into SensorData object.
+        
+        Format: S1:<d1>,S2:<d2>,S3:<d3>,MQ2:<v>,SERVO:<a>,LMOTOR:<ls>,RMOTOR:<rs>,OBSTACLE:<0|1>,WARNING:<0|1>
+        """
+        try:
+            parts = data_raw.split(",")
+            data = SensorData()
+            for part in parts:
+                if ":" not in part:
+                    continue
+                key, val = part.split(":", 1)
+                key = key.strip().upper()
+                val = val.strip()
+                if key == "S1":
+                    data.s1 = int(val)
+                elif key == "S2":
+                    data.s2 = int(val)
+                elif key == "S3":
+                    data.s3 = int(val)
+                elif key == "MQ2":
+                    data.mq2 = int(val)
+                elif key == "LMOTOR":
+                    data.lmotor = int(val)
+                elif key == "RMOTOR":
+                    data.rmotor = int(val)
+                elif key == "OBSTACLE":
+                    data.obstacle = val == "1"
+                elif key == "WARNING":
+                    data.warning = val == "1"
+            return data
+        except Exception as e:
+            logger.warning("Failed to parse sensor data: %s - %s", data_raw, e)
+            return None
+    
+    def _check_pi_side_safety(self, cmd: MotorCommand) -> tuple[bool, str]:
+        """Pi-side safety check as backup to ESP32.
+        
+        Returns (allowed, reason) tuple.
+        """
+        direction = (cmd.direction or "").lower()
+        
+        # Always allow stop, backward, turns, and non-movement commands
+        if direction in ("stop", "backward", "left", "right", "status", "reset", "scan", "clearblock", "servo"):
+            return True, ""
+        
+        # For forward, check sensor data
+        if direction == "forward" and self._last_sensor_data:
+            sd = self._last_sensor_data
+            if sd.obstacle:
+                return False, "ESP32 obstacle detected"
+            if sd.warning:
+                return False, "ESP32 warning zone"
+            if sd.min_distance > 0 and sd.min_distance < self.STOP_DISTANCE_CM:
+                return False, f"Pi safety: distance {sd.min_distance}cm < {self.STOP_DISTANCE_CM}cm"
+            if sd.min_distance > 0 and sd.min_distance < self.WARNING_DISTANCE_CM:
+                return False, f"Pi safety: warning zone {sd.min_distance}cm"
+        
+        return True, ""
+
+    def _send_command(self, cmd: MotorCommand) -> bool:
+        """Send command to ESP32 with Pi-side safety check."""
+        # Pi-side safety check (backup to ESP32)
+        allowed, reason = self._check_pi_side_safety(cmd)
+        if not allowed:
+            logger.warning("Command %s BLOCKED by Pi safety: %s", cmd.direction, reason)
+            self._blocked_reason = reason
+            # Publish blocked status
+            if self.pub:
+                publish_json(self.pub, TOPIC_ESP, {
+                    "blocked": True,
+                    "command": cmd.direction,
+                    "reason": reason,
+                    "source": cmd.source,
+                })
+            return False
+        
+        self._blocked_reason = None
+        formatted = self._format_command(cmd)
+
+        if self.sim:
+            logger.info("UART TX payload (sim) direction=%s speed=%s duration_ms=%s target=%s source=%s formatted=%s",
+                        cmd.direction,
+                        cmd.speed,
+                        cmd.duration_ms,
+                        cmd.target,
+                        cmd.source,
+                        formatted.strip())
+            logger.info("[SIM] UART TX: %s", formatted.strip())
+            return True
+
+        if not self.serial or not self.serial.is_open:
+            logger.error("Serial port not open")
+            return False
+
+        try:
+            logger.info(
+                "UART TX payload direction=%s speed=%s duration_ms=%s target=%s source=%s formatted=%s",
+                cmd.direction,
+                cmd.speed,
+                cmd.duration_ms,
+                cmd.target,
+                cmd.source,
+                formatted.strip(),
+            )
+            self.serial.write(formatted.encode("utf-8"))
+            self.serial.flush()
+            logger.info("UART TX: %s (source=%s)", formatted.strip(), cmd.source)
+            return True
+        except Exception as e:
+            logger.error("UART write failed: %s", e)
+            return False
+
+    def _rx_loop(self) -> None:
+        """Background thread for reading ESP32 responses."""
+        while self._running:
+            if self.sim:
+                time.sleep(0.1)
+                continue
+
+            if not self.serial or not self.serial.is_open:
+                time.sleep(0.1)
+                continue
+
+            try:
+                if self.serial.in_waiting > 0:
+                    line = self.serial.readline().decode("utf-8", errors="replace").strip()
+                    if line:
+                        self._rx_queue.put(line)
+                        logger.debug("UART RX: %s", line)
+                else:
+                    # Brief sleep to prevent busy-spin when no data
+                    time.sleep(0.005)  # 5ms - balance responsiveness vs CPU
+            except Exception as e:
+                logger.warning("UART read error: %s", e)
+                time.sleep(0.1)
+
+    def _process_rx(self) -> None:
+        """Process received data from ESP32 and publish to IPC."""
+        while not self._rx_queue.empty():
+            try:
+                line = self._rx_queue.get_nowait()
+                now = time.time()
+                if now - self._last_rx_log_ts >= 1.0:
+                    logger.info("UART RX sample: %s", line)
+                    self._last_rx_log_ts = now
+                # Parse ESP32 feedback (expected format: STATUS:value or JSON)
+                if line.startswith("{"):
+                    # JSON response (future extension)
+                    payload = json.loads(line)
+                else:
+                    # Parse ACK/STATUS and sensor data formats from esp-code.ino
+                    # Examples:
+                    #   ACK:<CMD>:<STATUS>
+                    #   STATUS:SERVO:<angle>,LMOTOR:<ls>,RMOTOR:<rs>
+                    #   DATA:S1:<d1>,S2:<d2>,S3:<d3>,MQ2:<v>,SERVO:<a>,LMOTOR:<ls>,RMOTOR:<rs>,OBSTACLE:<0|1>,WARNING:<0|1>
+                    #   ALERT:COLLISION:<reason>,S1:<d1>,S2:<d2>,S3:<d3>
+                    #   SCAN:START|COMPLETE|POS:<angle>|BEST:<angle>
+                    parts = line.split(":")
+                    if not parts:
+                        payload = {"raw": line}
+                    elif parts[0] == "ACK" and len(parts) >= 3:
+                        payload = {"ack": parts[1], "status": ":".join(parts[2:])}
+                        # Check if forward was blocked by ESP32
+                        if parts[1] == "FORWARD" and "BLOCKED" in parts[2]:
+                            logger.warning("ESP32 blocked FORWARD: %s", parts[2])
+                    elif parts[0] == "STATUS":
+                        payload = {"status_raw": ":".join(parts[1:])}
+                    elif parts[0] == "DATA":
+                        data_raw = ":".join(parts[1:])
+                        sensor_data = self._parse_sensor_data(data_raw)
+                        if sensor_data:
+                            self._last_sensor_data = sensor_data
+                            ts = int(time.time())
+                            frame = {
+                                "ts": ts,
+                                "s1": sensor_data.s1,
+                                "s2": sensor_data.s2,
+                                "s3": sensor_data.s3,
+                                "mq2": sensor_data.mq2,
+                                "lmotor": sensor_data.lmotor,
+                                "rmotor": sensor_data.rmotor,
+                                "min_distance": sensor_data.min_distance,
+                                "obstacle": sensor_data.obstacle,
+                                "warning": sensor_data.warning,
+                                "is_safe": sensor_data.is_safe,
+                            }
+                            self._sensor_buffer.append(frame)
+                            payload = {
+                                "data": {
+                                    "s1": sensor_data.s1,
+                                    "s2": sensor_data.s2,
+                                    "s3": sensor_data.s3,
+                                    "mq2": sensor_data.mq2,
+                                    "lmotor": sensor_data.lmotor,
+                                    "rmotor": sensor_data.rmotor,
+                                    "min_distance": sensor_data.min_distance,
+                                    "obstacle": sensor_data.obstacle,
+                                    "warning": sensor_data.warning,
+                                    "is_safe": sensor_data.is_safe,
+                                },
+                                "data_ts": ts,
+                                "buffer": list(self._sensor_buffer),
+                            }
+                        else:
+                            payload = {"data_raw": data_raw}
+                    elif parts[0] == "ALERT" and len(parts) >= 2:
+                        # Handle collision alerts
+                        alert_type = parts[1] if len(parts) > 1 else "UNKNOWN"
+                        alert_data = ":".join(parts[2:]) if len(parts) > 2 else ""
+                        payload = {"alert": alert_type, "alert_data": alert_data}
+                        logger.warning("ESP32 ALERT: %s - %s", alert_type, alert_data)
+                        # Emergency stop on Pi side too
+                        if alert_type == "COLLISION" and "EMERGENCY" in alert_data:
+                            logger.critical("COLLISION ALERT - Emergency stop triggered!")
+                    elif parts[0] == "SCAN":
+                        # Handle scan updates
+                        scan_type = parts[1] if len(parts) > 1 else "UNKNOWN"
+                        if scan_type == "START":
+                            self._scan_in_progress = True
+                            self._scan_results = []
+                            logger.info("360?? scan started")
+                        elif scan_type == "COMPLETE":
+                            self._scan_in_progress = False
+                            logger.info("360?? scan complete with %d positions", len(self._scan_results))
+                        elif scan_type == "POS":
+                            # POS:<angle>,S1:<d1>,S2:<d2>,S3:<d3>
+                            scan_data = ":".join(parts[2:]) if len(parts) > 2 else ""
+                            self._scan_results.append({"raw": scan_data})
+                        elif scan_type == "BEST":
+                            # BEST:<angle>,DIST:<dist>
+                            best_data = ":".join(parts[2:]) if len(parts) > 2 else ""
+                            logger.info("Best direction from scan: %s", best_data)
+                        payload = {"scan": scan_type, "scan_data": ":".join(parts[2:]) if len(parts) > 2 else ""}
+                    else:
+                        payload = {"type": parts[0], "value": ":".join(parts[1:])}
+
+                if self.pub:
+                    publish_json(self.pub, TOPIC_ESP, payload)
+                    logger.debug("Published ESP32 feedback: %s", payload)
+
+            except Exception as e:
+                logger.warning("Failed to process RX: %s", e)
+
+    def _parse_nav_command(self, payload: Dict[str, Any]) -> MotorCommand:
+        """Parse IPC navigation payload into MotorCommand."""
+        direction = payload.get("direction", "stop")
+        speed = int(payload.get("speed", 100))
+        duration = int(payload.get("duration_ms", 0))
+        target = payload.get("target")
+        source = str(payload.get("source", "unknown"))
+
+        logger.info(
+            "nav.command parsed direction=%s speed=%s duration_ms=%s target=%s source=%s",
+            direction,
+            speed,
+            duration,
+            target,
+            source,
+        )
+
+        return MotorCommand(
+            direction=direction,
+            speed=max(0, min(100, speed)),
+            duration_ms=max(0, duration),
+            target=target,
+            source=source,
+        )
+    
+    def request_scan(self) -> bool:
+        """Request a 360-degree environment scan."""
+        if self._scan_in_progress:
+            logger.warning("Scan already in progress")
+            return False
+        return self._send_command(MotorCommand(direction="scan"))
+    
+    def get_sensor_data(self) -> Optional[SensorData]:
+        """Get the latest sensor data."""
+        return self._last_sensor_data
+    
+    def is_safe_to_move(self) -> bool:
+        """Check if it's safe to move forward."""
+        if self._last_sensor_data:
+            return self._last_sensor_data.is_safe
+        return True  # No data yet, assume safe (ESP32 will block anyway)
+
+    def run(self) -> None:
+        """Main bridge loop."""
+        if not self._open_serial():
+            if not self.sim:
+                logger.error("Cannot run bridge without serial port (use --sim for simulation)")
+                return
+
+        # Setup IPC
+        self.sub = make_subscriber(self.config, topic=TOPIC_NAV, channel="downstream")
+        self.pub = make_publisher(self.config, channel="upstream")
+
+        # Start RX thread
+        self._running = True
+        if not self.sim:
+            self._rx_thread = threading.Thread(target=self._rx_loop, daemon=True)
+            self._rx_thread.start()
+
+        logger.info("UART Motor Bridge running (device=%s, sim=%s)", self.device, self.sim)
+
+        try:
+            while self._running:
+                # Check for incoming nav commands (NON-BLOCKING with timeout)
+                try:
+                    # Use poller for non-blocking recv with timeout
+                    if self.sub.poll(timeout=50):  # 50ms timeout
+                        topic, data = self.sub.recv_multipart(zmq.NOBLOCK)
+                        payload = json.loads(data)
+                        logger.info("nav.command received payload=%s", payload)
+                        cmd = self._parse_nav_command(payload)
+                        self._send_command(cmd)
+                except zmq.Again:
+                    pass  # No message available, continue
+                except Exception as e:
+                    logger.error("Failed to process nav command: %s", e)
+
+                # Process any ESP32 feedback
+                self._process_rx()
+
+        except KeyboardInterrupt:
+            logger.info("Bridge interrupted")
+        finally:
+            self._running = False
+            self._close_serial()
+            logger.info("UART Motor Bridge stopped")
+
+    def stop(self) -> None:
+        """Stop the bridge."""
+        self._running = False
+        # Send emergency stop
+        if self.serial and self.serial.is_open:
+            self._send_command(MotorCommand(direction="stop"))
+
+
+def run() -> None:
+    """Legacy entry point for compatibility."""
+    cfg = load_config(Path("config/system.yaml"))
+    bridge = UARTMotorBridge(cfg)
+    bridge.run()
+
+
+def main() -> None:
+    parser = argparse.ArgumentParser(description="UART Motor Bridge for ESP32")
+    parser.add_argument("--sim", action="store_true", help="Run in simulation mode (no serial)")
+    parser.add_argument("--device", default=None, help="Override UART device path")
+    parser.add_argument("--baud", type=int, default=None, help="Override baud rate")
+    args = parser.parse_args()
+
+    cfg = load_config(Path("config/system.yaml"))
+
+    # Apply CLI overrides
+    if args.device:
+        cfg.setdefault("nav", {})["uart_device"] = args.device
+    if args.baud:
+        cfg.setdefault("nav", {})["baud_rate"] = args.baud
+
+    bridge = UARTMotorBridge(cfg, sim=args.sim)
+    bridge.run()
+
+
+if __name__ == "__main__":
+    main()
